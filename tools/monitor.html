<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset=utf-8 http-equiv="Content-Language" content="en" />
	<link rel="icon" href="icon-monitor.png">
	<title>MAOS Monitor</title>
	<style type="text/css">
		html {
			font-family: Arial;
			font-size: 14px;
		}
		/* CSS notes:
			A,B: match either A or B
			A B: matches B inside A
			table: type selector
			.title: class selector
			
			tr: table row
			td: table data
			th: table header, replaced td

			margin is space outside of border (how far the element is from other elements around it). 
				outline is a line outside of the border. does not affect layout or spacing (fills margin)
			border: top,right,bottom,left
			padding is space between content and border
			color is for text color
		*/

		table.monitor {
			border-spacing: 0 0;
			border-style: solid;
			border-color: black;
			border-width: 2px 1px 1px 2px;
			table-layout: fixed;
			max-width: 100%;
		}
		table.monitor tr{
			width: 100%;
			max-width:200em;
		}
		table.monitor tr td,th {
			border-width: 0.5px 0.5px;
			border-style: solid;
			border-color: #AAA;
			white-space: nowrap;
			vertical-align: middle;
		}
		table.monitor td {
			text-align: right;
		}
		table.monitor th {
			text-align: center;
		}

		table.monitor tr:nth-child(odd) {
			background-color: #EEE
		}

		table.monitor .tdpath {
			width: 50%;
			max-width: 100px;/*this allows ellipsis*/
			overflow: hidden;
			text-overflow: ellipsis; 
		}
		table.monitor .tdout {
			width: 50%;
			max-width: 100px;/*this allows ellipsis*/
			overflow: hidden;
			text-overflow: ellipsis; 
		}
		table.monitor td.tdout{ /*use td.tdout, not td .tdout or .tdout td*/
			text-align: left;
		}
		table.monitor td.tdout details summary{/*not effective*/
			overflow: hidden; 
			text-overflow: ellipsis; 
		}
		table.monitor td.tdout details p{
			font-family: roboto mono, monospace;
			font-size: 12px;
			white-space: normal;
		}

		div.progress {
			position: relative;
			text-align: left;
		}

		div.progressbar {
			background: #3584E4;
			height: 20px;
		}

		span.progressbar {
			position: absolute;
			top: 2px;
			z-index: 2;
			text-align: left;
			width: 100%;
		}

		div.tab_hosts {
			background: #BFBFBF;
		}

		div.tab_hosts ul {
			list-style: none;
			overflow: hidden;
			padding: 0px;
			margin: 0px;
		}

		div.tab_hosts ul li {
			display: inline-block;/*inline ignores vertical padding*/
			padding: 5px;
			cursor: pointer;
			font-size: 16px;
		}

		div.tab_hosts ul li:hover,
		div.tab_hosts ul li.active {
			color: #7d7d7d;
			background: #EFEFEF;
		}
	</style>
</head>

<body>
	<header></header>
	<article>
		<table style="margin: 0 auto;">
			<tr>
				<td><img src="icon-monitor.png" alt="icon" style="width: 36px; vertical-align: middle; margin-right: 0px;"></td>
				<td style="font-size:28px;font-family:Arial;">MAOS Monitor</td>
			</tr>
		</table>
		<div class="tab_hosts">
			<ul id="tab_hosts">
				<li><span onclick="clear_all(0)">Clear Finished</span></li>
				<li><span onclick="clear_all(1)">Clear Skipped</span></li>
				<li><span onclick="clear_all(2)">Clear Crashed</span></li>
				<li><span onclick="kill_all()">Kill All</span></li>
				<li><input id="hostname_input"></li>
				<li><span onclick="add_host()">Add host</span></li>
			</ul>
		</div>
	</article>

	<script>
		/*JS notes:
			var is global or functional scope
			let and const is block scope
		*/
		let cur_hostname;//current active hostname
		let port=0;
		document.getElementById("hostname_input").addEventListener("keyup", function (event) {
			if (event.key === "Enter") {
				add_host();
			}
		})
		function notify(msg, host, iconurl) {
			if (!("Notification" in window)) {
				return;
			} else if (Notification.permission === "granted") {
				notification = new Notification(msg, { tag: 'maos_' + host, icon: iconurl });
			} else if (Notification.permission !== "denied") {
				Notification.requestPermission(function (permission) {
					if (permission === "granted") {
						notification = new Notification(msg, { tag: 'maos_' + host, icon: iconurl });
					}
				});
			}
		}
		let socket_lms = {};
		function clear_all(kind) {
			const hostname = cur_hostname;
			if (socket_lms[hostname]===undefined || socket_lms[hostname].readyState > 1){
				console.log("server is not ready:", hostname);
				return
			}
			const joblist = get_joblist(hostname);
			cmd = [];
			for (irow = 1; irow < joblist.rows.length; irow++) {
				const status = joblist.rows[irow].cells[tcol.ICON].firstChild.getAttribute("status");
				const frac = joblist.rows[irow].cells[tcol.PROG].firstChild.childNodes[1].innerHTML;
				if (status == 11 && (kind == 0 || (kind == 1 && frac === "")) || (status > 11 && kind == 2)) {
					const pid = joblist.rows[irow].cells[tcol.ICON].firstChild.getAttribute("pid");
					cmd[cmd.length] = pid + "&REMOVE;";
				}
			}
			for (icmd = 0; icmd < cmd.length; icmd++) {
				socket_lms[hostname].send(cmd[icmd]);
			}
		}
		function kill_all() {
			if (socket_lms[hostname] === undefined || socket_lms[hostname].readyState > 1) {
				console.log("server is not ready:", hostname);
				return
			}
			
			const hostname = cur_hostname;
			cmd = [];
			const joblist = get_joblist(hostname)
			for (irow = 1; irow < joblist.rows.length; irow++) {
				const status = joblist.rows[irow].cells[tcol.ICON].firstChild.getAttribute("status");
				const pid = joblist.rows[irow].cells[tcol.ICON].firstChild.getAttribute("pid");
				if (status < 10) {
					cmd[cmd.length] = pid + "&KILL;";
				}
			}
			if (window.confirm("Kill all "+cmd.length+" jobs on " + hostname + "?")) {
				for (icmd = 0; icmd < cmd.length; icmd++) {
					socket_lms[hostname].send(cmd[icmd]);
				}
			}
		}

		let pcol;

		const tcol = {//table columns
			TIME: 0,
			PID: 1,
			PATH: 2,
			OUT: 3,
			LOW: 4,
			HIGH: 5,
			STEP: 6,
			PROG: 7,
			ICON: 8,
			TOT: 9,
		};
		const icol={//status keys
			//pid, STATUS/PATH, pidnew, status, start time, errhi, errlo, iseed, nseed, isim, nsim, rest, tot, step timing
			PID:0,
			TAG:1,//PATH or STATUS
			VALUE:2,//Command line if TAG==PATH; new PID if TAG==STATUS
			STATUS:3,
			TSTART:4,
			ERRHI:5,
			ERRLO:6,
			ISEED:7,
			NSEED:8,
			ISIM:9,
			NSIM:10,
			TREST:11,
			TTOTAL:12,
			TSTEP:13,
			TOT:14,
		};
		const sval={//status values. see sys/scheduler.h
			RUNNING:1,
			WAIT:2,
			START:3,
			QUEUED:4,
			FINISH:11,
			CRASH:12,
			TOKILL:13,
			REMOVE:14,
			KILLED:15,
		};
		function new_progbar(width) {
			const div1 = document.createElement("div");
			div1.className = "progress";
			div1.style.width = width;
			const div2 = document.createElement("div");
			div2.className = "progressbar";
			div2.style.width = "0%";
			const span1 = document.createElement("span");
			span1.className = "progressbar";
			span1.innerHTML = "";
			div1.appendChild(div2);
			div1.appendChild(span1);
			return div1;
		}
		function progbar_set(progbar, frac, text) {
			progbar.childNodes[0].style.width = frac + '%';
			progbar.childNodes[1].innerHTML = text;
		}
		function new_button(name) {
			//img is faster than input when switching tabs. 
			//const button = document.createElement("input");
			//button.type = "image";
			const button= document.createElement("img");
			button.src = name;
			button.setAttribute("url", name);
			return button;
		}
		function get_joblist(hostname){
			const joblist_id= "joblist_" + hostname.split(":")[0];
			const s_tab_content = "tab_content_" + hostname;
			let joblist = document.getElementById(joblist_id);
			if(!joblist){
				//Create a div for containing host data
				newdiv = document.createElement('div');
				newdiv.name = "tab_content";
				newdiv.id = s_tab_content;
				newdiv.className = "tab_content";
				//Create a table for containing jobs
				joblist = document.createElement('table');
				joblist.id = joblist_id;
				joblist.className = "monitor";
				joblist.innerHTML = ' <tr> <th>Time</th> <th>PID</th><th class="tdpath">Path</th> <th class="tdout">Dir Out</th> <th>Low</th> <th>High</th><th>Step</th><th>Progress</th><th></th></tr>';
				newdiv.appendChild(joblist);
				document.body.appendChild(newdiv);
			}
			return joblist
		}
		const button_wait = new_button("icon-waiting.png");
		const button_ok = new_button("icon-finished.png");
		const button_play = new_button("icon-play.png");
		const button_skip = new_button("icon-skip.png");
		const button_err = new_button("icon-error.png");
		let pos = 0;
		function sec2str(secstr) {//agrees with C function output
			let sec;
			try{
				sec = parseFloat(secstr);
			}catch(error){
				console.log(error)
				return '';
			}
			if(sec<=0){
				sec=0;
			}
			const hr = Math.floor(sec/3600); sec=sec-hr*3600;
			let min = Math.floor(sec/60); sec=sec-min*60;
			let res='';
			if (hr>0){
				res=res+ hr + 'h';
				sec=0;
				if(hr>5){
					min=0;
				}
			}
			if(min>0){
				res=res + min+'m';
				if(min>5){
					sec=0;
				}else{
					sec=Math.round(sec);
				}
			}
			if(sec>10){
				res=res+sec.toFixed(0);
			}else if(sec>0){
				res=res+sec.toPrecision(2);
			}else if(res==''){
				res='0'
			}
			return res;
		}
		function get_hostname() {
			let u = document.URL;
			if (u.substring(0, 5) == "https") {
				pcol = "wss://";
				u = u.substr(8);
			} else {
				pcol = "ws://";
				if (u.substring(0, 4) == "http")
					u = u.substr(7);
			}
			u = u.split('/')[0];
			return u;
		}

		/* maos-monitor protocol */
		function setchild(cell, button) {
			if (cell.firstChild) {
				cell.replaceChild(button.cloneNode(false), cell.firstChild);
			} else {
				cell.appendChild(button.cloneNode(false));
			}
		}
		function websocket_start(node) {
			const hostname = node.id;
			if (typeof hostname == 'undefined' || (typeof socket_lms[hostname] != 'undefined' && socket_lms[hostname].readyState <=1 )) {
				console.log("Connection in progress to " + hostname);
				return;
			}
			console.log("Connecting to " + hostname);
			const hostname2=hostname.split(':')[0].split('.')[0]
			const joblist = get_joblist(hostname)
			let socket_lm;
			if (typeof MozWebSocket != "undefined") {/* + "/xxx" bit is for IE10 workaround */
				socket_lm = new MozWebSocket(pcol + hostname + "/xxx", "maos-monitor-protocol");
			} else {
				socket_lm = new WebSocket(pcol + hostname + "/xxx", "maos-monitor-protocol");
			}
			socket_lms[hostname] = socket_lm
			socket_lm.onopen = function () {//change tab color upon connecton
				console.log('Websocket open from ' + hostname);
				node.style.color = "#4885DD";
				const nrow = joblist.rows.length;
				for (irow = 1; irow < nrow; irow++) {
					joblist.deleteRow(-1);
				}
			}
			socket_lm.onerror = function (error) {
				console.log('Websocket error: ' + error);
				//onclose is auto called on error
			}
			socket_lm.onclose = function () {//try to auto-reconnect
				console.log('Websocket closed from ' + hostname);
				node.style.color = "#9d4040";
				socket_lms[hostname] == undefined
				setTimeout(function(){websocket_start(node)}, 10000);//10 seconds
			}
			socket_lm.onmessage = function got_packet(msg) {
				//console.log('message received from '+hostname +msg.data);
				let j;
				if (msg.data.indexOf('$')!=-1){
					j = msg.data.split('$'); //newer format to avoid conflict with actual data.
				}else{
					j = msg.data.split(';');
				}
				//console.log(msg.data);
				//pid, STATUS/PATH, pidnew, status, start time, errhi, errlo, iseed, nseed, isim, nsim, rest, tot, step timing
				for (let f = 0; f < j.length - 1; f++) {
					let i = j[f].split('&');
					if(i.length!=3 && i.length!=14){
						console.log("Data from ", hostname2, msg.data, "has ", i.length, " fields:",  i)
						continue;
					}
					const row_id=hostname2+'_pid'+i[icol.PID];
					let row=document.getElementById(row_id);
					if(i.length==icol.TOT && i[icol.STATUS] == sval.REMOVE) {/*remove*/
						if (row){//row maybe none if already removed
							row.parentNode.removeChild(row);//faster than deleteRow
						}
						continue;
					}
					if(!row){
						row = joblist.insertRow(-1);
						row.id=row_id;
						for (let j = 0; j < tcol.TOT; j++) {
							row.insertCell(-1);
						}
						row.cells[tcol.PATH].className = "tdpath";
						row.cells[tcol.OUT].className = "tdout";
						row.cells[tcol.PID].innerHTML = i[icol.PID];
						row.cells[tcol.PROG].appendChild(new_progbar("160px"));
					}
					if (i.length==3 && i[icol.TAG] == 'PATH') {//Only path is sent
						const ispace=i[icol.VALUE].indexOf(" ");
						if(ispace>-1){
							row.cells[tcol.PATH].innerHTML=i[icol.VALUE].substring(0,ispace);
							if(row.cells[tcol.PATH].innerHTML.length>100){
								row.cells[tcol.PATH].setAttribute("title", row.cells[tcol.PATH].innerHTML);
							}
							i[icol.VALUE]=i[icol.VALUE].substring(ispace);
						}
						const io = i[icol.VALUE].lastIndexOf("-o");
						if (io > -1) {
							const dirout = i[icol.VALUE].substr(io + 2).trim().split(' ')[0];
							//row.cells[cols.OUT].innerHTML = i[icol.VALUE].substr(io + 2).trim().split(' ')[0];
							i[icol.VALUE] = i[icol.VALUE].replace(/[ \t]+-o[ \t]+[^ \t]+/g, " ");
							if(i[icol.VALUE]==""){
								row.cells[tcol.OUT].innerHTML = dirout;
							}else{
								row.cells[tcol.OUT].innerHTML = '<details><summary>' + dirout + '</summary><p>' + i[icol.VALUE] + '</p></details>';
							}
						}else{
							row.cells[tcol.OUT].innerHTML = i[icol.VALUE];
						}
					} else if(i.length==icol.TOT) {//status update
						if (i[icol.PID] != i[icol.VALUE]) {//new pid for queued job
							i[icol.PID] = i[icol.VALUE];
							row.cells[tcol.PID].innerHTML = i[icol.PID];
							row.id=hostname2+'_pid'+i[icol.PID];//update id
						}
						if(i[icol.TSTART] === undefined){
							console.log("errr found:", i);
						}
						i[icol.STATUS]=parseInt(i[icol.STATUS]);
						i[icol.TREST]=parseInt(i[icol.TREST]);
						i[icol.TTOTAL]=parseInt(i[icol.TTOTAL]);
						row.cells[tcol.TIME].innerHTML = i[icol.TSTART];
						if (i[icol.STATUS] == sval.RUNNING || (i[icol.STATUS] >=sval.FINISH && i[icol.TTOTAL]>0)) {
							row.cells[tcol.LOW].innerHTML = i[icol.ERRLO];
							row.cells[tcol.HIGH].innerHTML = i[icol.ERRHI];
							let frac = 0;
							if (i[icol.TTOTAL] > 0) {
								frac = Math.round(100*(1-i[icol.TREST]/i[icol.TTOTAL]));
							}
							progbar_set(row.cells[tcol.PROG].firstChild, frac, i[icol.ISEED]+'/'+i[icol.NSEED]+' '+i[icol.ISIM]+'/'+i[icol.NSIM] +' '+ sec2str(i[icol.TREST]) + '/' + sec2str(i[icol.TTOTAL]));
							row.cells[tcol.STEP].innerHTML=sec2str(i[icol.TSTEP]);
						}
						const cell_btn = row.cells[tcol.ICON];
						if(!cell_btn.firstChild || cell_btn.firstChild.getAttribute("status") != i[icol.STATUS]) {
							if (i[icol.STATUS] == sval.RUNNING) {//running
								setchild(cell_btn, button_play);
							} else if (i[icol.STATUS] == sval.WAIT) {//waiting
								setchild(cell_btn, button_wait);
							} else if (i[icol.STATUS] == sval.START) {//started
								setchild(cell_btn, button_play);
							} else if (i[icol.STATUS] == sval.QUEUED) {//queued
								setchild(cell_btn, button_wait);
							} else if (i[icol.STATUS] == sval.FINISH) {//finished
								if (i[icol.TTOTAL] >0 ) {//not skipped
									if (cell_btn.firstChild) {//change of status
										notify('task ' + row.cells[tcol.PID].innerHTML + ' finished on ' + hostname2, hostname2 + '_ok', "icon-finished.png");
									}
									setchild(cell_btn, button_ok);
								}else{
									setchild(cell_btn, button_skip);
								}
								
							} else if (i[icol.STATUS] == sval.CRASH || i[icol.STATUS] == sval.KILLED) {//crashed or killed
								if (cell_btn.firstChild) {//change of status
									notify('task ' + row.cells[tcol.PID].innerHTML + ' crashed on ' + hostname2, hostname2 + '_err', "icon-error.png");
								}
								setchild(cell_btn, button_err);
								row.cells[tcol.PROG].firstChild.childNodes[0].style.background = "red";
							}
							try{
								cell_btn.firstChild.setAttribute("pid", i[icol.PID]);
							}catch(error){
								console.log(error, i);
							}
							cell_btn.firstChild.setAttribute("status", i[icol.STATUS]);
							cell_btn.firstChild.onclick = function () {
								pid = this.getAttribute("pid");
								status = this.getAttribute("status");
								if (status < sval.FINISH) {
									if (window.confirm("Kill the job " + pid + "?")) {
										socket_lm.send(pid + "&KILL;");
									}
								} else {
									socket_lm.send(pid + "&REMOVE;");
									row.removeAttribute('id');
									row.parentNode.removeChild(row);
								}
							}

						}
					}else{
						console.log("Error data from ", hostname2, msg.data);
					}
				}
			}
		}


		function switch_tabs(li) {
			let hideonly=0;
			let node;
			let hostname;
			let s_tab_content;
			if(li.classList.contains("tabhost")){
				node = li.firstChild;
				console.log("switch_tabs:" + node.id);
			}else{
				console.log("switch_tabs: not a host"+li.className);
				hideonly=1;
			}
			const nodes = document.getElementsByClassName("tabhost");
			for (let x = 0; x < nodes.length; x++) {
				nodes[x].className = nodes[x].className.replace(" active", "");
			}
			if(!hideonly){
				li.className += " active";
				hostname = node.id;
				cur_hostname = hostname;
				// contents for each host.
				s_tab_content = "tab_content_" + hostname;
			}
			
			const contents = document.getElementsByClassName("tab_content");
			let found = 0;
			for (let x = 0; x < contents.length; x++) {
				if (contents[x].id == s_tab_content) {
					contents[x].style.display = "block";
					found = 1;
				} else {
					contents[x].style.display = "none";
				}
			}
			if(!hideonly){
				if (typeof hostname != 'undefined' && typeof socket_lms[hostname] == 'undefined' || socket_lms[hostname].readyState>1) {
					websocket_start(node);
				}
			}
		}
		function add_host(hostname) {
			if (!hostname) {
				hostname = document.getElementById("hostname_input").value;
			}
			if (hostname.length == 0) return;
			if (hostname.split(':').length==1){
				if (port!=0){
					hostname=hostname+':'+port;
				}else{
					document.getElementById("hostname_input").value="please specify host:port";
					return;
				}
			}else{
				port=hostname.split(':')[1];
			}
			hostname2 = hostname.split(':')[0].split('.')[0];
			if (hostname2.length == 0) {
				console.log("Host " + hostname + " is invalid");
				remove_hostname(hostname);
				return;
			}
			save_hostname(hostname);
			const hosts = document.getElementsByClassName("tabhost");
			for (let ih = 0; ih < hosts.length; ih++) {
				//if (hosts[ih].firstChild.innerHTML == hostname.split(':')[0]) {
				if (hosts[ih].firstChild.id == hostname) {
					console.log("Host " + hostname + " already exists");
					return;
				}
			}
			//li is contains the name and close button for each host
			const li = document.createElement("li");
			li.className = "tabhost";
			//node contains the name of each host
			const node = document.createElement("span");
			node.appendChild(document.createTextNode(hostname2));
			node.id = hostname;

			node.onclick = function () { switch_tabs(li); };

			const closebtn = document.createElement("span");
			closebtn.appendChild(document.createTextNode(" \u00D7 "));
			closebtn.className = "close";
			closebtn.onclick = function () {
				const parent=li.parentNode;
				parent.removeChild(li);
				switch_tabs(parent.lastChild);
				socket_lms[hostname].onclose();
				remove_hostname(hostname);
				get_joblist(hostname).remove();
			}
			li.appendChild(node);
			li.appendChild(closebtn);
			document.getElementById("tab_hosts").appendChild(li);

			node.onclick();
		}
		function remove_hostname(host){
			localStorage.hosts = localStorage.hosts.replace(';' + host, '');
		}
		function save_hostname(host) {
			if (!localStorage.hosts.includes(";" + host + ";")) {
				localStorage.hosts += host + ";";
			}
		}
		if (typeof (localStorage.hosts) === "undefined") {
			localStorage.hosts = ";";
		}
		save_hostname(get_hostname());
		console.log("localStorage.hosts=" + localStorage.hosts);
		localStorage.hosts.split(";").forEach(function (host) { add_host(host); });
	</script>

</body>

</html>
