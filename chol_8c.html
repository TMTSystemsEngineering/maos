<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>maos-0.6.1: lib/chol.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lib/chol.c File Reference</h1>Wraps the CHOLESKY Library to provide a simple interface.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e7e001251de0d24c5fb7ece1fe256ad1"></a><!-- doxytag: member="chol.c::sp2chol" ref="e7e001251de0d24c5fb7ece1fe256ad1" args="(dsp *A)" -->
static cholmod_sparse *&nbsp;</td><td class="memItemRight" valign="bottom"><b>sp2chol</b> (<a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4cd34c53318702b084bd737ce2e43c14"></a><!-- doxytag: member="chol.c::d2chol" ref="4cd34c53318702b084bd737ce2e43c14" args="(const dmat *A)" -->
static cholmod_dense *&nbsp;</td><td class="memItemRight" valign="bottom"><b>d2chol</b> (const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#b1c164cb862233f91bac0baa84e0804c">chol_sp</a> (spchol *A, int keep)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert spchol to sparse matrix.  <a href="#b1c164cb862233f91bac0baa84e0804c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">spchol *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#43ab12416b0a5f5b4bb88587edbb9b12">chol_factorize</a> (<a class="el" href="structdsp.html">dsp</a> *A_in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factorize a sparse array into LL'.  <a href="#43ab12416b0a5f5b4bb88587edbb9b12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#da0ce1a175b77c9e140d8c826ff88907">chol_solve</a> (<a class="el" href="structdmat.html">dmat</a> **x, spchol *A, const <a class="el" href="structdmat.html">dmat</a> *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve A*x=Y where the cholesky factor of A is stored in A.  <a href="#da0ce1a175b77c9e140d8c826ff88907"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#7a999102f2b6b345ff1ed7aff6e7a841">chol_free_do</a> (spchol *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free cholesky factor.  <a href="#7a999102f2b6b345ff1ed7aff6e7a841"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#3ff611672c83dc9ccf8f53ca9e299e71">chol_save</a> (spchol *A, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save cholesky factor: the lower left side and permutation vector.  <a href="#3ff611672c83dc9ccf8f53ca9e299e71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#6af1b2b392e60a455a9b01cfec1ddbd3">chol_convert</a> (<a class="el" href="structdsp.html">dsp</a> **Cs, long **Cp, spchol *A, int keep)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the internal data type cholesky factor into the lower left diagonal and permutation vector.  <a href="#6af1b2b392e60a455a9b01cfec1ddbd3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b04a632ad4b8ee8ec209e70e535c206f"></a><!-- doxytag: member="chol.c::chol_perm_f" ref="b04a632ad4b8ee8ec209e70e535c206f" args="(dmat **out, long *perm, const dmat *in)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>chol_perm_f</b> (<a class="el" href="structdmat.html">dmat</a> **out, long *perm, const <a class="el" href="structdmat.html">dmat</a> *in)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="67531603f7f798efdb636f353cbb880c"></a><!-- doxytag: member="chol.c::chol_perm_b" ref="67531603f7f798efdb636f353cbb880c" args="(dmat **out, long *perm, const dmat *in)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>chol_perm_b</b> (<a class="el" href="structdmat.html">dmat</a> **out, long *perm, const <a class="el" href="structdmat.html">dmat</a> *in)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#54fd8616ad9eee6993bdeab95e2d7f33">chol_solve_lower</a> (<a class="el" href="structdmat.html">dmat</a> **x, <a class="el" href="structdsp.html">dsp</a> *A, long *perm, const <a class="el" href="structdmat.html">dmat</a> *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve A*x=Y where the A=LL' and L is stored in A.  <a href="#54fd8616ad9eee6993bdeab95e2d7f33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#ef52e878eb677dfb7e6f655ebb27e4f3">chol_solve_upper</a> (<a class="el" href="structdmat.html">dmat</a> **x, <a class="el" href="structdsp.html">dsp</a> *A, long *perm, const <a class="el" href="structdmat.html">dmat</a> *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve A*x=Y where the A=U'U and U is stored in A.  <a href="#ef52e878eb677dfb7e6f655ebb27e4f3"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Wraps the CHOLESKY Library to provide a simple interface. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="b1c164cb862233f91bac0baa84e0804c"></a><!-- doxytag: member="chol.c::chol_sp" ref="b1c164cb862233f91bac0baa84e0804c" args="(spchol *A, int keep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdsp.html">dsp</a>* chol_sp           </td>
          <td>(</td>
          <td class="paramtype">spchol *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>keep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert spchol to sparse matrix. 
<p>
keep=1: A is kept intact, otherwise destroyed. The matrix is in lower left side.<p>
This routine works only if the factor is using simplicity factor. not supernodal. so, in chol_factorize, we have set c.final_super=0, so that the final result is always in simplicity factor. <div class="fragment"><pre class="fragment"><a name="l00066"></a>00066                                         {
<a name="l00067"></a>00067     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l00068"></a>00068 
<a name="l00069"></a>00069     cholmod_factor *L;
<a name="l00070"></a>00070     <span class="keywordflow">if</span>(keep){
<a name="l00071"></a>00071     L=cholmod_l_copy_factor(A-&gt;L, &amp;(A-&gt;c));
<a name="l00072"></a>00072     }<span class="keywordflow">else</span>{
<a name="l00073"></a>00073     L=A-&gt;L;
<a name="l00074"></a>00074     }
<a name="l00075"></a>00075     cholmod_sparse *B=cholmod_l_factor_to_sparse(L, &amp;(A-&gt;c));
<a name="l00076"></a>00076     <a class="code" href="structdsp.html" title="a sparse array of double numbers stored in compressed column format, i.e.">dsp</a> *out=<a class="code" href="dsp_8h.html#ad23f2152cd2622871367fd28ac0ff6b" title="Create a nx*ny X(sp) matrix with memory for nmax max elements allocated.">spnew</a>(B-&gt;nrow, B-&gt;ncol, 0);
<a name="l00077"></a>00077     <span class="comment">//out-&gt;m=B-&gt;nrow;</span>
<a name="l00078"></a>00078     <span class="comment">//out-&gt;n=B-&gt;ncol;</span>
<a name="l00079"></a>00079     out-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>=B-&gt;p;
<a name="l00080"></a>00080     out-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>=B-&gt;i;
<a name="l00081"></a>00081     out-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>=B-&gt;x;
<a name="l00082"></a>00082     out-&gt;<a class="code" href="structdsp.html#870a449e24356b8a08ec11a4916be6a0" title="maximum number of entries">nzmax</a>=B-&gt;nzmax;
<a name="l00083"></a>00083     free(B);
<a name="l00084"></a>00084     cholmod_l_free_factor(&amp;L, &amp;(A-&gt;c));
<a name="l00085"></a>00085     <span class="keywordflow">if</span>(!keep){
<a name="l00086"></a>00086     cholmod_l_finish(&amp;(A-&gt;c));
<a name="l00087"></a>00087     free(A);
<a name="l00088"></a>00088     }
<a name="l00089"></a>00089     <span class="keywordflow">return</span> out;
<a name="l00090"></a>00090 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="43ab12416b0a5f5b4bb88587edbb9b12"></a><!-- doxytag: member="chol.c::chol_factorize" ref="43ab12416b0a5f5b4bb88587edbb9b12" args="(dsp *A_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spchol* chol_factorize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A_in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Factorize a sparse array into LL'. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00094"></a>00094                                  {
<a name="l00095"></a>00095     <span class="keywordflow">if</span>(!A_in) <span class="keywordflow">return</span> NULL;
<a name="l00096"></a>00096     TIC;tic;
<a name="l00097"></a>00097     spchol *out=calloc(1, <span class="keyword">sizeof</span>(spchol));
<a name="l00098"></a>00098     cholmod_l_start(&amp;out-&gt;c);
<a name="l00099"></a>00099     cholmod_sparse *A=sp2chol(A_in);
<a name="l00100"></a>00100     out-&gt;c.status=CHOLMOD_OK;
<a name="l00101"></a>00101     out-&gt;c.final_super=0;
<a name="l00102"></a>00102     {
<a name="l00103"></a>00103     <span class="comment">//Try AMD ordering only. SLOW</span>
<a name="l00104"></a>00104     <span class="comment">/*</span>
<a name="l00105"></a>00105 <span class="comment">      out-&gt;c.nmethods=1;</span>
<a name="l00106"></a>00106 <span class="comment">      out-&gt;c.method[0].ordering=CHOLMOD_AMD;</span>
<a name="l00107"></a>00107 <span class="comment">      out-&gt;c.postorder=1;</span>
<a name="l00108"></a>00108 <span class="comment">      out-&gt;c.supernodal=CHOLMOD_SIMPLICIAL;//force simplicial only.</span>
<a name="l00109"></a>00109 <span class="comment">    */</span>
<a name="l00110"></a>00110     }
<a name="l00111"></a>00111     info2(<span class="stringliteral">"analyzing..."</span>);
<a name="l00112"></a>00112     out-&gt;L=cholmod_l_analyze(A,&amp;out-&gt;c);
<a name="l00113"></a>00113     info2(<span class="stringliteral">"factoring..."</span>);
<a name="l00114"></a>00114     <span class="keywordflow">if</span>(!out-&gt;L) error(<span class="stringliteral">"Analyze failed\n"</span>);
<a name="l00115"></a>00115     cholmod_l_factorize(A,out-&gt;L, &amp;out-&gt;c);
<a name="l00116"></a>00116     <span class="comment">//info2("done, packing...");</span>
<a name="l00117"></a>00117     <span class="comment">//cholmod_l_pack_factor(out-&gt;L, &amp;out-&gt;c);</span>
<a name="l00118"></a>00118     free(A);
<a name="l00119"></a>00119     toc2(<span class="stringliteral">"done."</span>);
<a name="l00120"></a>00120     <span class="keywordflow">return</span> out;
<a name="l00121"></a>00121 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="da0ce1a175b77c9e140d8c826ff88907"></a><!-- doxytag: member="chol.c::chol_solve" ref="da0ce1a175b77c9e140d8c826ff88907" args="(dmat **x, spchol *A, const dmat *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chol_solve           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spchol *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solve A*x=Y where the cholesky factor of A is stored in A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00125"></a>00125                                                    {
<a name="l00126"></a>00126     <span class="comment">//solve A*x=Y;</span>
<a name="l00127"></a>00127     cholmod_dense *y2=d2chol(y);<span class="comment">//share pointer.</span>
<a name="l00128"></a>00128     <span class="keywordflow">if</span>(A-&gt;L-&gt;xtype==0) error(<span class="stringliteral">"A-&gt;L is pattern only!\n"</span>);
<a name="l00129"></a>00129     cholmod_dense *x2=cholmod_l_solve(CHOLMOD_A,A-&gt;L,y2,&amp;A-&gt;c);
<a name="l00130"></a>00130     <span class="keywordflow">if</span>(!x2) error(<span class="stringliteral">"chol_solve failed\n"</span>);
<a name="l00131"></a>00131     <span class="keywordflow">if</span>(x2-&gt;z){
<a name="l00132"></a>00132     error(<span class="stringliteral">"why is this?\n"</span>);
<a name="l00133"></a>00133     }
<a name="l00134"></a>00134     <span class="keywordflow">if</span>(x2-&gt;nzmax!=x2-&gt;nrow*x2-&gt;ncol || x2-&gt;d!=x2-&gt;nrow){
<a name="l00135"></a>00135     error(<span class="stringliteral">"Fix here\n"</span>);
<a name="l00136"></a>00136     }
<a name="l00137"></a>00137     free(y2);
<a name="l00138"></a>00138     <span class="keywordflow">if</span>(!*x){
<a name="l00139"></a>00139     *x=<a class="code" href="dmat_8h.html#21a7a376c0208121a33994cc82e7e662" title="Creat a X(mat) object with already allocated memory chunk.">dnew_data</a>(x2-&gt;x,x2-&gt;nrow,x2-&gt;ncol);
<a name="l00140"></a>00140     }<span class="keywordflow">else</span>{
<a name="l00141"></a>00141     <span class="keywordflow">if</span>((*x)-&gt;nx!=x2-&gt;nrow || (*x)-&gt;ny!=x2-&gt;ncol){
<a name="l00142"></a>00142         error(<span class="stringliteral">"Matrix mismatch\n"</span>);
<a name="l00143"></a>00143     }
<a name="l00144"></a>00144     memcpy((*x)-&gt;p,x2-&gt;x,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*((*x)-&gt;nx)*((*x)-&gt;ny));
<a name="l00145"></a>00145     free(x2-&gt;x);
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147     free(x2);<span class="comment">//x2-&gt;x is kept.</span>
<a name="l00148"></a>00148 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7a999102f2b6b345ff1ed7aff6e7a841"></a><!-- doxytag: member="chol.c::chol_free_do" ref="7a999102f2b6b345ff1ed7aff6e7a841" args="(spchol *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chol_free_do           </td>
          <td>(</td>
          <td class="paramtype">spchol *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free cholesky factor. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00151"></a>00151                             {
<a name="l00152"></a>00152     <span class="keywordflow">if</span>(A){
<a name="l00153"></a>00153     cholmod_l_free_factor(&amp;A-&gt;L, &amp;A-&gt;c);
<a name="l00154"></a>00154     cholmod_l_finish(&amp;A-&gt;c);
<a name="l00155"></a>00155     free(A);
<a name="l00156"></a>00156     }
<a name="l00157"></a>00157 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3ff611672c83dc9ccf8f53ca9e299e71"></a><!-- doxytag: member="chol.c::chol_save" ref="3ff611672c83dc9ccf8f53ca9e299e71" args="(spchol *A, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chol_save           </td>
          <td>(</td>
          <td class="paramtype">spchol *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save cholesky factor: the lower left side and permutation vector. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00160"></a>00160                                                  {
<a name="l00161"></a>00161     format2fn;
<a name="l00162"></a>00162     <span class="keywordtype">char</span> *fn2=malloc(strlen(fn)+10);
<a name="l00163"></a>00163     <a class="code" href="structdsp.html" title="a sparse array of double numbers stored in compressed column format, i.e.">dsp</a> *Chol=<a class="code" href="chol_8c.html#b1c164cb862233f91bac0baa84e0804c" title="Convert spchol to sparse matrix.">chol_sp</a>(A, 1);
<a name="l00164"></a>00164     <a class="code" href="dmat_8h.html#779cefb17e24b648212cc59f9324f5ae" title="User callable function to write sparse matrix into file.">spwrite</a>(Chol,<span class="stringliteral">"%s_C.bin"</span>,fn);
<a name="l00165"></a>00165     spfree(Chol);
<a name="l00166"></a>00166     <a class="code" href="bin_8c.html#b0e7504d3dfd44579094bdd73624f35a" title="Write a 64 bit integer array of size nx*ny to file.">writeint64</a>(A-&gt;L-&gt;Perm,A-&gt;L-&gt;n,1,<span class="stringliteral">"%s_P.bin.gz"</span>,fn);<span class="comment">//fixme: what happens in 32bit machine?</span>
<a name="l00167"></a>00167     free(fn2);
<a name="l00168"></a>00168 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6af1b2b392e60a455a9b01cfec1ddbd3"></a><!-- doxytag: member="chol.c::chol_convert" ref="6af1b2b392e60a455a9b01cfec1ddbd3" args="(dsp **Cs, long **Cp, spchol *A, int keep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chol_convert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> **&nbsp;</td>
          <td class="paramname"> <em>Cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long **&nbsp;</td>
          <td class="paramname"> <em>Cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spchol *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>keep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the internal data type cholesky factor into the lower left diagonal and permutation vector. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00173"></a>00173                                                            {
<a name="l00174"></a>00174     <span class="comment">/*</span>
<a name="l00175"></a>00175 <span class="comment">       Convert the internal format spchol to a simple sparse and a reordering vector.</span>
<a name="l00176"></a>00176 <span class="comment">       Keep=1: A is kept.</span>
<a name="l00177"></a>00177 <span class="comment">       Keep=0: A is destroyed.</span>
<a name="l00178"></a>00178 <span class="comment">    */</span>
<a name="l00179"></a>00179     <span class="keywordflow">if</span>(!A){
<a name="l00180"></a>00180     *Cs=NULL;
<a name="l00181"></a>00181     *Cp=NULL;
<a name="l00182"></a>00182     }
<a name="l00183"></a>00183     *Cp=malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*A-&gt;L-&gt;n);<span class="comment">//fixme: is this right in 32 bit machine?</span>
<a name="l00184"></a>00184     memcpy(*Cp, A-&gt;L-&gt;Perm, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*A-&gt;L-&gt;n);
<a name="l00185"></a>00185     *Cs=<a class="code" href="chol_8c.html#b1c164cb862233f91bac0baa84e0804c" title="Convert spchol to sparse matrix.">chol_sp</a>(A, keep);
<a name="l00186"></a>00186 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="54fd8616ad9eee6993bdeab95e2d7f33"></a><!-- doxytag: member="chol.c::chol_solve_lower" ref="54fd8616ad9eee6993bdeab95e2d7f33" args="(dmat **x, dsp *A, long *perm, const dmat *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chol_solve_lower           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solve A*x=Y where the A=LL' and L is stored in A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00223"></a>00223                                                                   {<span class="comment"></span>
<a name="l00224"></a>00224 <span class="comment">    /**</span>
<a name="l00225"></a>00225 <span class="comment">      Solve the cholesky backsubstitution when it's</span>
<a name="l00226"></a>00226 <span class="comment">      expressed in sparse matrix and a permutation</span>
<a name="l00227"></a>00227 <span class="comment">      vector. Notice only the lower left side is stored.</span>
<a name="l00228"></a>00228 <span class="comment">      </span>
<a name="l00229"></a>00229 <span class="comment">      The original matrix B=A*A';</span>
<a name="l00230"></a>00230 <span class="comment">      solve B*x=y or A*(A'*x)=y </span>
<a name="l00231"></a>00231 <span class="comment">      first solve A\y</span>
<a name="l00232"></a>00232 <span class="comment">      then solve A'\(A\y)</span>
<a name="l00233"></a>00233 <span class="comment">      </span>
<a name="l00234"></a>00234 <span class="comment">    */</span>
<a name="l00235"></a>00235     assert(A &amp;&amp; A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>==A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a> &amp;&amp; A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>==y-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>);
<a name="l00236"></a>00236     <span class="keywordflow">if</span>(!*x){
<a name="l00237"></a>00237     *x=<a class="code" href="dmat_8h.html#0d7497e2dbb79adb228de6bdde4a201e" title="Create a new T matrix object.">dnew</a>(y-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>,y-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00238"></a>00238     }<span class="keywordflow">else</span>{
<a name="l00239"></a>00239     assert((*x)-&gt;nx==y-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> &amp;&amp; (*x)-&gt;ny==y-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00240"></a>00240     }
<a name="l00241"></a>00241     <a class="code" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> *y2=NULL;
<a name="l00242"></a>00242     chol_perm_f(&amp;y2, perm, y);
<a name="l00243"></a>00243     <span class="keywordtype">double</span> *Ax=A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>;
<a name="l00244"></a>00244     <span class="keywordtype">long</span> *Ap=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>;
<a name="l00245"></a>00245     <span class="keywordtype">long</span> *Ai=A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>;
<a name="l00246"></a>00246     <span class="keywordflow">if</span>(y2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1){
<a name="l00247"></a>00247     <span class="comment">//Solve L\y</span>
<a name="l00248"></a>00248     <span class="keywordtype">double</span> *py=y2-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00249"></a>00249     
<a name="l00250"></a>00250     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00251"></a>00251         <span class="comment">//assert(Ai[Ap[icol]]==icol);//lower triangular matrix.</span>
<a name="l00252"></a>00252         py[icol]/=Ax[Ap[icol]];
<a name="l00253"></a>00253         <span class="keywordtype">double</span> val=-py[icol];
<a name="l00254"></a>00254         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol]+1; irow&lt;Ap[icol+1]; irow++){
<a name="l00255"></a>00255         py[Ai[irow]]+=val*Ax[irow];<span class="comment">//update in place.</span>
<a name="l00256"></a>00256         }
<a name="l00257"></a>00257     }
<a name="l00258"></a>00258 
<a name="l00259"></a>00259     <span class="comment">//Solve L'\y;</span>
<a name="l00260"></a>00260     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>-1; icol&gt;-1; icol--){
<a name="l00261"></a>00261         <span class="keywordtype">double</span> sum=0;
<a name="l00262"></a>00262         <span class="comment">//We do in reverse order to increase memory reuse. 1.5xFaster than forward order.</span>
<a name="l00263"></a>00263         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol+1]-1; irow&gt;Ap[icol]; irow--){
<a name="l00264"></a>00264         sum+=Ax[irow]*py[Ai[irow]];
<a name="l00265"></a>00265         }
<a name="l00266"></a>00266         py[icol]=(py[icol]-sum)/Ax[Ap[icol]];
<a name="l00267"></a>00267     }
<a name="l00268"></a>00268     }<span class="keywordflow">else</span>{
<a name="l00269"></a>00269     <span class="comment">//Solve L\y</span>
<a name="l00270"></a>00270     PDMAT(y2, py);
<a name="l00271"></a>00271     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00272"></a>00272         <span class="keywordtype">double</span> AxI=1./Ax[Ap[icol]];
<a name="l00273"></a>00273         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;y2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l00274"></a>00274         py[iy][icol]*=AxI;
<a name="l00275"></a>00275         <span class="keywordtype">double</span> val=-py[iy][icol];
<a name="l00276"></a>00276         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol]+1; irow&lt;Ap[icol+1]; irow++){
<a name="l00277"></a>00277             py[iy][Ai[irow]]+=val*Ax[irow];<span class="comment">//update in place.</span>
<a name="l00278"></a>00278         }
<a name="l00279"></a>00279         }
<a name="l00280"></a>00280     }
<a name="l00281"></a>00281 
<a name="l00282"></a>00282     <span class="comment">//Solve L'\y;</span>
<a name="l00283"></a>00283     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>-1; icol&gt;-1; icol--){
<a name="l00284"></a>00284         <span class="keywordtype">double</span> AxI=1./Ax[Ap[icol]];
<a name="l00285"></a>00285         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;y2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l00286"></a>00286         <span class="keywordtype">double</span> sum=0;
<a name="l00287"></a>00287         <span class="comment">//We do in reverse order to increase memory reuse. 1.5xFaster than forward order.</span>
<a name="l00288"></a>00288         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol+1]-1; irow&gt;Ap[icol]; irow--){
<a name="l00289"></a>00289             sum+=Ax[irow]*py[iy][Ai[irow]];
<a name="l00290"></a>00290         }
<a name="l00291"></a>00291         py[iy][icol]=(py[iy][icol]-sum)*AxI;
<a name="l00292"></a>00292         }
<a name="l00293"></a>00293     }
<a name="l00294"></a>00294     }
<a name="l00295"></a>00295     chol_perm_b(x, perm, y2);
<a name="l00296"></a>00296     dfree(y2);
<a name="l00297"></a>00297 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ef52e878eb677dfb7e6f655ebb27e4f3"></a><!-- doxytag: member="chol.c::chol_solve_upper" ref="ef52e878eb677dfb7e6f655ebb27e4f3" args="(dmat **x, dsp *A, long *perm, const dmat *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chol_solve_upper           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solve A*x=Y where the A=U'U and U is stored in A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00301"></a>00301                                                                   {
<a name="l00302"></a>00302     <span class="comment">/*</span>
<a name="l00303"></a>00303 <span class="comment">       Solve the cholesky backsubstitution when it's</span>
<a name="l00304"></a>00304 <span class="comment">       expressed in sparse matrix and a permutation</span>
<a name="l00305"></a>00305 <span class="comment">       vector. Notice only the lower left side is stored.</span>
<a name="l00306"></a>00306 <span class="comment">       </span>
<a name="l00307"></a>00307 <span class="comment">       The original matrix B=A'*A;</span>
<a name="l00308"></a>00308 <span class="comment">    */</span>
<a name="l00309"></a>00309     assert(A &amp;&amp; A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>==A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a> &amp;&amp; A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>==y-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>);
<a name="l00310"></a>00310     <span class="keywordflow">if</span>(!*x){
<a name="l00311"></a>00311     *x=<a class="code" href="dmat_8h.html#0d7497e2dbb79adb228de6bdde4a201e" title="Create a new T matrix object.">dnew</a>(y-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>,y-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00312"></a>00312     }<span class="keywordflow">else</span>{
<a name="l00313"></a>00313     assert((*x)-&gt;nx==y-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> &amp;&amp; (*x)-&gt;ny==y-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00314"></a>00314     }
<a name="l00315"></a>00315     <a class="code" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> *y2=NULL;
<a name="l00316"></a>00316     chol_perm_f(&amp;y2, perm, y);
<a name="l00317"></a>00317     <span class="keywordtype">double</span> *Ax=A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>;
<a name="l00318"></a>00318     <span class="keywordtype">long</span> *Ap=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>;
<a name="l00319"></a>00319     <span class="keywordtype">long</span> *Ai=A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>;
<a name="l00320"></a>00320     <span class="keywordflow">if</span>(y2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1){
<a name="l00321"></a>00321     <span class="comment">//Solve R'\y</span>
<a name="l00322"></a>00322     <span class="keywordtype">double</span> *py=y2-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00323"></a>00323 
<a name="l00324"></a>00324     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>; icol++){
<a name="l00325"></a>00325         <span class="keywordtype">double</span> sum=0;
<a name="l00326"></a>00326         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol]; irow&lt;Ap[icol+1]-1; irow++){
<a name="l00327"></a>00327         sum+=Ax[irow]*py[Ai[irow]];
<a name="l00328"></a>00328         }
<a name="l00329"></a>00329         <span class="comment">//assert(Ai[Ap[icol+1]-1]==icol);//confirm upper right triangular</span>
<a name="l00330"></a>00330         py[icol]=(py[icol]-sum)/Ax[Ap[icol+1]-1];
<a name="l00331"></a>00331     }
<a name="l00332"></a>00332 
<a name="l00333"></a>00333     <span class="comment">//Solve R\y</span>
<a name="l00334"></a>00334     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>-1; icol&gt;-1; icol--){
<a name="l00335"></a>00335         py[icol]/=Ax[Ap[icol+1]-1];
<a name="l00336"></a>00336         <span class="keywordtype">double</span> val=-py[icol];
<a name="l00337"></a>00337         <span class="comment">//We do in reverse order to increase memory reuse. 1.5xFaster than forward order.</span>
<a name="l00338"></a>00338         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol+1]-2; irow&gt;Ap[icol]-1; irow--){
<a name="l00339"></a>00339         py[Ai[irow]]+=val*Ax[irow];
<a name="l00340"></a>00340         }
<a name="l00341"></a>00341     }
<a name="l00342"></a>00342     }<span class="keywordflow">else</span>{
<a name="l00343"></a>00343     PDMAT(y2,py);
<a name="l00344"></a>00344     <span class="comment">//Solve R'\y</span>
<a name="l00345"></a>00345     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>; icol++){
<a name="l00346"></a>00346         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;y2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l00347"></a>00347         <span class="keywordtype">double</span> sum=0;
<a name="l00348"></a>00348         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol]; irow&lt;Ap[icol+1]-1; irow++){
<a name="l00349"></a>00349             sum+=Ax[irow]*py[iy][Ai[irow]];
<a name="l00350"></a>00350         }
<a name="l00351"></a>00351         <span class="comment">//assert(Ai[Ap[icol+1]-1]==icol);//confirm upper right triangular</span>
<a name="l00352"></a>00352         py[iy][icol]=(py[iy][icol]-sum)/Ax[Ap[icol+1]-1];
<a name="l00353"></a>00353         }
<a name="l00354"></a>00354     }
<a name="l00355"></a>00355     
<a name="l00356"></a>00356     <span class="comment">//Solve R\y</span>
<a name="l00357"></a>00357     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>-1; icol&gt;-1; icol--){
<a name="l00358"></a>00358         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;y2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l00359"></a>00359         py[iy][icol]/=Ax[Ap[icol+1]-1];
<a name="l00360"></a>00360         <span class="keywordtype">double</span> val=-py[iy][icol];
<a name="l00361"></a>00361         <span class="comment">//We do in reverse order to increase memory reuse. 1.5xFaster than forward order.</span>
<a name="l00362"></a>00362         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol+1]-2; irow&gt;Ap[icol]-1; irow--){
<a name="l00363"></a>00363             py[iy][Ai[irow]]+=val*Ax[irow];
<a name="l00364"></a>00364         }
<a name="l00365"></a>00365         }
<a name="l00366"></a>00366     }
<a name="l00367"></a>00367     }
<a name="l00368"></a>00368     chol_perm_b(x, perm, y2);
<a name="l00369"></a>00369     dfree(y2);
<a name="l00370"></a>00370 }
</pre></div>
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Oct 27 12:43:13 2010 for maos-0.6.1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
