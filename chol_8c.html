<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>maos-0.6.4: lib/chol.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lib/chol.c File Reference</h1>Wraps the CHOLESKY Library to provide a simple interface.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e7e001251de0d24c5fb7ece1fe256ad1"></a><!-- doxytag: member="chol.c::sp2chol" ref="e7e001251de0d24c5fb7ece1fe256ad1" args="(dsp *A)" -->
static cholmod_sparse *&nbsp;</td><td class="memItemRight" valign="bottom"><b>sp2chol</b> (<a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4cd34c53318702b084bd737ce2e43c14"></a><!-- doxytag: member="chol.c::d2chol" ref="4cd34c53318702b084bd737ce2e43c14" args="(const dmat *A)" -->
static cholmod_dense *&nbsp;</td><td class="memItemRight" valign="bottom"><b>d2chol</b> (const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#b1c164cb862233f91bac0baa84e0804c">chol_sp</a> (spchol *A, int keep)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert spchol to sparse matrix.  <a href="#b1c164cb862233f91bac0baa84e0804c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">spchol *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#43ab12416b0a5f5b4bb88587edbb9b12">chol_factorize</a> (<a class="el" href="structdsp.html">dsp</a> *A_in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factorize a sparse array into LL'.  <a href="#43ab12416b0a5f5b4bb88587edbb9b12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#da0ce1a175b77c9e140d8c826ff88907">chol_solve</a> (<a class="el" href="structdmat.html">dmat</a> **x, spchol *A, const <a class="el" href="structdmat.html">dmat</a> *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve A*x=Y where the cholesky factor of A is stored in A.  <a href="#da0ce1a175b77c9e140d8c826ff88907"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#7a999102f2b6b345ff1ed7aff6e7a841">chol_free_do</a> (spchol *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free cholesky factor.  <a href="#7a999102f2b6b345ff1ed7aff6e7a841"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#3ff611672c83dc9ccf8f53ca9e299e71">chol_save</a> (spchol *A, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save cholesky factor: the lower left side and permutation vector.  <a href="#3ff611672c83dc9ccf8f53ca9e299e71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#6af1b2b392e60a455a9b01cfec1ddbd3">chol_convert</a> (<a class="el" href="structdsp.html">dsp</a> **Cs, long **Cp, spchol *A, int keep)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the internal data type cholesky factor into the lower left diagonal and permutation vector.  <a href="#6af1b2b392e60a455a9b01cfec1ddbd3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b04a632ad4b8ee8ec209e70e535c206f"></a><!-- doxytag: member="chol.c::chol_perm_f" ref="b04a632ad4b8ee8ec209e70e535c206f" args="(dmat **out, long *perm, const dmat *in)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>chol_perm_f</b> (<a class="el" href="structdmat.html">dmat</a> **out, long *perm, const <a class="el" href="structdmat.html">dmat</a> *in)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="67531603f7f798efdb636f353cbb880c"></a><!-- doxytag: member="chol.c::chol_perm_b" ref="67531603f7f798efdb636f353cbb880c" args="(dmat **out, long *perm, const dmat *in)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>chol_perm_b</b> (<a class="el" href="structdmat.html">dmat</a> **out, long *perm, const <a class="el" href="structdmat.html">dmat</a> *in)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#54fd8616ad9eee6993bdeab95e2d7f33">chol_solve_lower</a> (<a class="el" href="structdmat.html">dmat</a> **x, <a class="el" href="structdsp.html">dsp</a> *A, long *perm, const <a class="el" href="structdmat.html">dmat</a> *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve A*x=Y where the A=LL' and L is stored in A.  <a href="#54fd8616ad9eee6993bdeab95e2d7f33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="chol_8c.html#ef52e878eb677dfb7e6f655ebb27e4f3">chol_solve_upper</a> (<a class="el" href="structdmat.html">dmat</a> **x, <a class="el" href="structdsp.html">dsp</a> *A, long *perm, const <a class="el" href="structdmat.html">dmat</a> *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve A*x=Y where the A=U'U and U is stored in A.  <a href="#ef52e878eb677dfb7e6f655ebb27e4f3"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Wraps the CHOLESKY Library to provide a simple interface. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="b1c164cb862233f91bac0baa84e0804c"></a><!-- doxytag: member="chol.c::chol_sp" ref="b1c164cb862233f91bac0baa84e0804c" args="(spchol *A, int keep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdsp.html">dsp</a>* chol_sp           </td>
          <td>(</td>
          <td class="paramtype">spchol *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>keep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert spchol to sparse matrix. 
<p>
keep=1: A is kept intact, otherwise destroyed. The matrix is in lower left side.<p>
This routine works only if the factor is using simplicity factor. not supernodal. so, in chol_factorize, we have set c.final_super=0, so that the final result is always in simplicity factor. <div class="fragment"><pre class="fragment"><a name="l00070"></a>00070                                         {
<a name="l00071"></a>00071     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l00072"></a>00072 
<a name="l00073"></a>00073     cholmod_factor *L;
<a name="l00074"></a>00074     <span class="keywordflow">if</span>(keep){
<a name="l00075"></a>00075     L=cholmod_l_copy_factor(A-&gt;L, A-&gt;c);
<a name="l00076"></a>00076     }<span class="keywordflow">else</span>{
<a name="l00077"></a>00077     L=A-&gt;L;
<a name="l00078"></a>00078     }
<a name="l00079"></a>00079     cholmod_sparse *B=cholmod_l_factor_to_sparse(L, A-&gt;c);
<a name="l00080"></a>00080     <a class="code" href="structdsp.html" title="a sparse array of double numbers stored in compressed column format, i.e.">dsp</a> *out=<a class="code" href="dsp_8h.html#ad23f2152cd2622871367fd28ac0ff6b" title="Create a nx*ny X(sp) matrix with memory for nmax max elements allocated.">spnew</a>(B-&gt;nrow, B-&gt;ncol, 0);
<a name="l00081"></a>00081     <span class="comment">//out-&gt;m=B-&gt;nrow;</span>
<a name="l00082"></a>00082     <span class="comment">//out-&gt;n=B-&gt;ncol;</span>
<a name="l00083"></a>00083     out-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>=B-&gt;p;
<a name="l00084"></a>00084     out-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>=B-&gt;i;
<a name="l00085"></a>00085     out-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>=B-&gt;x;
<a name="l00086"></a>00086     out-&gt;<a class="code" href="structdsp.html#870a449e24356b8a08ec11a4916be6a0" title="maximum number of entries">nzmax</a>=B-&gt;nzmax;
<a name="l00087"></a>00087     free(B);
<a name="l00088"></a>00088     cholmod_l_free_factor(&amp;L, A-&gt;c);
<a name="l00089"></a>00089     <span class="keywordflow">if</span>(!keep){
<a name="l00090"></a>00090     cholmod_l_finish(A-&gt;c);
<a name="l00091"></a>00091     free(A);
<a name="l00092"></a>00092     }
<a name="l00093"></a>00093     <span class="keywordflow">return</span> out;
<a name="l00094"></a>00094 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="43ab12416b0a5f5b4bb88587edbb9b12"></a><!-- doxytag: member="chol.c::chol_factorize" ref="43ab12416b0a5f5b4bb88587edbb9b12" args="(dsp *A_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spchol* chol_factorize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A_in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Factorize a sparse array into LL'. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00098"></a>00098                                  {
<a name="l00099"></a>00099     <span class="keywordflow">if</span>(!A_in) <span class="keywordflow">return</span> NULL;
<a name="l00100"></a>00100     TIC;tic;
<a name="l00101"></a>00101     spchol *out=calloc(1, <span class="keyword">sizeof</span>(spchol));
<a name="l00102"></a>00102     out-&gt;c=calloc(1, <span class="keyword">sizeof</span>(cholmod_common));
<a name="l00103"></a>00103     cholmod_l_start(out-&gt;c);
<a name="l00104"></a>00104     cholmod_sparse *A=sp2chol(A_in);
<a name="l00105"></a>00105     out-&gt;c-&gt;status=CHOLMOD_OK;
<a name="l00106"></a>00106     out-&gt;c-&gt;final_super=0;<span class="comment">//we want a simple result</span>
<a name="l00107"></a>00107     {
<a name="l00108"></a>00108     <span class="comment">//Try AMD ordering only. SLOW</span>
<a name="l00109"></a>00109     <span class="comment">/*</span>
<a name="l00110"></a>00110 <span class="comment">      out-&gt;c.nmethods=1;</span>
<a name="l00111"></a>00111 <span class="comment">      out-&gt;c.method[0].ordering=CHOLMOD_AMD;</span>
<a name="l00112"></a>00112 <span class="comment">      out-&gt;c.postorder=1;</span>
<a name="l00113"></a>00113 <span class="comment">      out-&gt;c.supernodal=CHOLMOD_SIMPLICIAL;//force simplicial only.</span>
<a name="l00114"></a>00114 <span class="comment">    */</span>
<a name="l00115"></a>00115     }
<a name="l00116"></a>00116     info2(<span class="stringliteral">"analyzing..."</span>);
<a name="l00117"></a>00117     out-&gt;L=cholmod_l_analyze(A,out-&gt;c);
<a name="l00118"></a>00118     info2(<span class="stringliteral">"factoring..."</span>);
<a name="l00119"></a>00119     <span class="keywordflow">if</span>(!out-&gt;L) error(<span class="stringliteral">"Analyze failed\n"</span>);
<a name="l00120"></a>00120     cholmod_l_factorize(A,out-&gt;L, out-&gt;c);
<a name="l00121"></a>00121     free(A);
<a name="l00122"></a>00122     toc2(<span class="stringliteral">"done."</span>);
<a name="l00123"></a>00123     <span class="keywordflow">return</span> out;
<a name="l00124"></a>00124 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="da0ce1a175b77c9e140d8c826ff88907"></a><!-- doxytag: member="chol.c::chol_solve" ref="da0ce1a175b77c9e140d8c826ff88907" args="(dmat **x, spchol *A, const dmat *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chol_solve           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spchol *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solve A*x=Y where the cholesky factor of A is stored in A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00128"></a>00128                                                    {
<a name="l00129"></a>00129     <span class="comment">//solve A*x=Y;</span>
<a name="l00130"></a>00130     cholmod_dense *y2=d2chol(y);<span class="comment">//share pointer.</span>
<a name="l00131"></a>00131     <span class="keywordflow">if</span>(A-&gt;L-&gt;xtype==0) error(<span class="stringliteral">"A-&gt;L is pattern only!\n"</span>);
<a name="l00132"></a>00132     cholmod_dense *x2=cholmod_l_solve(CHOLMOD_A,A-&gt;L,y2,A-&gt;c);
<a name="l00133"></a>00133     <span class="keywordflow">if</span>(!x2) error(<span class="stringliteral">"chol_solve failed\n"</span>);
<a name="l00134"></a>00134     <span class="keywordflow">if</span>(x2-&gt;z){
<a name="l00135"></a>00135     error(<span class="stringliteral">"why is this?\n"</span>);
<a name="l00136"></a>00136     }
<a name="l00137"></a>00137     <span class="keywordflow">if</span>(x2-&gt;nzmax!=x2-&gt;nrow*x2-&gt;ncol || x2-&gt;d!=x2-&gt;nrow){
<a name="l00138"></a>00138     error(<span class="stringliteral">"Fix here\n"</span>);
<a name="l00139"></a>00139     }
<a name="l00140"></a>00140     free(y2);
<a name="l00141"></a>00141     <span class="keywordflow">if</span>(!*x){
<a name="l00142"></a>00142     *x=<a class="code" href="dmat_8h.html#21a7a376c0208121a33994cc82e7e662" title="Creat a X(mat) object with already allocated memory chunk.">dnew_data</a>(x2-&gt;x,x2-&gt;nrow,x2-&gt;ncol);
<a name="l00143"></a>00143     }<span class="keywordflow">else</span>{
<a name="l00144"></a>00144     <span class="keywordflow">if</span>((*x)-&gt;nx!=x2-&gt;nrow || (*x)-&gt;ny!=x2-&gt;ncol){
<a name="l00145"></a>00145         error(<span class="stringliteral">"Matrix mismatch\n"</span>);
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147     memcpy((*x)-&gt;p,x2-&gt;x,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*((*x)-&gt;nx)*((*x)-&gt;ny));
<a name="l00148"></a>00148     free(x2-&gt;x);
<a name="l00149"></a>00149     }
<a name="l00150"></a>00150     free(x2);<span class="comment">//x2-&gt;x is kept.</span>
<a name="l00151"></a>00151 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7a999102f2b6b345ff1ed7aff6e7a841"></a><!-- doxytag: member="chol.c::chol_free_do" ref="7a999102f2b6b345ff1ed7aff6e7a841" args="(spchol *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chol_free_do           </td>
          <td>(</td>
          <td class="paramtype">spchol *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free cholesky factor. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00154"></a>00154                             {
<a name="l00155"></a>00155     <span class="keywordflow">if</span>(A){
<a name="l00156"></a>00156     cholmod_l_free_factor(&amp;A-&gt;L, A-&gt;c);
<a name="l00157"></a>00157     cholmod_l_finish(A-&gt;c);
<a name="l00158"></a>00158     free(A-&gt;c);
<a name="l00159"></a>00159     free(A);
<a name="l00160"></a>00160     }
<a name="l00161"></a>00161 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3ff611672c83dc9ccf8f53ca9e299e71"></a><!-- doxytag: member="chol.c::chol_save" ref="3ff611672c83dc9ccf8f53ca9e299e71" args="(spchol *A, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chol_save           </td>
          <td>(</td>
          <td class="paramtype">spchol *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save cholesky factor: the lower left side and permutation vector. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00164"></a>00164                                                  {
<a name="l00165"></a>00165     format2fn;
<a name="l00166"></a>00166     <span class="keywordtype">char</span> *fn2=malloc(strlen(fn)+10);
<a name="l00167"></a>00167     <a class="code" href="structdsp.html" title="a sparse array of double numbers stored in compressed column format, i.e.">dsp</a> *Chol=<a class="code" href="chol_8c.html#b1c164cb862233f91bac0baa84e0804c" title="Convert spchol to sparse matrix.">chol_sp</a>(A, 1);
<a name="l00168"></a>00168     <a class="code" href="dmat_8h.html#779cefb17e24b648212cc59f9324f5ae" title="User callable function to write sparse matrix into file.">spwrite</a>(Chol,<span class="stringliteral">"%s_C.bin"</span>,fn);
<a name="l00169"></a>00169     spfree(Chol);
<a name="l00170"></a>00170     <a class="code" href="bin_8c.html#b0e7504d3dfd44579094bdd73624f35a" title="Write a 64 bit integer array of size nx*ny to file.">writeint64</a>(A-&gt;L-&gt;Perm,A-&gt;L-&gt;n,1,<span class="stringliteral">"%s_P.bin.gz"</span>,fn);<span class="comment">//fixme: what happens in 32bit machine?</span>
<a name="l00171"></a>00171     free(fn2);
<a name="l00172"></a>00172 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6af1b2b392e60a455a9b01cfec1ddbd3"></a><!-- doxytag: member="chol.c::chol_convert" ref="6af1b2b392e60a455a9b01cfec1ddbd3" args="(dsp **Cs, long **Cp, spchol *A, int keep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chol_convert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> **&nbsp;</td>
          <td class="paramname"> <em>Cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long **&nbsp;</td>
          <td class="paramname"> <em>Cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spchol *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>keep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the internal data type cholesky factor into the lower left diagonal and permutation vector. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00177"></a>00177                                                            {
<a name="l00178"></a>00178     <span class="comment">/*</span>
<a name="l00179"></a>00179 <span class="comment">       Convert the internal format spchol to a simple sparse and a reordering vector.</span>
<a name="l00180"></a>00180 <span class="comment">       Keep=1: A is kept.</span>
<a name="l00181"></a>00181 <span class="comment">       Keep=0: A is destroyed.</span>
<a name="l00182"></a>00182 <span class="comment">    */</span>
<a name="l00183"></a>00183     <span class="keywordflow">if</span>(!A){
<a name="l00184"></a>00184     *Cs=NULL;
<a name="l00185"></a>00185     *Cp=NULL;
<a name="l00186"></a>00186     }
<a name="l00187"></a>00187     *Cp=malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*A-&gt;L-&gt;n);<span class="comment">//fixme: is this right in 32 bit machine?</span>
<a name="l00188"></a>00188     memcpy(*Cp, A-&gt;L-&gt;Perm, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*A-&gt;L-&gt;n);
<a name="l00189"></a>00189     *Cs=<a class="code" href="chol_8c.html#b1c164cb862233f91bac0baa84e0804c" title="Convert spchol to sparse matrix.">chol_sp</a>(A, keep);
<a name="l00190"></a>00190 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="54fd8616ad9eee6993bdeab95e2d7f33"></a><!-- doxytag: member="chol.c::chol_solve_lower" ref="54fd8616ad9eee6993bdeab95e2d7f33" args="(dmat **x, dsp *A, long *perm, const dmat *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chol_solve_lower           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solve A*x=Y where the A=LL' and L is stored in A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00227"></a>00227                                                                   {<span class="comment"></span>
<a name="l00228"></a>00228 <span class="comment">    /**</span>
<a name="l00229"></a>00229 <span class="comment">      Solve the cholesky backsubstitution when it's</span>
<a name="l00230"></a>00230 <span class="comment">      expressed in sparse matrix and a permutation</span>
<a name="l00231"></a>00231 <span class="comment">      vector. Notice only the lower left side is stored.</span>
<a name="l00232"></a>00232 <span class="comment">      </span>
<a name="l00233"></a>00233 <span class="comment">      The original matrix B=A*A';</span>
<a name="l00234"></a>00234 <span class="comment">      solve B*x=y or A*(A'*x)=y </span>
<a name="l00235"></a>00235 <span class="comment">      first solve A\y</span>
<a name="l00236"></a>00236 <span class="comment">      then solve A'\(A\y)</span>
<a name="l00237"></a>00237 <span class="comment">      </span>
<a name="l00238"></a>00238 <span class="comment">    */</span>
<a name="l00239"></a>00239     assert(A &amp;&amp; A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>==A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a> &amp;&amp; A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>==y-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>);
<a name="l00240"></a>00240     <span class="keywordflow">if</span>(!*x){
<a name="l00241"></a>00241     *x=<a class="code" href="dmat_8h.html#0d7497e2dbb79adb228de6bdde4a201e" title="Create a new T matrix object.">dnew</a>(y-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>,y-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00242"></a>00242     }<span class="keywordflow">else</span>{
<a name="l00243"></a>00243     assert((*x)-&gt;nx==y-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> &amp;&amp; (*x)-&gt;ny==y-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00244"></a>00244     }
<a name="l00245"></a>00245     <a class="code" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> *y2=NULL;
<a name="l00246"></a>00246     chol_perm_f(&amp;y2, perm, y);
<a name="l00247"></a>00247     <span class="keywordtype">double</span> *Ax=A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>;
<a name="l00248"></a>00248     <span class="keywordtype">long</span> *Ap=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>;
<a name="l00249"></a>00249     <span class="keywordtype">long</span> *Ai=A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>;
<a name="l00250"></a>00250     <span class="keywordflow">if</span>(y2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1){
<a name="l00251"></a>00251     <span class="comment">//Solve L\y</span>
<a name="l00252"></a>00252     <span class="keywordtype">double</span> *py=y2-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00253"></a>00253     
<a name="l00254"></a>00254     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00255"></a>00255         <span class="comment">//assert(Ai[Ap[icol]]==icol);//lower triangular matrix.</span>
<a name="l00256"></a>00256         py[icol]/=Ax[Ap[icol]];
<a name="l00257"></a>00257         <span class="keywordtype">double</span> val=-py[icol];
<a name="l00258"></a>00258         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol]+1; irow&lt;Ap[icol+1]; irow++){
<a name="l00259"></a>00259         py[Ai[irow]]+=val*Ax[irow];<span class="comment">//update in place.</span>
<a name="l00260"></a>00260         }
<a name="l00261"></a>00261     }
<a name="l00262"></a>00262 
<a name="l00263"></a>00263     <span class="comment">//Solve L'\y;</span>
<a name="l00264"></a>00264     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>-1; icol&gt;-1; icol--){
<a name="l00265"></a>00265         <span class="keywordtype">double</span> sum=0;
<a name="l00266"></a>00266         <span class="comment">//We do in reverse order to increase memory reuse. 1.5xFaster than forward order.</span>
<a name="l00267"></a>00267         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol+1]-1; irow&gt;Ap[icol]; irow--){
<a name="l00268"></a>00268         sum+=Ax[irow]*py[Ai[irow]];
<a name="l00269"></a>00269         }
<a name="l00270"></a>00270         py[icol]=(py[icol]-sum)/Ax[Ap[icol]];
<a name="l00271"></a>00271     }
<a name="l00272"></a>00272     }<span class="keywordflow">else</span>{
<a name="l00273"></a>00273     <span class="comment">//Solve L\y</span>
<a name="l00274"></a>00274     PDMAT(y2, py);
<a name="l00275"></a>00275     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00276"></a>00276         <span class="keywordtype">double</span> AxI=1./Ax[Ap[icol]];
<a name="l00277"></a>00277         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;y2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l00278"></a>00278         py[iy][icol]*=AxI;
<a name="l00279"></a>00279         <span class="keywordtype">double</span> val=-py[iy][icol];
<a name="l00280"></a>00280         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol]+1; irow&lt;Ap[icol+1]; irow++){
<a name="l00281"></a>00281             py[iy][Ai[irow]]+=val*Ax[irow];<span class="comment">//update in place.</span>
<a name="l00282"></a>00282         }
<a name="l00283"></a>00283         }
<a name="l00284"></a>00284     }
<a name="l00285"></a>00285 
<a name="l00286"></a>00286     <span class="comment">//Solve L'\y;</span>
<a name="l00287"></a>00287     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>-1; icol&gt;-1; icol--){
<a name="l00288"></a>00288         <span class="keywordtype">double</span> AxI=1./Ax[Ap[icol]];
<a name="l00289"></a>00289         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;y2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l00290"></a>00290         <span class="keywordtype">double</span> sum=0;
<a name="l00291"></a>00291         <span class="comment">//We do in reverse order to increase memory reuse. 1.5xFaster than forward order.</span>
<a name="l00292"></a>00292         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol+1]-1; irow&gt;Ap[icol]; irow--){
<a name="l00293"></a>00293             sum+=Ax[irow]*py[iy][Ai[irow]];
<a name="l00294"></a>00294         }
<a name="l00295"></a>00295         py[iy][icol]=(py[iy][icol]-sum)*AxI;
<a name="l00296"></a>00296         }
<a name="l00297"></a>00297     }
<a name="l00298"></a>00298     }
<a name="l00299"></a>00299     chol_perm_b(x, perm, y2);
<a name="l00300"></a>00300     dfree(y2);
<a name="l00301"></a>00301 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ef52e878eb677dfb7e6f655ebb27e4f3"></a><!-- doxytag: member="chol.c::chol_solve_upper" ref="ef52e878eb677dfb7e6f655ebb27e4f3" args="(dmat **x, dsp *A, long *perm, const dmat *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chol_solve_upper           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solve A*x=Y where the A=U'U and U is stored in A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00305"></a>00305                                                                   {
<a name="l00306"></a>00306     <span class="comment">/*</span>
<a name="l00307"></a>00307 <span class="comment">       Solve the cholesky backsubstitution when it's</span>
<a name="l00308"></a>00308 <span class="comment">       expressed in sparse matrix and a permutation</span>
<a name="l00309"></a>00309 <span class="comment">       vector. Notice only the lower left side is stored.</span>
<a name="l00310"></a>00310 <span class="comment">       </span>
<a name="l00311"></a>00311 <span class="comment">       The original matrix B=A'*A;</span>
<a name="l00312"></a>00312 <span class="comment">    */</span>
<a name="l00313"></a>00313     assert(A &amp;&amp; A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>==A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a> &amp;&amp; A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>==y-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>);
<a name="l00314"></a>00314     <span class="keywordflow">if</span>(!*x){
<a name="l00315"></a>00315     *x=<a class="code" href="dmat_8h.html#0d7497e2dbb79adb228de6bdde4a201e" title="Create a new T matrix object.">dnew</a>(y-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>,y-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00316"></a>00316     }<span class="keywordflow">else</span>{
<a name="l00317"></a>00317     assert((*x)-&gt;nx==y-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> &amp;&amp; (*x)-&gt;ny==y-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319     <a class="code" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> *y2=NULL;
<a name="l00320"></a>00320     chol_perm_f(&amp;y2, perm, y);
<a name="l00321"></a>00321     <span class="keywordtype">double</span> *Ax=A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>;
<a name="l00322"></a>00322     <span class="keywordtype">long</span> *Ap=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>;
<a name="l00323"></a>00323     <span class="keywordtype">long</span> *Ai=A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>;
<a name="l00324"></a>00324     <span class="keywordflow">if</span>(y2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1){
<a name="l00325"></a>00325     <span class="comment">//Solve R'\y</span>
<a name="l00326"></a>00326     <span class="keywordtype">double</span> *py=y2-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00327"></a>00327 
<a name="l00328"></a>00328     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>; icol++){
<a name="l00329"></a>00329         <span class="keywordtype">double</span> sum=0;
<a name="l00330"></a>00330         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol]; irow&lt;Ap[icol+1]-1; irow++){
<a name="l00331"></a>00331         sum+=Ax[irow]*py[Ai[irow]];
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333         <span class="comment">//assert(Ai[Ap[icol+1]-1]==icol);//confirm upper right triangular</span>
<a name="l00334"></a>00334         py[icol]=(py[icol]-sum)/Ax[Ap[icol+1]-1];
<a name="l00335"></a>00335     }
<a name="l00336"></a>00336 
<a name="l00337"></a>00337     <span class="comment">//Solve R\y</span>
<a name="l00338"></a>00338     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>-1; icol&gt;-1; icol--){
<a name="l00339"></a>00339         py[icol]/=Ax[Ap[icol+1]-1];
<a name="l00340"></a>00340         <span class="keywordtype">double</span> val=-py[icol];
<a name="l00341"></a>00341         <span class="comment">//We do in reverse order to increase memory reuse. 1.5xFaster than forward order.</span>
<a name="l00342"></a>00342         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol+1]-2; irow&gt;Ap[icol]-1; irow--){
<a name="l00343"></a>00343         py[Ai[irow]]+=val*Ax[irow];
<a name="l00344"></a>00344         }
<a name="l00345"></a>00345     }
<a name="l00346"></a>00346     }<span class="keywordflow">else</span>{
<a name="l00347"></a>00347     PDMAT(y2,py);
<a name="l00348"></a>00348     <span class="comment">//Solve R'\y</span>
<a name="l00349"></a>00349     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>; icol++){
<a name="l00350"></a>00350         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;y2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l00351"></a>00351         <span class="keywordtype">double</span> sum=0;
<a name="l00352"></a>00352         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol]; irow&lt;Ap[icol+1]-1; irow++){
<a name="l00353"></a>00353             sum+=Ax[irow]*py[iy][Ai[irow]];
<a name="l00354"></a>00354         }
<a name="l00355"></a>00355         <span class="comment">//assert(Ai[Ap[icol+1]-1]==icol);//confirm upper right triangular</span>
<a name="l00356"></a>00356         py[iy][icol]=(py[iy][icol]-sum)/Ax[Ap[icol+1]-1];
<a name="l00357"></a>00357         }
<a name="l00358"></a>00358     }
<a name="l00359"></a>00359     
<a name="l00360"></a>00360     <span class="comment">//Solve R\y</span>
<a name="l00361"></a>00361     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>-1; icol&gt;-1; icol--){
<a name="l00362"></a>00362         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;y2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l00363"></a>00363         py[iy][icol]/=Ax[Ap[icol+1]-1];
<a name="l00364"></a>00364         <span class="keywordtype">double</span> val=-py[iy][icol];
<a name="l00365"></a>00365         <span class="comment">//We do in reverse order to increase memory reuse. 1.5xFaster than forward order.</span>
<a name="l00366"></a>00366         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=Ap[icol+1]-2; irow&gt;Ap[icol]-1; irow--){
<a name="l00367"></a>00367             py[iy][Ai[irow]]+=val*Ax[irow];
<a name="l00368"></a>00368         }
<a name="l00369"></a>00369         }
<a name="l00370"></a>00370     }
<a name="l00371"></a>00371     }
<a name="l00372"></a>00372     chol_perm_b(x, perm, y2);
<a name="l00373"></a>00373     dfree(y2);
<a name="l00374"></a>00374 }
</pre></div>
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 29 14:31:01 2010 for maos-0.6.4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
