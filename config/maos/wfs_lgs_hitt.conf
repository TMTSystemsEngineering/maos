#FILE wfs_lgs_hitt.conf
#Use visible, high order WFS as the TTF.

powfs.order = [0 0] # number of sa in one dimension. 0 to match ground DM order.
powfs.dx  = [1/64 1/64] #sampling of opd in each subaperture. 
	    	           #NGS performs pretty good with 1/16 sampling.
powfs.hs  = [90e3 inf] #height of the guide star. 90e3 for LGS. inf for NGS.
powfs.fnllt= ["llt_CL.conf" ""] # configuration of laser launch telescope. 
powfs.trs = [1 0]  #tilt remove flag. 1 for LGS. 0 for NGS
powfs.dfrs= [0 0]  #differential focus removal flag. 1 for LGS, 0 for NGS. LGS=1 is bad for CBS
powfs.lo  = [0 1]  #low order. 1 for T/T or T/T/F WFS. 0 for LGS and high order NGS
powfs.saat    = [0.6 0.6]  #threshold of relative area to turn off subaperture.
powfs.neareconfile=["" ""]
powfs.nearecon= [20 20] # nea in mas for reconstruction
powfs.neasim  = [-1 -1] # nea in mas for simulation. -1 to match nearecon.
powfs.neasimfile=["" ""]#read NEA used in simulation from file. Defined at
		        #sim.dt sampling rate, in radian. neasim must be -1
powfs.neaphy  = [0 0]  #use nea from matched filter in geometric simulations.

powfs.gtype_sim = [0 0] #0: gtilt, 1: ztilt for simulation. gtilt is averaging
			  #gradient. ztilt is best zernike tip/tilt fit
powfs.gtype_recon = [0 0] #0: gtilt, 1: ztilt for reconstruction.
#Physical optics options.
powfs.pixtheta= [0.5 0.5] #CCD Pixel size in arcsec. if negative -alpha, the size is alpha*max(wvl)/dsa
powfs.radpixtheta=[0 0]#CCD Pixel size along radiual direction.
powfs.fieldstop=[0 0] #the field stop in arcsec
powfs.pixblur = [0.3 0.3] #bluring of pixels in unit of pixtheta
powfs.pixpsa  = [6 2]  #number of pixels per subaperture or along azimuthal
			 #direction if radpix is nonzero. 6 is good for LGS. 4 causes spikes
powfs.radpix  = [16 0] #if non zero, radial pixel along radial direction. 
	      	      	 #If negative, figure out appropriate size automatically.
powfs.radrot  = [0 0]  #rotate OTF to do radial pixel 0: like laos. 1: rotate
			 #OTF. 1 is good for side launch to save memory.
powfs.ncomp   = [0 0]  #specify FFT grid size in WFS sensor imaging. 0: automatic.
powfs.pixoffx  = [0 0]  #offset of psf center from pixel vertex.
powfs.pixoffy  = [0 0]  #offset of psf center from pixel vertex.
powfs.i0scale = [0 0] #scale i0 to match area. Because simulations has more
	      	       #concentrated i0 than precomputation due to outer scale
powfs.sigscale= [1 1]#scale the wfs.siglev to wfs.siglevsim for simulation.
powfs.bkgrnd  = [0 0] #background
powfs.bkgrndc = [1 1]
powfs.bkgrndfn= ["" ""]
powfs.bkgrndfnc= ["" ""]
powfs.rne     = [3 1] #read out noise
powfs.phyusenea  = [0 0] #force use specified nea in recon in physical optics mode
powfs.neaspeckle=[0 0]#speckle noise nea in mas.
powfs.embfac  = [2 2] #keep at 2 to avoid aliasing
powfs.psfout  = [0 0] #output complex psf for sky coverage. only valid in split
			#tomography, do ideal compensation of NGS modes.
powfs.pistatout = [0 0] #output tip/tilt removed averaged psf for matched filter
powfs.pistatstart=[0 20]#first time step to start outputing averaged psf.
powfs.pistatstc = [0 0]#shift pistat to center using fft method.
powfs.nwvl      = [1 1]#number of bands for each powfs.
powfs.wvl       = [0.589e-6 0.7e-6]#concatenated list of bands
powfs.wvlwts    = [1 1]
powfs.piinfile  = ["" ""]#pixel intensities input file prefix. Mainly used
			    #for NGS. If seed is 1, and pistatout=[0 1 1], the
			    #program outputs pistat_seed1_wfs[678].bin. Put
			    #here powfs.piinfile=["" "pistat_see1"
			    #"pistat_seed1"] here and set pistatout=[0 0 0] to
			    #run physical optics NGS simulation.
powfs.sninfile  = ["" ""]#not used

powfs.phystep  = [0 0] #-1 to disable physical optics.
powfs.phytype  = [1 1] #1: matched filter. 2:cog(not implemented)
powfs.phytypesim=[-1 -1]
powfs.mtchcr  = [1 0] #use constraint matched filter for x(radial) displace
powfs.mtchcra  = [-1 -1] #use constraint matched filter for y(azimuthal).
powfs.mtchcpl  = [1 1] #use coupling between r/a measure error.
powfs.mtchstc  = [1 1] #shift peak in sepsf to center using fft.
powfs.mtchscl  = [-1 -1] #scale subaperture image to have the same intensity as i0.
powfs.mtchadp  = [0 0] #Using adaptive matched filter.
powfs.cogthres = [1 1] #tCoG threshold, relative to noise
powfs.cogoff   = [1 1] #tCoG offset to remove, relative to noise
#misregistration described by file containing a cell array A of 2xp, where p is
#1 or number of wfs belonging to this powfs. The misregistered coordinate is
#computed as
#xm{ip}=\sum_{ic}(A{1,ip}(1,ic)*pow(x,A{1,ip}(2,ic))*pow(y,A{1,ip}(3,ic)))
#ym{ip}=\sum_{ic}(A{2,ip}(1,ic)*pow(x,A{1,ip}(2,ic))*pow(y,A{1,ip}(3,ic)))
#where ip is ipowfs. ic is index of column in entries of A.
powfs.misreg   = ["" ""] 
powfs.ncpa     = ["" ""]	       
powfs.ncpa_method=[2 2]
powfs.noisy    = [1 1] #noisy detector in simulation.
powfs.dtrat    = [1 1] #sampling period relative to 1/dt (1/800)
powfs.moao     = [-1 -1]
powfs.siglev   = [900 900]#signal level at 800 Hz (no matter what sim.dt is)

#x coordinate in arcsecond unit.
wfs.thetax=[0 0  -33.287 -20.5725  20.5725 33.287 4]
#y coordinate in arcsecond unit.
wfs.thetay=[0 35 10.8156 -28.3156 -28.3156 10.8156 0]
wfs.powfs =[0 0 0 0 0 0 1] #type of powfs for each wfs.

#signal level at 800 Hz for fully illuminated subaperture. 
wfs.siglev=[] #if set, powfs.siglev must be set to empty.
#concatenated lists of wavelength weighting.
wfs.wvlwts=[] #if set, powfs.wvlwts must be set to empty.
