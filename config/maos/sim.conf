#File sim.conf
#Contains common parameters to all setups. 
#SI units are used unless otherwise noted.
#Entries marked as (engineering) are not used for normal simulations
__default__ 	 #this file contains default setup (will not override existing records).
#path=dir #add dir to path. Relative to the directory of enclosing conf file unless absolute path is used.
#Telescope Aperture Configuration.
aper.d     	  = [30 3.6] #outer (d) and inner diameter (din) in meter. may contain one number for [d] or two numbers for [d din]. din=0 when omitted.
aper.fnamp    = "TMT_23cm6.bin" #The telescope aperture amplitude map file. It contains a nx*ny 2d array of values between 0 and 1 with the following keywords:
	              # dx, dy: grid spacing in m.
				  # ox oy: grid origin in m. FFT style origin (-nx/2*dx) is used if omitted. 
				  # ht. height in m. always at 0.

aper.rotdeg   = 0     #Telescope pupil rotation CCW in degrees.
aper.pupmask  = ""    #Instrument pupil Lyot mask file.
aper.misreg	  =	[0,0] #Telescope pupil misregistration along x and y in meter.

#Simulation parameters.
sim.seeds     = [1]   #random seeds. a list. 0 means random seed
sim.start     = 0     #first time step. usually 0.
sim.end       = 500   #last time step (exclusive)
sim.closeloop = 1     #1: closed loop (CL) simulation. 0: open loop correction without feedback control.
sim.dt        = 1/600 #Main loop sampling time in seconds.
sim.dtref     = 1/600 #The integration time in seconds for which the powfs.siglev is computed. Do not change this value. The actual integration time is governed by sim.dt and powfs.dtrat.
sim.zadeg     = 0     #zenith angle in degrees.
sim.htel      = 4000  #height of telescope in meters from mean sea level. It is used to adjust powfs.hs for LGS. 
sim.cachedm   = 4     #Caching DM commands to fine sampled grids to speed up ray tracing.  #=1: sampling is dm.dx/4. >3: sampling is dm.dx/sim.cachedm. 0 to disable.
sim.fov       = 0     #The entire FoV diameter in arcsec. Only used for plotting.

#RTC servo coefficients. The total (high order) loop latency is sim.dt*(powfs.dtrat+1+sim.alhi).
#A is command. e is error signal. at time step n, the command is updated by
#A(n)=A(n-1)*ap(0)+A(n-2)*ap(1)+...+e(n-2)*ep. 
sim.aphi      = 1     #high order loop integrator leakage parameter ap. 
sim.ephi      = 0.5   #high order loop error gain ep.
sim.alhi      = 0     #Additional latency (in sim.dt) of the high order loop. Can be fractional but must be >=0. 
sim.f0dm	  = 0     #Natural frequency of the DMs in Hz. 0 is for spontaneous response.
sim.zetadm    = 1     #Damping of the DMs.
sim.aplo      = ref:sim.aphi #ap for low order control. See sim.aphi
sim.eplo      = ref:sim.ephi #error gain of low order modes. See sim.ephi
sim.allo      = ref:sim.alhi #Additional latency (sim.dt) of the lo order loop. See sim.alhi. 
sim.fcttm     = 20    #Cross over frequency in Hz of T/T split between DM and TTM (20Hz)*/

#Focus tracking gains.
sim.fcfocus   = inf   #cross-over frequency in Hz of the focus LPF. LPF gain is lpfocus=2*pi*fc/fs where fs is sampling frequency. 
	      	     	  #-1 means 1/10 of NGS frame rate. inf means remove LGS focus completely. 
sim.mffocus   = -1    #method for focus tracking. 
						#0: disable focus update. 
						#1: Focus tracking using closed loop gradients, for each LGS independently. (preferred)
						#2: Focus tracking using closed loop graidnets, for common LGS focus only.
						#-1: auto. 1 for LGS, 0 for NGS.
#Focus offloading to telescope
sim.focus2tel = 0     #Offload focus to telescope. (engineering)
sim.epfocus2tel=0.01  #Integrator gain for telescope focus control
#Truth WFS reference vector update parameters
sim.aptwfs    = 1     #Truth WFS reference vector update leakage ap.
sim.eptwfs    = 0.05  #Truth WFS reference vector update integrator gain.
sim.eptsph	  = 0.5   #Truth WFS reference vector update integrator gain for spherical mode.
#Other
sim.skysim    = 0     #enable presimulation for sky coverage (applies ideal correction for NGS WFS controlled modes and saves NGS WFS complex PSFs).
sim.wspsd     =	      #Telescope wind shake PSD input. Nx2. First column is frequency in Hz, Second column is PSD in rad^2/Hz.
sim.wsseq     = 1     #Windshake sequence random number generator seed. different wsseq gives different realization.
sim.dmadd     = ""    #file containing dm vector to simulate turbulence (added to integrator output). 
	                  #Contains ndm cells. In each cell, one colume is for each time step. Wraps over in the end. Can be empty.

#if mvmport is nonzero connect to the mvm server at mvmhost:mvmport.
sim.mvmhost   = "localhost" #Where does the MVM server run (engineering)
sim.mvmport   = 0     #which port does the MVM server run. 0: disable mvm server/client (engineering)
sim.mvmsize   = 0     #number of gradients to send each time. 0 is all. (engineering)
sim.mvmngpu   = 0     #>0: limit maximum number of gpus to use.	(engineering)

#For special purpose
sim.noatm     = 0     #Disable atmosphere generation (e.g., to evaluate telescope errors).
sim.evlol     = 0     #evaluate open loop performance only. Skip wfs/tomography/reconstruction.
sim.psfr      = 0     #Save PSF reconstruction telemetry.
sim.ecnn      = 0     #Estimate WF covariance due to WFS noise cov Cnn.
sim.wfsalias  = 0     #Study the wfs aliasing effect by project turbulence onto the orthogonal of the DM vector space. 
sim.idealfit  = 0     #evaluation ideal fit error only. no wfs, no recon. 
sim.idealtomo = 0     #ideal tomography without wfs (directly propagate from turbulence).
sim.idealwfs  = 0     #Implements ideal WFS by only using turbulence in DM range. conflicts sim.wfsalias
sim.idealevl  = 0     #Evaluate the performance only in DM range.
sim.dtrat_skip= 0     #drop frame every this many time steps (sim.dt). 0 no drop. This is to simulate RTC dropping frames. (engineering)
sim.fuseint   = 1     #use fused integrator. for high and low order loop. Keep at 1. (engineering)
sim.pause     = 0     #Pause after every step (engineering)

#GPU enablement for various functions. 
gpu.wfs       = 1     #Use GPU for wavefront sensor modeling
gpu.evl       = 1     #Use GPU for Performance evaluation
gpu.tomo      = 1     #Use GPU for tomography
gpu.fit       = 1     #Use GPU for DM fitting
gpu.lsr       = 1     #Use GPU for least square reconstruction
gpu.psf       = 1     #Use GPU to accumulate PSF.
gpu.moao      = 1     #Use GPU for MOAO

#Atmospheric turbulence common parameters (atm.r0z etc. are defined in atm_*.conf files)
atm.method    = 0     #0: Von Karman (default). 1: Fractal method. 2: Biharmonic. (engineering)
atm.ninit     = 17    #Initial size of the screen in fractal method. >=2 (engineering)
atm.size      = [64 64] #size of atmosphere in meter. 0: automatic to cover the metapupil.
atm.dx        = 1/64  #Sampling of the atmosphere in meter. Usually match evl.dx. Change powfs.dx to match if necessary.
atm.wddeg     = [0]   #Fixed wind direction (in degree) for all (1 number) or each (same length as atm.ht) turbulence layer. not used if atm.wdrand is set.
atm.wdrand    = 1     #>0: as an additional seed to randomize wind direction (see sim.seeds)
atm.frozenflow= 1     #using frozen flow screen (when sim.closeloop=0. sim.closeloop=1 is always frozenflow)
atm.share     = 1     #1: share atmoshere between different maos runs with the same seed using mmap'ed file to save memory. (engineering)
atm.r0evolve  = 0     #0: disable. 1: Scale turbulence screen spatially by r0logpsds, 2) Scale raytracing result using r0logpsdt, 3) both. Useful for long running simulations to vary r0.
atm.r0logpsdt = [-1.43 3.353e-4 0 0.3107] #[alpha beta fmin fmax]:temporal PSD of log(r0) /Hz: beta*f^alpha. Or a file of nx2
atm.r0logpsds = [-2.43 5.195e-5 0 1/30] #[alpha beta fmin fmax]:spatial PSD of log(r0) /Hz: beta*f^alpha. Or a file of nx2

#Tomography turbulence parameters
atmr.dx       = 0     #Fundemental reconstruction grid sampling in meter. 0: matching the subaperture spacing of high order WFS.
atmr.os       = [2]   #Reconstruction screen oversampling over atmr.dx. 1 number per atmr layer (see atmr.ht) or a single number for all layers.
atmr.r0z      = ref:atm.r0z #atm r0 at zenith in meter. -1: matches atm.r0z
atmr.L0       = ref:atm.L0  #atm outer scale in meter.  -1: matches atm.l0
atmr.ht       = ref:atm.ht  #reconstructed screen height in meter. Empty meaning follow atm.ht (MCAO)
atmr.wt       = ref:atm.wt  #reconstructed screen weight. Empty meaning follow atm.wt (MCAO)

#CN2 Estimation using slodar.
cn2.pair      = []    #pairs of wfs to estimate cn2. empty to disable cn2 estimation.
cn2.step      = 100   #cn2 estimation output results every cn2.step time steps.
cn2.reset     = 0     #reset the accumulated cn2 after every cn2.reset set of results.
cn2.hmax      = 18000 #maximum layer height in meter to esimate at zenith.
cn2.saat      = 0.95  #subaperture normalized area threashold to use in cn2 estimation.
cn2.keepht    = 1     #1: Interpolate slodar results onto atmr.ht. 2: do slodar directly on these layers. 1 works better.
cn2.tomo      = 0     #1: update tomography parameters with slodar output.
cn2.verbose   = 1     #1: output estimated r0, cn2 during simulation.
cn2.nhtomo    = 6     #number of layers to feed into reconstructor. only effective if keepht==0
cn2.psol      = 1     #1: use pseudo open loop gradients. 0: use residual turbulence. 1 works better.
cn2.moveht    = 0     #move the ht used for reconstructor to near strongest layers. only effective if keepht=0.

#set MOAO DMs parameters. See dm.* for definition
moao.dx       = [0.5] #spacing of actuator in meter. see dm.dx.
moao.iac      = [0.223] #inter-actuator coupling. see dm.iac
moao.gdm      = [0.5] #low pass filter gain on MOAO DM command.
moao.stroke   = [inf] #actuator stroke
moao.actslave = [0]   #inactive actuator slaving flag.
moao.lrt_ptt  = [0]   #low rank terms (piston/tip/tilt removal)
moao.guard    = [1]   #rings of guard actuators
moao.actstuck = [""]  #list of stuck actuators. See dm.actstuck
moao.actfloat = [""]  #list of floating actuators. see dm.actfloat
moao.ar       = [1]   #aspect ratio. see dm.ar.
#Science evaluation field parameters
evl.dx      = ref:atm.dx  #sampling of the aperture in meter in simulation. -1: follow atm.dx
evl.psfr    = [1] #output psf reconstruction telemetry for this direction.
evl.hs      = [inf] #the height of the science object. normally infinity. 
evl.rmax    = 1   #max radial order for zernke fitting in performance evaluation. 1: includes piston/tip/tilt. 2: p/t/t/focus/astigmatism
evl.tomo    = 0   #Use tomography output directly as wavefront correction. (engineering)
evl.moao    = -1  #index into MOAO config in recon.conf
evl.psfhist = 0   #output history of the complex psf (a lot of storage). 
evl.psfmean = 0   #output time averaged psf after incrementally averaging this many time steps.
				  #1: only save in the end. n: save average every n steps (no reset after saving)
evl.psfol   = 0   #compute open loop psf in additional to closed loop PSF. 
	        	  #0: disable 1: on axis direction only, 2: all directions and average them.
evl.psf     = [1] #Include this direction if psf is computed. 1 or nevl elements. 1: regular, 2: ngs mode removed in ahst. 3: both.
evl.pttr    = [0] #remove p/t/t in wavefront OPD before computing PSF or covariance.
evl.cov     = 0   #save covariance of opd for directions for steps like evl.psfmean (no reset after saving). For PSF reconstruction.
evl.opdmean = 0   #save science opd time average every this many time steps if >0.
evl.wvl     = [1.25e-6 1.65e-6 2.2e-6] #wavelength to evaluat PSF or strehl
evl.psfisim = 20  #time step to start psfmean/psfhist
evl.psfgridsize=[]#1-d FFT grid size for psf computation for each wavelength. 0,1,or evl.nwvl number of elements. 
				  #empty or 0:automatic.The computed PSF has sampling of evl.wvl/(evl.psfgridsize*evl.dx).
evl.psfsize = []  #Limit PSF side length in pixels for output. Larger PSF is truncated to this size.
		    	  #Set to 1 to compute strehl only. 1 or nwvl number of elements(for each wvl)

#some common DM parameters that are usually the same for each DM. Can take either 1 or ndm values.
dm.dx     = [0.5]  #spacing of DM actuators in meter at the primary mirror. preferred way to set system order as of 2014-04-03. Only way since 2016.
dm.ar     = [1]    #DM actuator spacing aspect ratio. dy/dx spacing
dm.guard  = [1]    #extra DM actuator rings in actuator grid. default: 1
dm.stroke = [inf]  #surface stroke in micron. opd is [-stroke stroke]
dm.iastroke=[inf]  #surface inter-actuator stroke in micron (or voltage if dm.strokescale is supplied)
dm.strokescale=[]  #describes polynomials that convert opd to voltage (first cell), and voltage to opd
			       # (second cell). The two operations has to be strict inverse of each other
dm.iac    = [0.223] #inter-actuator-coupling coefficient for cubic influence function. 0: disable. 4/29/2019: updated from 0.3.
dm.hist   = [0]    #output histogram of DM actuator commands.
dm.histbin= [1e-7] #The bin size in meters for DM histogram computation.
dm.histn  = [201]  #Total number of bins. odd number, centered around zero.
dm.vmisreg= [0]    #DM vertical misregistration. not implemented yet.
dm.hyst   = [0]    #DM model hysteresis amount (ratio) 
dm.hyst_alpha=[2]  #The DM model hysteresis alpha parameter
dm.hyst_stroke=[10e-6] #The surface stroke that the hysteresis is measured at
dm.actfloat = [""] #file containing floating actuators. nx2 coordinate
dm.actstuck = [""] #file containing stuck actuators. nx2 coordinate. or nx3 with third column the stuck position (in opd).
dm.dratio   = [1]  #telescope diameter to DM diameter ratio (beam angle magnification factor). Used to scale DM OPD correction.

#Distortion parameters
#Use powfs.misregx/y instead for WFS misregistration (shift)
#Use aper.misreg instead for telescope pupil miregistration (shift)
distortion.tel2wfs=[] #From telescope pupil (atmosphere) to WFS.  It handles SA thresholding correctly.
distortion.dm2wfs=[] #From DM to WFS. "0.5+x; 0.2+y" #for pure shift of 0.5, 0.2 along x and y. 
distortion.dm2sci=[] #From DM to science.

ncpa.calib= 1    #calibrate NCPA. Only useful if surf is not empty.  #1: use all DMs. 2: use only ground dm
ncpa.ttr  = 0    #Remove average t/t from NCPA for WFS. Equivalent as performing WFS registration alignment.
ncpa.thetax= []  #x coordinate for NCPA calibration direction (arcsec). empty means follow evl.thetax.
ncpa.thetay= []  #y coordinate for NCPA calibration direction(arcsec). empty means follow evl.thetay.
ncpa.wt    = []  #Weight for each NCPA calibration direction. (see evl.wt)
ncpa.hs    = []  #Height of star for each NCPA calibration direction. (see powfs.hs)
ncpa.preload=0   #1: preload integrator with DM sys flat, 0: add DM sys flat after the integrator. (engineering)
ncpa.rmsci=0     #1: do not include uncorrelatable error in science path. (engineering)

ncpa.surf  = []  #Simulating surfaces like the telescope or NCPA.
                 #Each file contains an array with the following keys in header, or a prescription to generate screens 
				 #(e.g., "r0=0.2;L0=30;dx=1/64;nx=1024;slope=-11/3;seed=1;SURFEVL=[0];SURFWFS=[1]" or "rms=100;mode=5;dx=1/64;nx=1024") 
				 #keys:(all units are in meters.)
                 #dx: the sampling along x and y direction (must be the same)
                 #ox,oy: the origin along x and y direction
                 #h: height of the surface from pupil.	
                 #SURFEVL=[]: vector of the same length of evl.thetax with 1 or 0 to indicate whether the science evaluation direction is covered or not by this map. If keyword is not present, assume all are covered. 
                 #SURFWFS=[]: vector of the same length of wfs.thetax with 1 or 0 to indicate whether the WFS is covered or not by this map. If keyword is not present, assume all are covered. 
                 #Important: The OPD should cover more area (1/2 meter each side) than meta pupil for interpolation to avoid edge roll off.

ncpa.tsurf = []  #Simulating surfaces on M3 that is tilted in converging beam
                 #Each file contains an array of surface map (NOT OPD) with the following key in header.
				 #keys:(all units are in meters.)
                 #dx,dy: the sampling along x and y direction, 
                 #ox,oy: the origin along x and y direction, 
                 #txdeg: the x tilt angle in degree wrt beam (90 is prep), 
                 #tydeg: the y tilt angle in degree wrt beam (90 is prep), 
                 #ftel: The telescope effective focal length, 
                 #fexit: the distance between the exit pupil and the focus, 
                 #fsurf: the distance between the M3 and the focus.
