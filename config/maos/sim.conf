#FILE sim.conf
#Contains common parameters to all setups. 

#Telescope Aperture Configuration.
aper.d     = [30 3.6] #may contain one for [d] or two numbers for [d din]. d is
		      #outer diameter. din is optimal inner hole diameter.
aper.dx       = 1/64  #sampling of the aperture in simulation
aper.fnamp    = "TMT_CurDesign.bin.gz" #The amplitude map contains a cell array
	              # of 2 elements.  The first element is 5x1 vector,
	              # specifying sampling dx, dy, origin coordinate ox, oy and
	              # height (0).  The second element is a NxN square array.
aper.rotdeg   = 0     #Telescope pupil rotation CCW with respect to instrument. 
aper.misreg   = [0 0] #misregistration of the pupil. Shifts the amplitude map and atmosphere.
aper.pupmask  =       #the science pupil mask.

#defines simulation parameters.
sim.seeds     = [1]   #random seeds. a list. 0 means random seed
sim.start     = 0     #first time step. usually 0.
sim.end       = 500   #last time step (exclusive)
sim.closeloop = 1     #closed loop simulation
sim.dt        = 1/800 #loop sampling time. (WFS integration time)
sim.zadeg     = 0     #zenith angle. moved from atm.zadeg
sim.cachedm   = 1     #Caching DM commands to fine sampled grids that matches
	              #the sampling of the WFS and/or science evaluation
	              #grid. speed up simulation
sim.fov       = 120   #The total FoV.
#Servo coefficients. There is two cycle delay.
#A is command. e is error signal. at time step n, the command is updated by
#A(n)=A(n-1)*apdm(0)+A(n-2)*ap(1)+...+e(n-2)*ep
sim.apdm      = [1 0] #this is the default. [0.5 0.5] is used in laos 
sim.epdm      = 1/2   #error gain of high order loop
sim.apngs     = [1 0] #this is the default. [0.5 0.5] is used in laos.
sim.epngs     = 0.5   #error gain of ngs mode in split tomography

sim.fuseint   = 1     #use fused integrator. for high and low order loop.
sim.servotype_hi=1    #1: simple integrator servo for high order loop
sim.servotype_lo=1    #1: simple integrator servo for low order loop. 2: type II control.
sim.gtypeII_lo=""     #contains 3x1 or 3xnmod coeffs for type II servo lo 
 
#Focus tracking gains.
sim.lpfocus   = 0     #coefficient for focus update low pass filter
sim.epfocus   = 0     #coefficient for focus update integrator error gain.
sim.mffocus   = 0     #method for focus update. 0 to disable focus update. 1:
	      	      #default implementation in RTC block diagram. see recon.c
	      	      #for details.

#Uplink laser pointing servo
sim.apupt     = [1 0] #[0.5 0.5] is used in laos.
sim.epupt     = 0.5   #uplink integrator gain
sim.dpupt     = 0.0   #uplink derivative gain if use derivative control.
sim.uptideal  = 0     #ideal correction on uplink (debugging)

#Other
sim.skysim    = 0     #enable presimulation for sky coverage.
sim.wspsd     =	      #Telescope wind shake PSD input. Nx2. First column is freq
		      #in Hz, Second column is PSD in rad^2/Hz.
gpu.wfs       = 1     #Use GPU for WFS sensing
gpu.evl       = 1     #Use GPU for Performance evaluation
gpu.tomo      = 1     #Use GPU for tomography
gpu.fit       = 1     #Use GPU for DM fitting
gpu.lsr       = 1     #Use GPU for LSR

#For special purpose
sim.noatm     = 0     #Disable atmosphere generation (to evaluate telescope errors).
sim.evlol     = 0     #evaluate open loop performance only. don't do wfs/tomo/recon.
sim.psfr      = 0     #Save PSF reconstruction telemetry.
sim.ecnn      = 0     #Estimate WF covariance due to WFS noise cov Cnn.
sim.wfsalias  = 0     #Study the wfs aliasing effect by project turbulence onto
  	      	      #the orthogonal of the DM vector space.
sim.idealfit  = 0     #evaluation ideal fit error only. no wfs, no recon. (was fitonly)
sim.idealtomo =0      #ideal tomography without wfs (directly propagate from turbulence).
sim.idealwfs  = 0     #Implements ideal WFS by only using turbulence in DM range. conflicts sim.wfsalias
sim.idealevl  = 0     #Evaluate the performance only in DM range.
#Common atmospheric parameters
atm.fractal   = 0     #Use fractal method to generate atmosphere screen. 0: fft method.
atm.size      = [0 0] #size of atmosphere in meter. 0: automatic.
atm.dx        = 1/64  #sampling of the atmosphere, match aper.dx
atm.wdrand    = 1     #>0: as additional seed to randomize wind direction 
atm.evolve    = 0     #evolve the atm in additional to frozen flow. developed
		      #for fractal since it does not wrap. Need twice as storage.
atm.frozenflow=0      #using frozen flow screen (at OL. CL is always frozenflow)
atm.ninit     = 17    #Initial size of the screen in fractal method. >=2
atm.share     = 1     #We share atmosphere by default.

#CN2 Estimation
cn2.pair      = []    #pairs of wfs to estimate cn2. empty to disable cn2 estimation.
cn2.step      = 100   #do cn2 estimation every this time step
cn2.reset     = 0     #reset the accumulated cn2 after every cn2step.
cn2.hmax      = 18000 #maximum height to esimate at zenith
cn2.saat      = 0.95  #subaperture area threashold to use in cn2 estimation
cn2.keepht    = 1     #1: keep the layer ht specified by atmr.ht by
		      #interpolation. 2: do slodar directly on these layers.
cn2.tomo      = 0     #update tomography parameters if non zero
cn2.nhtomo    = 6     #number of layers to feed into reconstructor. only effective if keepht==0
cn2.moveht    = 0     #move the ht used for reconstructor to near strongest layers. only
                      #effective if keepht=0.

#set MOAO DMs parameters.
moao.order    = [0]   #override this if moao is required.
moao.cubic    = [1]
moao.iac      = [0.3]
moao.stroke   = [inf]
moao.actslave = [0]
moao.lrt_ptt  = [0]
moao.actstuck = [""]
moao.actfloat = [""]

#some common fov parameters
evl.misreg  = [0 0]#misregistration
evl.psf     = [1] #output psf for this direction if psf is computed. 1 or nevl elements.
evl.psfr    = [1] #output psf reconstruction telemetry for this direction.
evl.hs      = [inf] #the height of the science object. normally infinity. 
evl.rmax    = 1   #max radial order in performance evaluation. 
	       #1: includes piston/tip/tilt. 2: p/t/t/focus/astigmatism
evl.tomo    = 0 #evaluate CL error for tomography
evl.moao    = -1 #index into MOAO config in recon.conf
evl.psfhist = 0 #output history of the psf (a lot of storage). 
evl.psfmean = 0 #output time averaged psf. for this number of psf's along the
		#way. 1: only save in the end. n: save cumulative average every
		#n steps (do not reset)
evl.opdcov  = 0 #save covariance of opd for directions where evl.psf==1.
evl.psfol   = 1 #compute OL psf in additional to CL PSF. 0: disable 1: on axis
	        #direction only, 2: all directions and average them.

evl.wvl     = [1.25e-6 1.65e-6 2.2e-6]#wavelength to evaluat PSF or strehl
evl.psfpttr = [0] #remove p/t/t in wavefront OPD before computing PSF.
evl.psfisim = 20  #time step to start psfmean/psfhist
evl.psfgridsize = [] #FFT grid size for psf computation for each
		     #wavelength. 0,1,or nwvl number of elements. 0:
		     #automatic. This determines the sampling of the computed
		     #PSF. length matches evl.wvl
evl.psfsize = [512] #size of the psf to output. The large PSF is cut to this
		    #size. Set to 1 to compute strehl only. 1 or nwvl number of
		    #elements(for each wvl)

#some common DM parameters that are usually the same for each DM. Can take either 1 or ndm values.
dm.guard  = [1]    #extra DM actuator rings in actuator grid
dm.stroke = [inf]  #surface stroke in meter. opd is [-stroke stroke]
dm.cubic  = [1]    #1: cubic influence function, with dm.iac as inter-actuator-coupling.
dm.iac    = [0.3]  #inter-actuator-coupling coefficient.  
dm.hist   = [0]    #output histogram of DM actuator commands.
dm.histbin= [1e-7] #The bin size for DM histogram computation.
dm.histn  = [201]  #Total number of bins. odd number, centered around zero.
dm.vmisreg= [0]    #vertical misregistration. not implemented yet.
dm.misreg = [""]   #misregistration.
dm.hyst   = [""]   #File containing a matrix that describes the hysterisis. The
		   #matrix should have 3 rows, and multiple columns. Each column
		   #describe the parameters for a mode, and the rows are: 1)
		   #weight 2) alpha, 3) beta. See "Hysteresis Modeling and
		   #Simulation" by Luc Gilles. Notice that this alpha is alpha
		   #in laos multiplied by 0.5e-6.
dm.actfloat = [""] #file containing floating actuators. nx2 coordinate
dm.actstuck = [""] #file containing stuck actuators. nx2 coordinate.
