#FILE wfs_lgs_tt_ttf.conf
#Contains 6 LGS in a pentagon at 70" diameter by default.

#powfs is type of wfs.
powfs.order   = [0 2 1 1]  # number of sa in one dimension. 0 to match ground DM order.
powfs.dx    = [1/64 1/16 1/16 1/16] #sampling of opd in each subaperture.  NGS
	    	         #performs pretty good with 1/16 sampling.
powfs.hs    = [90e3 inf inf inf] #height of the guide star. 90e3 for LGS. inf for NGS.
powfs.fnllt = ["llt_CL.conf" "" "" ""] # configuration of laser launch telescope. 
powfs.trs   = [1 0 0 0]    #tilt remove flag. 1 for LGS. 0 for NGS
powfs.dfrs  = [0 0 0 0]    #differential focus removal flag. 1 for LGS. 0 for NGS
powfs.lo    = [0 1 1 1]    #low order. 1 for T/T or T/T/F WFS. 0 for LGS and high order NGS
powfs.saat  = [0.6 0.1 0.1 0.1]  #threshold of relative area to turn off subaperture.
powfs.neareconfile=["" "" "" ""] #file contains NEA for each SA. takes precedence. File name
			    #takes same format as piinfile. in radian unit. (takes precedance)
powfs.nearecon= [20 0.11 0.055 0.055] # noise equivalent angle in mas for reconstruction
powfs.neasim  = [-1 -1 -1 -1] # geometric only: nea in mas for simulation. -1 to match nearecon (not neareconfile).
powfs.neasimfile=["" "" "" ""]#read NEA used in simulation from file. Defined at
			   #sim.dt sampling rate, in radian. neasim must be -1
powfs.neaphy  = [0 0 0 0]  #1: use nea from matched filter in geometric simulations.
powfs.phyusenea = [0 0 0 0] #1: force use specified nea_recon in reconstruction
			   #in physical optics mode.
powfs.neaspeckle= [0 0 0 0] #speckle noise equivalent angle in mas. added to matched
			  #filter estimation of nea due to photon and detector
			  #noise in physical optics mode for reconstructor

powfs.gtype_sim = [0 1 1 1] #geometric gradient for simulation. 
                          #0: gtilt (averaging gradient). 
			  #1: ztilt (best zernike tip/tilt fit)
powfs.gtype_recon = [0 1 1 1] #gtype used for reconstructor. see gtype_sim.
#Physical optics options.
powfs.pixtheta= [0.5 -0.5 -0.5 -0.5] #CCD Pixel size in arcsec. if negative -alpha,
				#the size is alpha times nyquist sampling in the
				#longest wavelength.	 
powfs.radpixtheta=[0 0 0 0]#CCD Pixel size along radiual direction.

powfs.pixblur = [0 0 0 0]  #bluring of pixels in unit of pixtheta
powfs.pixpsa  = [6 8 8 8]  #number of pixels per subaperture or along azimuthal
			 #direction if radpix is nonzero. 6 is good for LGS.
powfs.radpix  = [16 0 0 0] #if non zero, radial pixel along radial direction. 
	      	      	 #If negative, figure out appropriate size automatically.
powfs.radrot  = [0 0 0 0]  #rotate OTF to do radial pixel 0: like laos. 1: rotate
			 #OTF. 1 is good for side launch to save memory.
powfs.ncomp   = [0 0 0 0]  #specify FFT grid size in WFS sensor imaging. 0: automatic.
powfs.pixoffx = [0 0 0 0]  #offset of psf center from pixel vertex.
powfs.pixoffy = [0 0 0 0]  #offset of psf center from pixel vertex.
powfs.i0scale = [0 0 0 0] #scale sum of averaged image intensity generated using
			#turbulence OTF to match normalized subaperture
			#area. This is used to build matched filter.
powfs.sigscale= [1 1 1 1] #scale factor from the wfs.siglev to wfs.siglevsim for
			#simulation. to simulate signal variation/mismatch
powfs.bkgrnd  = [0 0 0 0] #sky background in unit e/pixel/frame at sim.dt.
powfs.bkgrndc = [1 1 1 1] #background correction factor for powfs.bkgrnd. 1: DC
			#component fully removed.
powfs.bkgrndfn= ["" "" "" ""]#sky background/rayleigh backscatter image for each
			  #subaperture in each wfs. at sim.dt
powfs.bkgrndfnc=["" "" "" ""]#estimation of bkgrndfn that will be subtracted.
powfs.rne     = [3 5 5 5] #read out noise in e-
powfs.embfac  = [2 2 2 2] #embeding factor of complex pupil function to generate
			#subaperture image using FFT method. keep at 2 to avoid
			#aliasing
powfs.psfout  = [0 0 0 0] #output complex psf core for sky coverage. only valid in
			#split tomography, do ideal compensation of NGS modes.
powfs.pistatout = [0 0 0 0] #output tip/tilt removed averaged psf for later
			  #matched filter input
powfs.pistatstart=[0 20 20 20]#first time step to start outputing averaged psf.
powfs.pistatstc = [0 0 0 0]#shift pistat to center using fft method.
powfs.nwvl      = [1 2 2 2]#number of wavelength. 1 for LGS, 2 for J+H NGS

powfs.wvl       = [0.589e-6 1.25e-6 1.65e-6 1.25e-6 1.65e-6 1.25e-6 1.65e-6]
		#concatenated list of wavelength
powfs.wvlwts    = [1 0.5 0.5 0.5 0.5 0.5 0.5]#may be overriden by wfs.wvlwts
powfs.piinfile  = ["" "" "" ""]#pixel intensities input file prefix. Mainly used
			    #for NGS. If seed is 1, and pistatout=[0 1 1], the
			    #program outputs pistat_seed1_wfs[678].bin. Put
			    #here powfs.piinfile=["" "pistat_see1"
			    #"pistat_seed1"] here and set pistatout=[0 0 0] to
			    #run physical optics NGS simulation. PSF must be centered.
powfs.sninfile  = ["" "" "" ""]#speckle noise. not yet used
powfs.phystep  = [0 -1 -1 -1] #time step to start doing physical optics. -1 to
			   #disable physical optics.
powfs.phytype  = [1 1 1 1] #1: matched filter. 2:cog (not implemented yet)
powfs.phytypesim=[-1 -1 -1 -1]#physical optics type in simulation. -1 to match phytype
powfs.mtchcr  = [1 0 0 0] #use constraint matched filter for x(radial)
powfs.mtchcra  = [-1 -1 -1 -1] #use constraint matched filter for y(azimuthal)
powfs.mtchcpl  = [1 1 1 1] #use coupling between r/a measure error.
powfs.mtchstc  = [0 1 1 1] #shift peak in the short exposure image i0 to center
			 #using fft before building matched filter.
powfs.mtchscl  = [0 0 0 0] #scale subaperture image to have the same intensity as i0.
powfs.mtchadp  = [0 0 0 0] #Using adaptive matched filter.
#misregistration described by file containing a cell array A of 2xp, where p is
#1 or number of wfs belonging to this powfs. The misregistered coordinate is
#computed as
#xm{ip}=\sum_{ic}(A{1,ip}(1,ic)*pow(x,A{1,ip}(2,ic))*pow(y,A{1,ip}(3,ic)))
#ym{ip}=\sum_{ic}(A{2,ip}(1,ic)*pow(x,A{1,ip}(2,ic))*pow(y,A{1,ip}(3,ic)))
#where ip is ipowfs. ic is index of column in entries of A.
powfs.misreg   = ["" "" "" ""]
#none common path aberrations for powfs. Each file contains 2xn cell array,
#where n can be 1 or number of wfs belonging to this powfs. The format of each
#2x1 cell is the same as for surf. used in both preparation of matched filter
#and simulation.
powfs.ncpa     = ["" "" "" ""]
powfs.ncpa_method=[2 2 2 2]#Method to correct ncpa; 0: do nothing. 1: apply gradient
		         #offset. 2: apply bias to A when computing i0, should be
		         #more accurate than 1. 
powfs.noisy    = [1 1 1 1] #noisy detector in simulation.
powfs.dtrat    = [1 1 1 1] #sampling period relative to 1/sim.dt (1/800)

powfs.moao     = [-1 -1 -1 -1] #index into moao config. -1 mean no moao.
powfs.siglev   = [900 900 900 900]#siglev at always 800Hz for fully illuminated subaps
			      #(Circle and 1/4 of a circle for TT or TTF
			      #WFS). may be overriden by wfs.siglev

#x coordinate in arcsecond unit.
wfs.thetax=[0 0  -33.287 -20.5725  20.5725 33.287 15 -30 15]
#y coordinate in arcsecond unit.
wfs.thetay=[0 35 10.8156 -28.3156 -28.3156 10.8156 25.9808 0 -25.9808]
wfs.powfs =[0 0 0 0 0 0 1 2 3] #type of powfs for each wfs.

#signal level at 800 Hz for fully illuminated subaperture. 
wfs.siglev=[] #if set, powfs.siglev must be set to empty.
#concatenated lists of wavelength weighting.
wfs.wvlwts=[] #if set, powfs.wvlwts must be set to empty.
