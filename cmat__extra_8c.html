<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>maos-0.6.4: lib/cmat_extra.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lib/cmat_extra.c File Reference</h1>The following are functions that are only useful for <a class="el" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a>.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2725611a27bba450e4b17592425a0b3b"></a><!-- doxytag: member="cmat_extra.c::USE_COMPLEX" ref="2725611a27bba450e4b17592425a0b3b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>USE_COMPLEX</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8fa3c4cef9c249597bb27c189bfa70e3"></a><!-- doxytag: member="cmat_extra.c::cmpcpy" ref="8fa3c4cef9c249597bb27c189bfa70e3" args="(A, B, S)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>cmpcpy</b>(A, B, S)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="146b15da10eac68bacd2e58603410b6b"></a><!-- doxytag: member="cmat_extra.c::RA2XY" ref="146b15da10eac68bacd2e58603410b6b" args="(A)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>RA2XY</b>(A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="265c841095aea2a1650af702ac1bb91a"></a><!-- doxytag: member="cmat_extra.c::XY2RA" ref="265c841095aea2a1650af702ac1bb91a" args="(A)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>XY2RA</b>(A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b7067b7289792bf866cf3316109458cf"></a><!-- doxytag: member="cmat_extra.c::DO_LOOP" ref="b7067b7289792bf866cf3316109458cf" args="(AFTER, CMD)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DO_LOOP</b>(AFTER, CMD)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="146b15da10eac68bacd2e58603410b6b"></a><!-- doxytag: member="cmat_extra.c::RA2XY" ref="146b15da10eac68bacd2e58603410b6b" args="(A)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>RA2XY</b>(A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="265c841095aea2a1650af702ac1bb91a"></a><!-- doxytag: member="cmat_extra.c::XY2RA" ref="265c841095aea2a1650af702ac1bb91a" args="(A)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>XY2RA</b>(A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b7067b7289792bf866cf3316109458cf"></a><!-- doxytag: member="cmat_extra.c::DO_LOOP" ref="b7067b7289792bf866cf3316109458cf" args="(AFTER, CMD)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DO_LOOP</b>(AFTER, CMD)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="67c744661e8990a7ad32f86e4e7fc497"></a><!-- doxytag: member="cmat_extra.c::DO_COPY2" ref="67c744661e8990a7ad32f86e4e7fc497" args="(CCMD)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DO_COPY2</b>(CCMD)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#7d012cdba278344ecbc2714cf63ffaf7">cmaxabs</a> (const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute maximum of abs of the numbers  <a href="#7d012cdba278344ecbc2714cf63ffaf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#f3b5c3e441cfaf655561d1c2d37f145a">cminabs</a> (const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute minimum of abs of the numbers  <a href="#f3b5c3e441cfaf655561d1c2d37f145a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#05e65746042e26bd360d6e7ce2dca640">csumabs</a> (const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute sum of abs of the numbers  <a href="#05e65746042e26bd360d6e7ce2dca640"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#128c1f2e5ec78e2d83e7de64982b3f34">ccwm3</a> (<a class="el" href="structcmat.html">cmat</a> *restrict A, const <a class="el" href="structcmat.html">cmat</a> *restrict B, const <a class="el" href="structcmat.html">cmat</a> *restrict C)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise multiply of three matrices.  <a href="#128c1f2e5ec78e2d83e7de64982b3f34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#18ab9f6533541cbd1009203d12a5c1ac">ccwm2</a> (<a class="el" href="structcmat.html">cmat</a> *restrict A, const <a class="el" href="structcmat.html">cmat</a> *restrict B, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise multiply A=A.  <a href="#18ab9f6533541cbd1009203d12a5c1ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#8415fb720710c12beb34ef65e4c15bc5">ccwmcol</a> (<a class="el" href="structcmat.html">cmat</a> *restrict A, const <a class="el" href="structcmat.html">cmat</a> *restrict B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Component-wise multiply each column of A with B A(:,i)=A(:,i).  <a href="#8415fb720710c12beb34ef65e4c15bc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#c537b0ad1d3d03883f4a5979e96bf761">ccwm3col</a> (<a class="el" href="structcmat.html">cmat</a> *restrict A, const <a class="el" href="structcmat.html">cmat</a> *restrict W, const <a class="el" href="structcmat.html">cmat</a> *restrict B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component wise multiply of 2d complex matrix A,W and 1d vector B.  <a href="#c537b0ad1d3d03883f4a5979e96bf761"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#a512f3768a7155aa2fed40113f15cfd7">ccwmrow</a> (<a class="el" href="structcmat.html">cmat</a> *restrict A, const <a class="el" href="structcmat.html">cmat</a> *restrict B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Component wise multiply each row of A with B.  <a href="#a512f3768a7155aa2fed40113f15cfd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#74c60b022d7693e0973273b9651f4505">ccwmcol2</a> (<a class="el" href="structcmat.html">cmat</a> *restrict A, const dcomplex *restrict B1, const double wt1, const dcomplex *restrict B2, const double wt2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise multiply of columns of A with combination of B1 and B2: A(:,i)=A(:,i)*(B1*wt1+B2*wt2);  <a href="#74c60b022d7693e0973273b9651f4505"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#86f92e8ac1855f1c25f2c2780ee00eb7">ccwmrow2</a> (<a class="el" href="structcmat.html">cmat</a> *restrict A, const dcomplex *restrict B1, const double wt1, const dcomplex *restrict B2, const double wt2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise multiply of rows of A with combination of B1 and B2: A(i,:)=A(i,:).  <a href="#86f92e8ac1855f1c25f2c2780ee00eb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#cb122cb49f6760f7ef17133f64d24304">ccwmc</a> (<a class="el" href="structcmat.html">cmat</a> *restrict A, const <a class="el" href="structcmat.html">cmat</a> *restrict B, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise multiply A with conjugate of B: A=A.  <a href="#cb122cb49f6760f7ef17133f64d24304"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#42e5c392b9c07427312ef94f0e55ea33">ccwmd</a> (<a class="el" href="structcmat.html">cmat</a> *restrict A, const <a class="el" href="structdmat.html">dmat</a> *restrict B, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component multiply <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> A with <a class="el" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a> B.  <a href="#42e5c392b9c07427312ef94f0e55ea33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#b7a468d8dccd7e9095745af0367d51c6">cembed_wvf</a> (<a class="el" href="structcmat.html">cmat</a> *restrict A, const double *opd, const double *amp, const int nopdx, const int nopdy, const double wvl, const double theta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reshape amp.  <a href="#b7a468d8dccd7e9095745af0367d51c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7d5e997f3f896ee53fa48a683c50d1db"></a><!-- doxytag: member="cmat_extra.c::sq2cpy" ref="7d5e997f3f896ee53fa48a683c50d1db" args="(dcomplex *out, const dcomplex *in, const size_t length)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sq2cpy</b> (dcomplex *out, const dcomplex *in, const size_t length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f3bf0c08af81518daf8cf1b2c5a10439"></a><!-- doxytag: member="cmat_extra.c::realcpy" ref="f3bf0c08af81518daf8cf1b2c5a10439" args="(dcomplex *out, const dcomplex *in, const size_t length)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>realcpy</b> (dcomplex *out, const dcomplex *in, const size_t length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e8f7121f498b7d4912301cf180680637"></a><!-- doxytag: member="cmat_extra.c::abscpy" ref="e8f7121f498b7d4912301cf180680637" args="(dcomplex *out, const dcomplex *in, const size_t length)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>abscpy</b> (dcomplex *out, const dcomplex *in, const size_t length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#772387b5274cd5438d1612a1fd58d8d2">cembed</a> (<a class="el" href="structcmat.html">cmat</a> *restrict A, const <a class="el" href="structcmat.html">cmat</a> *restrict B, const double theta, CEMBED flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Embed array B into A with rotation theta CW.  <a href="#772387b5274cd5438d1612a1fd58d8d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#6f86acfdccdc2c5a1c3d02d4ae33ac15">cembedscaleout</a> (<a class="el" href="structcmat.html">cmat</a> *restrict A, const <a class="el" href="structcmat.html">cmat</a> *B, double xoutscale, double youtscale, const double theta, CEMBED flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">rotate (around fft center: (nx/2,ny/2)) CCW theta and embed in into A.  <a href="#6f86acfdccdc2c5a1c3d02d4ae33ac15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#b5a692d8dd9656bde4d9fe988d26695a">ccpcorner</a> (<a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *restrict B, CEMBED flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy and embed/crop psfin into psfout  <a href="#b5a692d8dd9656bde4d9fe988d26695a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#23f317cbb6e5cad3b80acefd960f7c7f">cabs2toreal</a> (<a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put abs square of each element into its realpart.  <a href="#23f317cbb6e5cad3b80acefd960f7c7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#952faac0b7598955f5d6108d66222707">cabstoreal</a> (<a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put abs of each elemnt into its realpart.  <a href="#952faac0b7598955f5d6108d66222707"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#4ff6717c6a0f3919c71a2dc6fde5aae8">ccpd</a> (<a class="el" href="structcmat.html">cmat</a> **restrict A0, const <a class="el" href="structdmat.html">dmat</a> *restrict B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> into real part of <a class="el" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a>.  <a href="#4ff6717c6a0f3919c71a2dc6fde5aae8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#b2baa26f7bd8861ab342eee97889522d">creal2d</a> (<a class="el" href="structdmat.html">dmat</a> **restrict A0, double alpha, const <a class="el" href="structcmat.html">cmat</a> *restrict B, double beta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy real part of a <a class="el" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a> to <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> with optional scaling: A0=A0.  <a href="#b2baa26f7bd8861ab342eee97889522d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#d50c3f29262e58d4032225e69edc892f">cabs22d</a> (<a class="el" href="structdmat.html">dmat</a> **restrict A0, double alpha, const <a class="el" href="structcmat.html">cmat</a> *restrict B, double beta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy abs squared of a <a class="el" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a> to <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> with optional scaling: A0=A0*alpha+abs(B).  <a href="#d50c3f29262e58d4032225e69edc892f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat__extra_8c.html#f912fcd3192a45180c528f075f1d0988">ctilt</a> (<a class="el" href="structcmat.html">cmat</a> *otf, double sx, double sy, int pinct)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tilt the otf to make the image shift.  <a href="#f912fcd3192a45180c528f075f1d0988"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The following are functions that are only useful for <a class="el" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a>. 
<p>
notice that fma and modf are slower than native functions. <hr><h2>Function Documentation</h2>
<a class="anchor" name="7d012cdba278344ecbc2714cf63ffaf7"></a><!-- doxytag: member="cmat_extra.c::cmaxabs" ref="7d012cdba278344ecbc2714cf63ffaf7" args="(const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cmaxabs           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute maximum of abs of the numbers 
<p>
<div class="fragment"><pre class="fragment"><a name="l00045"></a>00045                              {
<a name="l00046"></a>00046     <span class="keywordtype">double</span> max,min,sum;
<a name="l00047"></a>00047     maxmincmp(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>,A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>,&amp;max,&amp;min,&amp;sum);
<a name="l00048"></a>00048     <span class="keywordflow">return</span> max;
<a name="l00049"></a>00049 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f3b5c3e441cfaf655561d1c2d37f145a"></a><!-- doxytag: member="cmat_extra.c::cminabs" ref="f3b5c3e441cfaf655561d1c2d37f145a" args="(const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cminabs           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute minimum of abs of the numbers 
<p>
<div class="fragment"><pre class="fragment"><a name="l00053"></a>00053                              {
<a name="l00054"></a>00054     <span class="keywordtype">double</span> max,min,sum;
<a name="l00055"></a>00055     maxmincmp(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>,A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>,&amp;max,&amp;min,&amp;sum);
<a name="l00056"></a>00056     <span class="keywordflow">return</span> min;
<a name="l00057"></a>00057 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="05e65746042e26bd360d6e7ce2dca640"></a><!-- doxytag: member="cmat_extra.c::csumabs" ref="05e65746042e26bd360d6e7ce2dca640" args="(const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double csumabs           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute sum of abs of the numbers 
<p>
<div class="fragment"><pre class="fragment"><a name="l00061"></a>00061                              {
<a name="l00062"></a>00062     <span class="keywordtype">double</span> max,min,sum;
<a name="l00063"></a>00063     maxmincmp(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>,A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>,&amp;max,&amp;min,&amp;sum);
<a name="l00064"></a>00064     <span class="keywordflow">return</span> sum;
<a name="l00065"></a>00065 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="128c1f2e5ec78e2d83e7de64982b3f34"></a><!-- doxytag: member="cmat_extra.c::ccwm3" ref="128c1f2e5ec78e2d83e7de64982b3f34" args="(cmat *restrict A, const cmat *restrict B, const cmat *restrict C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccwm3           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>C</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
component-wise multiply of three matrices. 
<p>
A=A.*B.*C <div class="fragment"><pre class="fragment"><a name="l00071"></a>00071                                                                             {
<a name="l00072"></a>00072     <span class="keywordflow">if</span>(!B){
<a name="l00073"></a>00073     <a class="code" href="cmat_8h.html#2417a6c93f1245cf129586dce262aba3" title="Compute component wise multiply B=B.">ccwm</a>(A,C);
<a name="l00074"></a>00074     }<span class="keywordflow">else</span> <span class="keywordflow">if</span> (!C){
<a name="l00075"></a>00075     <a class="code" href="cmat_8h.html#2417a6c93f1245cf129586dce262aba3" title="Compute component wise multiply B=B.">ccwm</a>(A,B);
<a name="l00076"></a>00076     }<span class="keywordflow">else</span>{
<a name="l00077"></a>00077     assert(A &amp;&amp; B &amp;&amp; C);
<a name="l00078"></a>00078     assert(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> &amp;&amp; A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==C-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>&amp;&amp;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a> &amp;&amp; A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==C-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l00079"></a>00079     <span class="comment">//component-wise multiply A=A.*B</span>
<a name="l00080"></a>00080     <span class="keyword">const</span> <span class="keywordtype">size_t</span> ntot=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00081"></a>00081     <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;ntot; i++){
<a name="l00082"></a>00082         A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]=A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*C-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i];
<a name="l00083"></a>00083     }
<a name="l00084"></a>00084     }
<a name="l00085"></a>00085 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="18ab9f6533541cbd1009203d12a5c1ac"></a><!-- doxytag: member="cmat_extra.c::ccwm2" ref="18ab9f6533541cbd1009203d12a5c1ac" args="(cmat *restrict A, const cmat *restrict B, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccwm2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
component-wise multiply A=A. 
<p>
*B*alpha <div class="fragment"><pre class="fragment"><a name="l00090"></a>00090                                                                         {
<a name="l00091"></a>00091     assert(A &amp;&amp; A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>);
<a name="l00092"></a>00092     <span class="keyword">const</span> <span class="keywordtype">size_t</span> ntot=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00093"></a>00093     <span class="keywordflow">if</span>(B){
<a name="l00094"></a>00094     <span class="keywordflow">if</span>(fabs(alpha-1)&gt;1.e-15){
<a name="l00095"></a>00095         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;ntot; i++){
<a name="l00096"></a>00096         A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*=B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*alpha;
<a name="l00097"></a>00097         }
<a name="l00098"></a>00098     }<span class="keywordflow">else</span>{
<a name="l00099"></a>00099         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;ntot; i++){
<a name="l00100"></a>00100         A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*=B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i];
<a name="l00101"></a>00101         }
<a name="l00102"></a>00102     }
<a name="l00103"></a>00103     }<span class="keywordflow">else</span>{
<a name="l00104"></a>00104     <span class="keywordflow">if</span>(fabs(alpha-1)&gt;1.e-15){   
<a name="l00105"></a>00105         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;ntot; i++){
<a name="l00106"></a>00106         A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*=alpha;
<a name="l00107"></a>00107         }
<a name="l00108"></a>00108     }
<a name="l00109"></a>00109     }
<a name="l00110"></a>00110 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8415fb720710c12beb34ef65e4c15bc5"></a><!-- doxytag: member="cmat_extra.c::ccwmcol" ref="8415fb720710c12beb34ef65e4c15bc5" args="(cmat *restrict A, const cmat *restrict B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccwmcol           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Component-wise multiply each column of A with B A(:,i)=A(:,i). 
<p>
*B; <div class="fragment"><pre class="fragment"><a name="l00115"></a>00115                                                       {
<a name="l00116"></a>00116     <span class="keywordflow">if</span> (!B) <span class="keywordflow">return</span>;
<a name="l00117"></a>00117     assert(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> &amp;&amp; B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1);
<a name="l00118"></a>00118     dcomplex (*As)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>]=(dcomplex(*)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>])A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00119"></a>00119     dcomplex *B1=B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00120"></a>00120     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;ny; iy++){
<a name="l00121"></a>00121     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l00122"></a>00122         As[iy][ix]*=B1[ix];
<a name="l00123"></a>00123     }
<a name="l00124"></a>00124     }
<a name="l00125"></a>00125 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c537b0ad1d3d03883f4a5979e96bf761"></a><!-- doxytag: member="cmat_extra.c::ccwm3col" ref="c537b0ad1d3d03883f4a5979e96bf761" args="(cmat *restrict A, const cmat *restrict W, const cmat *restrict B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccwm3col           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
component wise multiply of 2d complex matrix A,W and 1d vector B. 
<p>
A(:,i)=A(:,i).*W(:,i).*B; <div class="fragment"><pre class="fragment"><a name="l00131"></a>00131                                                                              {
<a name="l00132"></a>00132 
<a name="l00133"></a>00133     <span class="keywordflow">if</span>(!W){
<a name="l00134"></a>00134     <a class="code" href="cmat__extra_8c.html#8415fb720710c12beb34ef65e4c15bc5" title="Component-wise multiply each column of A with B A(:,i)=A(:,i).">ccwmcol</a>(A,B);
<a name="l00135"></a>00135     }<span class="keywordflow">else</span>{
<a name="l00136"></a>00136     assert(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>&amp;&amp; A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==W-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>&amp;&amp;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==W-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>&amp;&amp;B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1);
<a name="l00137"></a>00137     dcomplex (*As)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>]=(dcomplex(*)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>])A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00138"></a>00138     dcomplex (*Ws)[W-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>]=(dcomplex(*)[W-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>])W-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00139"></a>00139     dcomplex *B1=B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;ny; iy++){
<a name="l00142"></a>00142         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l00143"></a>00143         As[iy][ix]=As[iy][ix]*Ws[iy][ix]*B1[ix];
<a name="l00144"></a>00144         }
<a name="l00145"></a>00145     }
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a512f3768a7155aa2fed40113f15cfd7"></a><!-- doxytag: member="cmat_extra.c::ccwmrow" ref="a512f3768a7155aa2fed40113f15cfd7" args="(cmat *restrict A, const cmat *restrict B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccwmrow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Component wise multiply each row of A with B. 
<p>
A(i,:)=A(i,:)*B <div class="fragment"><pre class="fragment"><a name="l00152"></a>00152                                                       {
<a name="l00153"></a>00153     <span class="keywordflow">if</span>(!A || !B) <span class="keywordflow">return</span>;
<a name="l00154"></a>00154     dcomplex (*As)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>]=(dcomplex(*)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>])A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00155"></a>00155     dcomplex *B1=B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00156"></a>00156     assert(A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> &amp;&amp; B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1);
<a name="l00157"></a>00157     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iy++){
<a name="l00158"></a>00158     dcomplex junk=B1[iy];
<a name="l00159"></a>00159     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l00160"></a>00160         As[iy][ix]*=junk;
<a name="l00161"></a>00161     }
<a name="l00162"></a>00162     }
<a name="l00163"></a>00163 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="74c60b022d7693e0973273b9651f4505"></a><!-- doxytag: member="cmat_extra.c::ccwmcol2" ref="74c60b022d7693e0973273b9651f4505" args="(cmat *restrict A, const dcomplex *restrict B1, const double wt1, const dcomplex *restrict B2, const double wt2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccwmcol2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wt2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
component-wise multiply of columns of A with combination of B1 and B2: A(:,i)=A(:,i)*(B1*wt1+B2*wt2); 
<p>
<div class="fragment"><pre class="fragment"><a name="l00170"></a>00170                                                         {
<a name="l00171"></a>00171     assert(A &amp;&amp; A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>); 
<a name="l00172"></a>00172     assert(B1);
<a name="l00173"></a>00173     dcomplex (*As)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>]=(dcomplex(*)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>])A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00174"></a>00174     <span class="keywordflow">if</span>(B2){
<a name="l00175"></a>00175     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l00176"></a>00176         dcomplex junk=B1[ix]*wt1+B2[ix]*wt2;
<a name="l00177"></a>00177         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iy++){
<a name="l00178"></a>00178         As[iy][ix]*=junk;
<a name="l00179"></a>00179         }
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181     }<span class="keywordflow">else</span>{
<a name="l00182"></a>00182     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l00183"></a>00183         dcomplex junk=B1[ix]*wt1;
<a name="l00184"></a>00184         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iy++){
<a name="l00185"></a>00185         As[iy][ix]*=junk;
<a name="l00186"></a>00186         }
<a name="l00187"></a>00187     }
<a name="l00188"></a>00188     }
<a name="l00189"></a>00189 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="86f92e8ac1855f1c25f2c2780ee00eb7"></a><!-- doxytag: member="cmat_extra.c::ccwmrow2" ref="86f92e8ac1855f1c25f2c2780ee00eb7" args="(cmat *restrict A, const dcomplex *restrict B1, const double wt1, const dcomplex *restrict B2, const double wt2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccwmrow2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wt2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
component-wise multiply of rows of A with combination of B1 and B2: A(i,:)=A(i,:). 
<p>
*(B1*wt1+B2*wt2); <div class="fragment"><pre class="fragment"><a name="l00196"></a>00196                                                        {
<a name="l00197"></a>00197     assert(A &amp;&amp; A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>); 
<a name="l00198"></a>00198     assert(B1);
<a name="l00199"></a>00199     dcomplex (*As)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>]=(dcomplex(*)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>])A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00200"></a>00200     <span class="keywordflow">if</span>(B2){
<a name="l00201"></a>00201     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iy++){
<a name="l00202"></a>00202         dcomplex junk=B1[iy]*wt1+B2[iy]*wt2;
<a name="l00203"></a>00203         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l00204"></a>00204         As[iy][ix]*=junk;
<a name="l00205"></a>00205         }
<a name="l00206"></a>00206     }
<a name="l00207"></a>00207     }<span class="keywordflow">else</span>{
<a name="l00208"></a>00208     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iy++){
<a name="l00209"></a>00209         dcomplex junk=B1[iy]*wt1;
<a name="l00210"></a>00210         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l00211"></a>00211         As[iy][ix]*=junk;
<a name="l00212"></a>00212         }
<a name="l00213"></a>00213     }
<a name="l00214"></a>00214     }
<a name="l00215"></a>00215 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cb122cb49f6760f7ef17133f64d24304"></a><!-- doxytag: member="cmat_extra.c::ccwmc" ref="cb122cb49f6760f7ef17133f64d24304" args="(cmat *restrict A, const cmat *restrict B, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccwmc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
component-wise multiply A with conjugate of B: A=A. 
<p>
*conj(B)*alpha; <div class="fragment"><pre class="fragment"><a name="l00219"></a>00219                                                                         {
<a name="l00220"></a>00220     assert(A &amp;&amp; A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>);
<a name="l00221"></a>00221     <span class="keyword">const</span> <span class="keywordtype">size_t</span> ntot=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00222"></a>00222     <span class="keywordflow">if</span>(B){
<a name="l00223"></a>00223     <span class="keywordflow">if</span>(fabs(alpha-1)&gt;1.e-15){
<a name="l00224"></a>00224         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;ntot; i++){
<a name="l00225"></a>00225         A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*=conj(B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i])*alpha;
<a name="l00226"></a>00226         }
<a name="l00227"></a>00227     }<span class="keywordflow">else</span>{
<a name="l00228"></a>00228         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;ntot; i++){
<a name="l00229"></a>00229         A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*=conj(B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]);
<a name="l00230"></a>00230         }
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232     }<span class="keywordflow">else</span>{
<a name="l00233"></a>00233     <span class="keywordflow">if</span>(fabs(alpha-1)&gt;1.e-15){   
<a name="l00234"></a>00234         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;ntot; i++){
<a name="l00235"></a>00235         A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*=alpha;
<a name="l00236"></a>00236         }
<a name="l00237"></a>00237     }
<a name="l00238"></a>00238     }
<a name="l00239"></a>00239 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="42e5c392b9c07427312ef94f0e55ea33"></a><!-- doxytag: member="cmat_extra.c::ccwmd" ref="42e5c392b9c07427312ef94f0e55ea33" args="(cmat *restrict A, const dmat *restrict B, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccwmd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
component multiply <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> A with <a class="el" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a> B. 
<p>
A=A.*B; <div class="fragment"><pre class="fragment"><a name="l00243"></a>00243                                                                         {
<a name="l00244"></a>00244     assert(A &amp;&amp; A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>);
<a name="l00245"></a>00245     <span class="keyword">const</span> <span class="keywordtype">size_t</span> ntot=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00246"></a>00246     <span class="keywordflow">if</span>(B){
<a name="l00247"></a>00247     <span class="keywordflow">if</span>(fabs(alpha-1)&gt;1.e-15){
<a name="l00248"></a>00248         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;ntot; i++){
<a name="l00249"></a>00249         A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*=B-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i]*alpha;
<a name="l00250"></a>00250         }
<a name="l00251"></a>00251     }<span class="keywordflow">else</span>{
<a name="l00252"></a>00252         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;ntot; i++){
<a name="l00253"></a>00253         A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*=B-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i];
<a name="l00254"></a>00254         }
<a name="l00255"></a>00255     }
<a name="l00256"></a>00256     }<span class="keywordflow">else</span>{
<a name="l00257"></a>00257     <span class="keywordflow">if</span>(fabs(alpha-1)&gt;1.e-15){   
<a name="l00258"></a>00258         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;ntot; i++){
<a name="l00259"></a>00259         A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*=alpha;
<a name="l00260"></a>00260         }
<a name="l00261"></a>00261     }
<a name="l00262"></a>00262     }
<a name="l00263"></a>00263 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b7a468d8dccd7e9095745af0367d51c6"></a><!-- doxytag: member="cmat_extra.c::cembed_wvf" ref="b7a468d8dccd7e9095745af0367d51c6" args="(cmat *restrict A, const double *opd, const double *amp, const int nopdx, const int nopdy, const double wvl, const double theta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cembed_wvf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>opd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>amp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nopdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nopdy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>theta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reshape amp. 
<p>
*exp(-2*pi/lambda*opd) into square and embed into center of A, with optional rotation of theta CW.<p>
benchmark: embed 32x32 into 64x64, without rotation takes 0.161 ms. with rotation takes 0.330 ms. <div class="fragment"><pre class="fragment"><a name="l00275"></a>00275                                                 {
<a name="l00276"></a>00276     dcomplex *psf=A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00277"></a>00277     <span class="keyword">const</span> <span class="keywordtype">int</span> npsfx=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00278"></a>00278     <span class="keyword">const</span> <span class="keywordtype">int</span> npsfy=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00279"></a>00279  
<a name="l00280"></a>00280     dcomplex wvk=2.*M_PI/wvl*I;
<a name="l00281"></a>00281     memset(psf, 0, <span class="keyword">sizeof</span>(dcomplex)*npsfx*npsfy);
<a name="l00282"></a>00282     <span class="keywordflow">if</span>(fabs(theta)&lt;1.e-10){<span class="comment">//no rotation.</span>
<a name="l00283"></a>00283     <span class="keyword">const</span> <span class="keywordtype">int</span> skipx=(npsfx-nopdx)/2;
<a name="l00284"></a>00284     <span class="keyword">const</span> <span class="keywordtype">int</span> skipy=(npsfy-nopdy)/2;
<a name="l00285"></a>00285     assert(skipx&gt;=0 &amp;&amp; skipy&gt;=0);
<a name="l00286"></a>00286     dcomplex *psf0=psf+skipy*npsfx+skipx;
<a name="l00287"></a>00287     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;nopdy; iy++){
<a name="l00288"></a>00288         dcomplex *psfi=psf0+iy*npsfx;
<a name="l00289"></a>00289         <span class="keyword">const</span> <span class="keywordtype">double</span> *opdi=opd+iy*nopdx;
<a name="l00290"></a>00290         <span class="keyword">const</span> <span class="keywordtype">double</span> *ampi=amp+iy*nopdx;
<a name="l00291"></a>00291         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;nopdx; ix++){
<a name="l00292"></a>00292         <span class="comment">//sqrt(1-cos^2)!=sin due to sign problem. </span>
<a name="l00293"></a>00293         psfi[ix]=ampi[ix]*cexp(wvk*opdi[ix]);
<a name="l00294"></a>00294         <span class="comment">//most time is spend in cexp.</span>
<a name="l00295"></a>00295         }
<a name="l00296"></a>00296     }
<a name="l00297"></a>00297     }<span class="keywordflow">else</span>{
<a name="l00298"></a>00298     <span class="comment">//rotated for LGS.</span>
<a name="l00299"></a>00299     <span class="comment">//rotate image CCW to -theta. coordinate rotate in reverse way.</span>
<a name="l00300"></a>00300     <span class="comment">//xnew=x*cos(theta)-y*sin(theta)</span>
<a name="l00301"></a>00301     <span class="comment">//ynew=x*sin(theta)+y*cos(theta);</span>
<a name="l00302"></a>00302     <span class="comment">//rotation is around the fft center: (nx/2, ny/2);</span>
<a name="l00303"></a>00303     <span class="comment">/*</span>
<a name="l00304"></a>00304 <span class="comment">      The original method of adding in to out is not right.</span>
<a name="l00305"></a>00305 <span class="comment">    */</span>
<a name="l00306"></a>00306     dcomplex (*psfs)[npsfx]=(dcomplex(*)[npsfx])psf;
<a name="l00307"></a>00307     double (*amps)[nopdx]=(double(*)[nopdx])amp;
<a name="l00308"></a>00308     double (*opds)[nopdx]=(double(*)[nopdx])opd;
<a name="l00309"></a>00309     <span class="keyword">const</span> <span class="keywordtype">double</span> ctheta=cos(theta);
<a name="l00310"></a>00310     <span class="keyword">const</span> <span class="keywordtype">double</span> stheta=sin(theta);
<a name="l00311"></a>00311     <span class="keywordtype">double</span> x2,y2;
<a name="l00312"></a>00312     <span class="keywordtype">double</span> x,y;
<a name="l00313"></a>00313     <span class="keywordtype">int</span> nopdx2=nopdx/2;
<a name="l00314"></a>00314     <span class="keywordtype">int</span> npsfx2=npsfx/2;
<a name="l00315"></a>00315     <span class="keywordtype">int</span> nopdy2=nopdy/2;
<a name="l00316"></a>00316     <span class="keywordtype">int</span> npsfy2=npsfy/2;
<a name="l00317"></a>00317     <span class="keywordtype">int</span> ix2, iy2;
<a name="l00318"></a>00318     <span class="keywordtype">double</span> iopd,iamp;
<a name="l00319"></a>00319     <span class="keyword">const</span> <span class="keywordtype">int</span> maxr=iceil(sqrt(nopdx*nopdx+nopdy*nopdy));
<a name="l00320"></a>00320     <span class="keywordtype">int</span> xskip=npsfx&gt;maxr?(npsfx-maxr)/2:0;
<a name="l00321"></a>00321     <span class="keywordtype">int</span> yskip=npsfy&gt;maxr?(npsfy-maxr)/2:0;
<a name="l00322"></a>00322     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=yskip; iy&lt;npsfy-yskip; iy++){
<a name="l00323"></a>00323         y=iy-npsfy2;
<a name="l00324"></a>00324         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=xskip; ix&lt;npsfx-xskip; ix++){
<a name="l00325"></a>00325         x=ix-npsfx2;
<a name="l00326"></a>00326         x2=x*ctheta+y*stheta+nopdx2;
<a name="l00327"></a>00327         y2=-x*stheta+y*ctheta+nopdy2;
<a name="l00328"></a>00328         <span class="keywordflow">if</span>(x2&gt;0 &amp;&amp; x2&lt;nopdx-1 &amp;&amp; y2&gt;0 &amp;&amp; y2&lt;nopdy-1){
<a name="l00329"></a>00329             ix2=ifloor(x2);
<a name="l00330"></a>00330             iy2=ifloor(y2);
<a name="l00331"></a>00331             x2=x2-ix2;
<a name="l00332"></a>00332             y2=y2-iy2;
<a name="l00333"></a>00333             iopd=opds[iy2][ix2]*(1.-x2)*(1.-y2)
<a name="l00334"></a>00334             +opds[iy2][ix2+1]*(x2*(1.-y2))
<a name="l00335"></a>00335             +opds[iy2+1][ix2]*((1-x2)*y2)
<a name="l00336"></a>00336             +opds[iy2+1][ix2+1]*(x2*y2);
<a name="l00337"></a>00337             iamp=amps[iy2][ix2]*(1.-x2)*(1.-y2)
<a name="l00338"></a>00338             +amps[iy2][ix2+1]*(x2*(1.-y2))
<a name="l00339"></a>00339             +amps[iy2+1][ix2]*((1-x2)*y2)
<a name="l00340"></a>00340             +amps[iy2+1][ix2+1]*(x2*y2);
<a name="l00341"></a>00341             psfs[iy][ix]=iamp*cexp(wvk*iopd);
<a name="l00342"></a>00342         }
<a name="l00343"></a>00343         }
<a name="l00344"></a>00344     }
<a name="l00345"></a>00345     }
<a name="l00346"></a>00346 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="772387b5274cd5438d1612a1fd58d8d2"></a><!-- doxytag: member="cmat_extra.c::cembed" ref="772387b5274cd5438d1612a1fd58d8d2" args="(cmat *restrict A, const cmat *restrict B, const double theta, CEMBED flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cembed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CEMBED&nbsp;</td>
          <td class="paramname"> <em>flag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Embed array B into A with rotation theta CW. 
<p>
Current version, preferred <div class="fragment"><pre class="fragment"><a name="l00369"></a>00369 {
<a name="l00370"></a>00370     <span class="keyword">const</span> dcomplex *restrict in=B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00371"></a>00371     <span class="keyword">const</span> <span class="keywordtype">int</span> ninx=B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00372"></a>00372     <span class="keyword">const</span> <span class="keywordtype">int</span> niny=B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00373"></a>00373     dcomplex *restrict out=A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00374"></a>00374     <span class="keyword">const</span> <span class="keywordtype">int</span> noutx=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00375"></a>00375     <span class="keyword">const</span> <span class="keywordtype">int</span> nouty=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00376"></a>00376     <span class="comment">/*</span>
<a name="l00377"></a>00377 <span class="comment">      rotate (around fft center: (nx/2,ny/2)) CCW theta and embed in into A. </span>
<a name="l00378"></a>00378 <span class="comment">      flag==0: pure copy</span>
<a name="l00379"></a>00379 <span class="comment">      flag==1: copy abs2;</span>
<a name="l00380"></a>00380 <span class="comment">      flag==2: copy real only.</span>
<a name="l00381"></a>00381 <span class="comment">    */</span>
<a name="l00382"></a>00382     memset(out, 0, <span class="keyword">sizeof</span>(dcomplex)*noutx*nouty);
<a name="l00383"></a>00383     <span class="keywordflow">if</span>(fabs(theta)&lt;1.e-10){<span class="comment">//no rotation.</span>
<a name="l00384"></a>00384     <span class="keyword">const</span> <span class="keywordtype">int</span> skipx=(noutx-ninx)/2;
<a name="l00385"></a>00385     <span class="keyword">const</span> <span class="keywordtype">int</span> skipy=(nouty-niny)/2;
<a name="l00386"></a>00386     <span class="keywordtype">int</span> ixstart=0, ixend=ninx;
<a name="l00387"></a>00387     <span class="keywordtype">int</span> iystart=0, iyend=niny;
<a name="l00388"></a>00388     <span class="keywordflow">if</span>(skipx&lt;0){
<a name="l00389"></a>00389         ixstart=-skipx;
<a name="l00390"></a>00390         ixend=ninx+skipx;
<a name="l00391"></a>00391     }
<a name="l00392"></a>00392     <span class="keywordflow">if</span>(skipy&lt;0){
<a name="l00393"></a>00393         iystart=-skipy;
<a name="l00394"></a>00394         iyend=niny+skipy;
<a name="l00395"></a>00395     }
<a name="l00396"></a>00396     dcomplex *restrict out2=out+skipy*noutx+skipx;
<a name="l00397"></a>00397     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=iystart; iy&lt;iyend; iy++){
<a name="l00398"></a>00398         dcomplex *restrict outi=out2+iy*noutx;
<a name="l00399"></a>00399         <span class="keyword">const</span> dcomplex *restrict ini=in+iy*ninx;
<a name="l00400"></a>00400         <span class="keywordflow">switch</span>(flag){<span class="comment">//this switch does not affect speed.</span>
<a name="l00401"></a>00401         <span class="keywordflow">case</span> C_FULL:
<a name="l00402"></a>00402         cmpcpy(outi+ixstart,ini+ixstart,(ixend-ixstart));
<a name="l00403"></a>00403         <span class="keywordflow">break</span>;
<a name="l00404"></a>00404         <span class="keywordflow">case</span> C_ABS2:
<a name="l00405"></a>00405         sq2cpy(outi+ixstart,ini+ixstart,(ixend-ixstart));
<a name="l00406"></a>00406         <span class="keywordflow">break</span>;
<a name="l00407"></a>00407         <span class="keywordflow">case</span> C_REAL:
<a name="l00408"></a>00408         realcpy(outi+ixstart,ini+ixstart,(ixend-ixstart));
<a name="l00409"></a>00409         <span class="keywordflow">break</span>;
<a name="l00410"></a>00410         <span class="keywordflow">case</span> C_ABS:
<a name="l00411"></a>00411         abscpy(outi+ixstart,ini+ixstart,(ixend-ixstart));
<a name="l00412"></a>00412         <span class="keywordflow">break</span>;
<a name="l00413"></a>00413         <span class="keywordflow">case</span> C_LITERAL:<span class="comment">//same as 0.</span>
<a name="l00414"></a>00414         cmpcpy(outi+ixstart,ini+ixstart,(ixend-ixstart));
<a name="l00415"></a>00415         <span class="keywordflow">break</span>;
<a name="l00416"></a>00416         <span class="keywordflow">default</span>:
<a name="l00417"></a>00417         error(<span class="stringliteral">"Invalid flag\n"</span>);
<a name="l00418"></a>00418         }
<a name="l00419"></a>00419     }
<a name="l00420"></a>00420     }<span class="keywordflow">else</span>{
<a name="l00421"></a>00421     <span class="comment">/*</span>
<a name="l00422"></a>00422 <span class="comment">      rotated for LGS.</span>
<a name="l00423"></a>00423 <span class="comment">      rotate image CCW to -theta. coordinate rotate in reverse way.</span>
<a name="l00424"></a>00424 <span class="comment">      xnew=x*cos(theta)-y*sin(theta)</span>
<a name="l00425"></a>00425 <span class="comment">      ynew=x*sin(theta)+y*cos(theta);</span>
<a name="l00426"></a>00426 <span class="comment">      </span>
<a name="l00427"></a>00427 <span class="comment">      The original method of adding in to out is not right.</span>
<a name="l00428"></a>00428 <span class="comment">     */</span>
<a name="l00429"></a>00429     dcomplex (*restrict outs)[noutx]=(dcomplex(*)[noutx])out;
<a name="l00430"></a>00430     dcomplex (*restrict ins)[ninx]=(dcomplex(*)[ninx])in;
<a name="l00431"></a>00431     <span class="keyword">const</span> <span class="keywordtype">double</span> ctheta=cos(theta);
<a name="l00432"></a>00432     <span class="keyword">const</span> <span class="keywordtype">double</span> stheta=sin(theta);
<a name="l00433"></a>00433     <span class="keyword">const</span> <span class="keywordtype">double</span> negstheta=-stheta;
<a name="l00434"></a>00434     <span class="comment">//const double negctheta=-ctheta;</span>
<a name="l00435"></a>00435     <span class="comment">//use long double to reduce accumulation error. but slow. error is on order of 1.e-14 </span>
<a name="l00436"></a>00436     <span class="keywordtype">double</span> x2,y2;
<a name="l00437"></a>00437     <span class="keywordtype">double</span> x4,y4;
<a name="l00438"></a>00438     <span class="keywordtype">double</span> x3,y3,x31;
<a name="l00439"></a>00439     <span class="keywordtype">double</span> noutx2=noutx&gt;&gt;1;
<a name="l00440"></a>00440     <span class="keywordtype">double</span> nouty2=nouty&gt;&gt;1;
<a name="l00441"></a>00441     <span class="keywordtype">int</span> ix2, iy2;
<a name="l00442"></a>00442     
<a name="l00443"></a>00443 <span class="preprocessor">#define DO_LOOP(AFTER,CMD)                      \</span>
<a name="l00444"></a>00444 <span class="preprocessor">    x4=(ninx&gt;&gt;1)-noutx2*ctheta-nouty2*stheta;           \</span>
<a name="l00445"></a>00445 <span class="preprocessor">    y4=(niny&gt;&gt;1)+noutx2*stheta-nouty2*ctheta;           \</span>
<a name="l00446"></a>00446 <span class="preprocessor">    for(int iy=0; iy&lt;nouty; iy++){                  \</span>
<a name="l00447"></a>00447 <span class="preprocessor">        double xbd1=-x4/ctheta; double xbd2=(ninx-1-x4)/ctheta; \</span>
<a name="l00448"></a>00448 <span class="preprocessor">        double ybd1=-y4/negstheta; double ybd2=(ninx-1-y4)/negstheta; \</span>
<a name="l00449"></a>00449 <span class="preprocessor">        if(xbd1&gt;xbd2){double tmp=xbd1; xbd1=xbd2; xbd2=tmp;}    \</span>
<a name="l00450"></a>00450 <span class="preprocessor">        if(ybd1&gt;ybd2){double tmp=ybd1; ybd1=ybd2; ybd2=tmp;}    \</span>
<a name="l00451"></a>00451 <span class="preprocessor">        int sx=iceil(fmax(xbd1,ybd1));              \</span>
<a name="l00452"></a>00452 <span class="preprocessor">        int mx=1+ifloor(fmin(xbd2,ybd2));               \</span>
<a name="l00453"></a>00453 <span class="preprocessor">        sx=sx&gt;0?sx:0; mx=mx&lt;noutx?mx:noutx;             \</span>
<a name="l00454"></a>00454 <span class="preprocessor">        x2=x4+ctheta*sx; y2=y4+negstheta*sx;            \</span>
<a name="l00455"></a>00455 <span class="preprocessor">        for(int ix=sx; ix&lt;mx; ix++){                \</span>
<a name="l00456"></a>00456 <span class="preprocessor">        ix2=ifloor(x2); x3=x2-ix2;x31=1.-x3;            \</span>
<a name="l00457"></a>00457 <span class="preprocessor">        iy2=ifloor(y2); y3=y2-iy2;              \</span>
<a name="l00458"></a>00458 <span class="preprocessor">        outs[iy][ix] =                      \</span>
<a name="l00459"></a>00459 <span class="preprocessor">            AFTER((CMD(ins[iy2][ix2])*(x31)         \</span>
<a name="l00460"></a>00460 <span class="preprocessor">               +CMD(ins[iy2][ix2+1])*x3)*(1.-y3)        \</span>
<a name="l00461"></a>00461 <span class="preprocessor">              +(CMD(ins[iy2+1][ix2])*(x31)          \</span>
<a name="l00462"></a>00462 <span class="preprocessor">                +CMD(ins[iy2+1][ix2+1])*x3)*y3);        \</span>
<a name="l00463"></a>00463 <span class="preprocessor">        x2+=ctheta;                     \</span>
<a name="l00464"></a>00464 <span class="preprocessor">        y2+=negstheta;                      \</span>
<a name="l00465"></a>00465 <span class="preprocessor">        }                               \</span>
<a name="l00466"></a>00466 <span class="preprocessor">        x4+=stheta;                         \</span>
<a name="l00467"></a>00467 <span class="preprocessor">        y4+=ctheta;                         \</span>
<a name="l00468"></a>00468 <span class="preprocessor">    }</span>
<a name="l00469"></a>00469 <span class="preprocessor"></span>    <span class="comment">//it is not good to embed flag in the inner most loop.</span>
<a name="l00470"></a>00470     <span class="keywordflow">switch</span>(flag){
<a name="l00471"></a>00471     <span class="keywordflow">case</span> C_FULL:
<a name="l00472"></a>00472         DO_LOOP(,);
<a name="l00473"></a>00473         <span class="keywordflow">break</span>;
<a name="l00474"></a>00474     <span class="keywordflow">case</span> C_ABS2:
<a name="l00475"></a>00475         DO_LOOP(,cabs2);
<a name="l00476"></a>00476         <span class="keywordflow">break</span>;
<a name="l00477"></a>00477     <span class="keywordflow">case</span> C_REAL:
<a name="l00478"></a>00478         DO_LOOP(,creal);
<a name="l00479"></a>00479         <span class="keywordflow">break</span>;
<a name="l00480"></a>00480     <span class="keywordflow">case</span> C_ABS:
<a name="l00481"></a>00481         DO_LOOP(,cabs);
<a name="l00482"></a>00482         <span class="keywordflow">break</span>;
<a name="l00483"></a>00483     <span class="keywordflow">case</span> C_LITERAL:
<a name="l00484"></a>00484         DO_LOOP(RA2XY,XY2RA);
<a name="l00485"></a>00485         <span class="keywordflow">break</span>;
<a name="l00486"></a>00486     <span class="keywordflow">default</span>:
<a name="l00487"></a>00487         error(<span class="stringliteral">"Invalid flag\n"</span>);
<a name="l00488"></a>00488     }
<a name="l00489"></a>00489 <span class="preprocessor">#undef DO_LOOP</span>
<a name="l00490"></a>00490 <span class="preprocessor"></span>    }
<a name="l00491"></a>00491 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6f86acfdccdc2c5a1c3d02d4ae33ac15"></a><!-- doxytag: member="cmat_extra.c::cembedscaleout" ref="6f86acfdccdc2c5a1c3d02d4ae33ac15" args="(cmat *restrict A, const cmat *B, double xoutscale, double youtscale, const double theta, CEMBED flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cembedscaleout           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>xoutscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>youtscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CEMBED&nbsp;</td>
          <td class="paramname"> <em>flag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
rotate (around fft center: (nx/2,ny/2)) CCW theta and embed in into A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00497"></a>00497                                             {
<a name="l00498"></a>00498     <span class="keywordflow">if</span>(fabs(xoutscale-1)&lt;1.e-10 &amp;&amp; fabs(youtscale-1)&lt;1.e-10){
<a name="l00499"></a>00499     <a class="code" href="cmat__extra_8c.html#772387b5274cd5438d1612a1fd58d8d2" title="Embed array B into A with rotation theta CW.">cembed</a>(A,B,theta,flag);
<a name="l00500"></a>00500     <span class="keywordflow">return</span>;
<a name="l00501"></a>00501     }
<a name="l00502"></a>00502     <span class="keyword">const</span> dcomplex *in=B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00503"></a>00503     <span class="keyword">const</span> <span class="keywordtype">int</span> ninx=B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00504"></a>00504     <span class="keyword">const</span> <span class="keywordtype">int</span> niny=B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00505"></a>00505     dcomplex *out=A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00506"></a>00506     <span class="keyword">const</span> <span class="keywordtype">int</span> noutx=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00507"></a>00507     <span class="keyword">const</span> <span class="keywordtype">int</span> nouty=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00508"></a>00508   
<a name="l00509"></a>00509 
<a name="l00510"></a>00510     dcomplex (*outs)[noutx]=(dcomplex(*)[noutx])out;
<a name="l00511"></a>00511     dcomplex (*ins)[ninx]=(dcomplex(*)[ninx])in;
<a name="l00512"></a>00512     <span class="keyword">const</span> <span class="keywordtype">double</span> ctheta=cos(theta);
<a name="l00513"></a>00513     <span class="keyword">const</span> <span class="keywordtype">double</span> stheta=sin(theta);
<a name="l00514"></a>00514     <span class="keywordtype">double</span> x2,y2;
<a name="l00515"></a>00515     <span class="keywordtype">double</span> x,y;
<a name="l00516"></a>00516     <span class="keywordtype">int</span> ninx2=ninx/2;
<a name="l00517"></a>00517     <span class="keywordtype">int</span> noutx2=noutx/2;
<a name="l00518"></a>00518     <span class="keywordtype">int</span> niny2=niny/2;
<a name="l00519"></a>00519     <span class="keywordtype">int</span> nouty2=nouty/2;
<a name="l00520"></a>00520     <span class="keywordtype">int</span> ix2, iy2;
<a name="l00521"></a>00521 <span class="preprocessor">#define RA2XY(A) (creal(A)*(cos(cimag(A))+I*sin(cimag(A))))</span>
<a name="l00522"></a>00522 <span class="preprocessor"></span><span class="preprocessor">#define XY2RA(A) (cabs(A)+I*atan2(cimag(A),creal(A)))</span>
<a name="l00523"></a>00523 <span class="preprocessor"></span><span class="preprocessor">#define DO_LOOP(AFTER,CMD)                      \</span>
<a name="l00524"></a>00524 <span class="preprocessor">    for(int iy=0; iy&lt;nouty; iy++){                  \</span>
<a name="l00525"></a>00525 <span class="preprocessor">    y=(iy-nouty2)*youtscale;                    \</span>
<a name="l00526"></a>00526 <span class="preprocessor">    for(int ix=0; ix&lt;noutx; ix++){                  \</span>
<a name="l00527"></a>00527 <span class="preprocessor">        x=(ix-noutx2)*xoutscale;                    \</span>
<a name="l00528"></a>00528 <span class="preprocessor">        x2=(x*ctheta+y*stheta+ninx2);               \</span>
<a name="l00529"></a>00529 <span class="preprocessor">        y2=(-x*stheta+y*ctheta+niny2);              \</span>
<a name="l00530"></a>00530 <span class="preprocessor">        if(x2&gt;0 &amp;&amp; x2&lt;ninx-1 &amp;&amp; y2&gt;0 &amp;&amp; y2&lt;niny-1){         \</span>
<a name="l00531"></a>00531 <span class="preprocessor">        ix2=ifloor(x2);                     \</span>
<a name="l00532"></a>00532 <span class="preprocessor">        iy2=ifloor(y2);                     \</span>
<a name="l00533"></a>00533 <span class="preprocessor">        x2=x2-ix2;                      \</span>
<a name="l00534"></a>00534 <span class="preprocessor">        y2=y2-iy2;                      \</span>
<a name="l00535"></a>00535 <span class="preprocessor">        outs[iy][ix] =AFTER(+CMD(ins[iy2][ix2])*((1.-x2)*(1.-y2)) \</span>
<a name="l00536"></a>00536 <span class="preprocessor">                    +CMD(ins[iy2][ix2+1])*(x2*(1.-y2))  \</span>
<a name="l00537"></a>00537 <span class="preprocessor">                    +CMD(ins[iy2+1][ix2])*((1-x2)*y2)   \</span>
<a name="l00538"></a>00538 <span class="preprocessor">                    +CMD(ins[iy2+1][ix2+1])*(x2*y2));   \</span>
<a name="l00539"></a>00539 <span class="preprocessor">        }else outs[iy][ix]=0;                   \</span>
<a name="l00540"></a>00540 <span class="preprocessor">    }                               \</span>
<a name="l00541"></a>00541 <span class="preprocessor">    }</span>
<a name="l00542"></a>00542 <span class="preprocessor"></span>    <span class="comment">//it is not good to embed flag in the inner most loop.</span>
<a name="l00543"></a>00543     <span class="keywordflow">switch</span>(flag){
<a name="l00544"></a>00544     <span class="keywordflow">case</span> C_FULL:
<a name="l00545"></a>00545     DO_LOOP(,);
<a name="l00546"></a>00546     <span class="keywordflow">break</span>;
<a name="l00547"></a>00547     <span class="keywordflow">case</span> C_ABS2:
<a name="l00548"></a>00548     DO_LOOP(,cabs2);
<a name="l00549"></a>00549     <span class="keywordflow">break</span>;
<a name="l00550"></a>00550     <span class="keywordflow">case</span> C_REAL:
<a name="l00551"></a>00551     DO_LOOP(,creal);
<a name="l00552"></a>00552     <span class="keywordflow">break</span>;
<a name="l00553"></a>00553     <span class="keywordflow">case</span> C_ABS:
<a name="l00554"></a>00554     DO_LOOP(,cabs);
<a name="l00555"></a>00555     <span class="keywordflow">break</span>;
<a name="l00556"></a>00556     <span class="keywordflow">case</span> C_LITERAL:
<a name="l00557"></a>00557     DO_LOOP(RA2XY,XY2RA);
<a name="l00558"></a>00558     <span class="keywordflow">break</span>;
<a name="l00559"></a>00559     <span class="keywordflow">default</span>:
<a name="l00560"></a>00560     error(<span class="stringliteral">"Invalid flag\n"</span>);
<a name="l00561"></a>00561     }
<a name="l00562"></a>00562 <span class="preprocessor">#undef DO_LOOP</span>
<a name="l00563"></a>00563 <span class="preprocessor"></span>}
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b5a692d8dd9656bde4d9fe988d26695a"></a><!-- doxytag: member="cmat_extra.c::ccpcorner" ref="b5a692d8dd9656bde4d9fe988d26695a" args="(cmat *A, const cmat *restrict B, CEMBED flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccpcorner           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CEMBED&nbsp;</td>
          <td class="paramname"> <em>flag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy and embed/crop psfin into psfout 
<p>
<div class="fragment"><pre class="fragment">
   4 * * 3
   * * * *
   * * * *
   2 * * 1
   </pre></div> to <div class="fragment"><pre class="fragment">
   4 * * * 3
   * * * * *
   * * * * *
   * * * * *
   2 * * * 1 
   </pre></div> } <div class="fragment"><pre class="fragment"><a name="l00584"></a>00584                                                             {
<a name="l00585"></a>00585     <span class="keyword">const</span> <span class="keywordtype">size_t</span> nx=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00586"></a>00586     <span class="keyword">const</span> <span class="keywordtype">size_t</span> ny=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00587"></a>00587     <span class="keyword">const</span> <span class="keywordtype">size_t</span> ninx=B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00588"></a>00588     <span class="keyword">const</span> <span class="keywordtype">size_t</span> niny=B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00589"></a>00589     dcomplex *psfout=A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00590"></a>00590     <span class="keyword">const</span> dcomplex *restrict psfin=B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00591"></a>00591     assert((nx&amp;1)==0 &amp;&amp; (ny&amp;1)==0 &amp;&amp; (ninx&amp;1)==0 &amp;&amp; (niny&amp;1)==0);
<a name="l00592"></a>00592     memset(psfout, 0, <span class="keyword">sizeof</span>(dcomplex)*nx*ny);
<a name="l00593"></a>00593     <span class="keyword">const</span> <span class="keywordtype">int</span> ny2=(ny&lt;niny)?ny/2:niny/2;
<a name="l00594"></a>00594     <span class="keyword">const</span> <span class="keywordtype">int</span> nx2=(nx&lt;ninx)?nx/2:ninx/2;
<a name="l00595"></a>00595 <span class="preprocessor">#define DO_COPY2(CCMD)                  \</span>
<a name="l00596"></a>00596 <span class="preprocessor">    CCMD(psfout+(ny-ny2+i)*nx+(nx-nx2),     \</span>
<a name="l00597"></a>00597 <span class="preprocessor">         psfin+(niny-ny2+i)*ninx+(ninx-nx2),nx2);   \</span>
<a name="l00598"></a>00598 <span class="preprocessor">    CCMD(psfout+(ny-ny2+i)*nx,          \</span>
<a name="l00599"></a>00599 <span class="preprocessor">         psfin+(niny-ny2+i)*ninx, nx2);     \</span>
<a name="l00600"></a>00600 <span class="preprocessor">    CCMD(psfout+i*nx+(nx-nx2),          \</span>
<a name="l00601"></a>00601 <span class="preprocessor">         psfin+i*ninx+(ninx-nx2), nx2);     \</span>
<a name="l00602"></a>00602 <span class="preprocessor">    CCMD(psfout+i*nx,               \</span>
<a name="l00603"></a>00603 <span class="preprocessor">         psfin+i*ninx, nx2);</span>
<a name="l00604"></a>00604 <span class="preprocessor"></span>    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;ny2; i++){
<a name="l00605"></a>00605     <span class="keywordflow">switch</span>(flag){
<a name="l00606"></a>00606     <span class="keywordflow">case</span> C_FULL:
<a name="l00607"></a>00607         DO_COPY2(cmpcpy);
<a name="l00608"></a>00608         <span class="keywordflow">break</span>;
<a name="l00609"></a>00609     <span class="keywordflow">case</span> C_ABS2:
<a name="l00610"></a>00610         DO_COPY2(sq2cpy);
<a name="l00611"></a>00611         <span class="keywordflow">break</span>;
<a name="l00612"></a>00612     <span class="keywordflow">case</span> C_REAL:
<a name="l00613"></a>00613         DO_COPY2(realcpy);
<a name="l00614"></a>00614         <span class="keywordflow">break</span>;
<a name="l00615"></a>00615     <span class="keywordflow">case</span> C_ABS:
<a name="l00616"></a>00616         DO_COPY2(abscpy);
<a name="l00617"></a>00617         <span class="keywordflow">break</span>;
<a name="l00618"></a>00618     <span class="keywordflow">default</span>:
<a name="l00619"></a>00619         error(<span class="stringliteral">"Invalid flag\n"</span>);
<a name="l00620"></a>00620     }   
<a name="l00621"></a>00621     }
<a name="l00622"></a>00622 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="23f317cbb6e5cad3b80acefd960f7c7f"></a><!-- doxytag: member="cmat_extra.c::cabs2toreal" ref="23f317cbb6e5cad3b80acefd960f7c7f" args="(cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cabs2toreal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Put abs square of each element into its realpart. 
<p>
A=abs(A).^2; <div class="fragment"><pre class="fragment"><a name="l00627"></a>00627                          {
<a name="l00628"></a>00628     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l00629"></a>00629     A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]=cabs2(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]);
<a name="l00630"></a>00630     }
<a name="l00631"></a>00631 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="952faac0b7598955f5d6108d66222707"></a><!-- doxytag: member="cmat_extra.c::cabstoreal" ref="952faac0b7598955f5d6108d66222707" args="(cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cabstoreal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Put abs of each elemnt into its realpart. 
<p>
A=abs(A); <div class="fragment"><pre class="fragment"><a name="l00635"></a>00635                         {
<a name="l00636"></a>00636     <span class="comment">//put abs to real</span>
<a name="l00637"></a>00637     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l00638"></a>00638     A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]=cabs(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]);
<a name="l00639"></a>00639     }
<a name="l00640"></a>00640 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4ff6717c6a0f3919c71a2dc6fde5aae8"></a><!-- doxytag: member="cmat_extra.c::ccpd" ref="4ff6717c6a0f3919c71a2dc6fde5aae8" args="(cmat **restrict A0, const dmat *restrict B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccpd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **restrict&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy a <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> into real part of <a class="el" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a>. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00644"></a>00644                                                     {
<a name="l00645"></a>00645     <a class="code" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a> *restrict A=*A0;
<a name="l00646"></a>00646     <span class="keywordflow">if</span>(!A){
<a name="l00647"></a>00647     *A0=A=<a class="code" href="cmat_8h.html#bb2b86ffc48237c760e652708aaf1415" title="Create a new T matrix object.">cnew</a>(B-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, B-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00648"></a>00648     }<span class="keywordflow">else</span>{
<a name="l00649"></a>00649     assert((A-&gt;nx==B-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> &amp;&amp; A-&gt;ny==B-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>));
<a name="l00650"></a>00650     }
<a name="l00651"></a>00651     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;B-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*B-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; i++){
<a name="l00652"></a>00652     A-&gt;p[i]=B-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i];
<a name="l00653"></a>00653     }
<a name="l00654"></a>00654 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b2baa26f7bd8861ab342eee97889522d"></a><!-- doxytag: member="cmat_extra.c::creal2d" ref="b2baa26f7bd8861ab342eee97889522d" args="(dmat **restrict A0, double alpha, const cmat *restrict B, double beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void creal2d           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **restrict&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy real part of a <a class="el" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a> to <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> with optional scaling: A0=A0. 
<p>
*alpha+real(B)*beta <div class="fragment"><pre class="fragment"><a name="l00660"></a>00660                                              {
<a name="l00661"></a>00661     <a class="code" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> *restrict A=*A0;
<a name="l00662"></a>00662     <span class="keywordflow">if</span>(!A){
<a name="l00663"></a>00663     *A0=A=<a class="code" href="dmat_8h.html#0d7497e2dbb79adb228de6bdde4a201e" title="Create a new T matrix object.">dnew</a>(B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l00664"></a>00664     }<span class="keywordflow">else</span>{
<a name="l00665"></a>00665     assert(A-&gt;nx==B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> &amp;&amp; A-&gt;ny==B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l00666"></a>00666     }
<a name="l00667"></a>00667     <span class="keywordflow">if</span>(fabs(alpha)&lt;EPS){
<a name="l00668"></a>00668     memset(A-&gt;p, 0,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l00669"></a>00669     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l00670"></a>00670         A-&gt;p[i]=creal(B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i])*beta;
<a name="l00671"></a>00671     }
<a name="l00672"></a>00672     }<span class="keywordflow">else</span>{
<a name="l00673"></a>00673     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l00674"></a>00674         A-&gt;p[i]=A-&gt;p[i]*alpha+creal(B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i])*beta;
<a name="l00675"></a>00675     }
<a name="l00676"></a>00676     }
<a name="l00677"></a>00677 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d50c3f29262e58d4032225e69edc892f"></a><!-- doxytag: member="cmat_extra.c::cabs22d" ref="d50c3f29262e58d4032225e69edc892f" args="(dmat **restrict A0, double alpha, const cmat *restrict B, double beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cabs22d           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **restrict&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy abs squared of a <a class="el" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a> to <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> with optional scaling: A0=A0*alpha+abs(B). 
<p>
^2*beta; <div class="fragment"><pre class="fragment"><a name="l00683"></a>00683                                              {
<a name="l00684"></a>00684     <a class="code" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> *restrict A=*A0;
<a name="l00685"></a>00685     <span class="keywordflow">if</span>(!A){
<a name="l00686"></a>00686     *A0=A=<a class="code" href="dmat_8h.html#0d7497e2dbb79adb228de6bdde4a201e" title="Create a new T matrix object.">dnew</a>(B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l00687"></a>00687     }<span class="keywordflow">else</span>{
<a name="l00688"></a>00688     assert(A-&gt;nx==B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> &amp;&amp; A-&gt;ny==B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l00689"></a>00689     }
<a name="l00690"></a>00690     <span class="keywordflow">if</span>(fabs(alpha)&lt;1.e-60){
<a name="l00691"></a>00691     memset(A-&gt;p, 0,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l00692"></a>00692     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l00693"></a>00693         A-&gt;p[i]=cabs2(B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i])*beta;
<a name="l00694"></a>00694     }
<a name="l00695"></a>00695     }<span class="keywordflow">else</span>{
<a name="l00696"></a>00696     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l00697"></a>00697         A-&gt;p[i]=A-&gt;p[i]*alpha+cabs2(B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i])*beta;
<a name="l00698"></a>00698     }
<a name="l00699"></a>00699     }
<a name="l00700"></a>00700 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f912fcd3192a45180c528f075f1d0988"></a><!-- doxytag: member="cmat_extra.c::ctilt" ref="f912fcd3192a45180c528f075f1d0988" args="(cmat *otf, double sx, double sy, int pinct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ctilt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>otf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pinct</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tilt the otf to make the image shift. 
<p>
apply exp(-2*pi*sx/nx)*exp(-2*pi*sy/ny) to otf to move the image sx, sy are shifts in terms of pixel. sx/nx is equivalent to sx*dtheta*du. pinct=1: peak is in center pinct=0: peak is in corner <div class="fragment"><pre class="fragment"><a name="l00710"></a>00710                                                       {
<a name="l00711"></a>00711     <span class="keywordtype">int</span> nx=otf-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00712"></a>00712     <span class="keywordtype">int</span> ny=otf-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00713"></a>00713     <span class="keywordtype">double</span> dux=1./(double)nx;
<a name="l00714"></a>00714     <span class="keywordtype">double</span> duy=1./(double)ny;
<a name="l00715"></a>00715     dcomplex ux[nx], uy[ny];
<a name="l00716"></a>00716     dcomplex cx=cexp(-2*M_PI*I*dux*sx);
<a name="l00717"></a>00717     dcomplex cy=cexp(-2*M_PI*I*duy*sy);
<a name="l00718"></a>00718     <span class="keywordflow">if</span>(pinct==1){<span class="comment">//peak in center</span>
<a name="l00719"></a>00719     ux[0]=cexp(-2*M_PI*I*dux*sx*(-nx/2));
<a name="l00720"></a>00720     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1; i&lt;nx; i++){
<a name="l00721"></a>00721         ux[i]=ux[i-1]*cx;
<a name="l00722"></a>00722     }
<a name="l00723"></a>00723     uy[0]=cexp(-2*M_PI*I*duy*sy*(-ny/2));
<a name="l00724"></a>00724     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1; i&lt;ny; i++){
<a name="l00725"></a>00725         uy[i]=uy[i-1]*cy;
<a name="l00726"></a>00726     }
<a name="l00727"></a>00727     }<span class="keywordflow">else</span>{
<a name="l00728"></a>00728     ux[0]=1;
<a name="l00729"></a>00729     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1; i&lt;nx/2; i++){
<a name="l00730"></a>00730         ux[i]=ux[i-1]*cx;
<a name="l00731"></a>00731     }
<a name="l00732"></a>00732     ux[nx/2]=cexp(-2*M_PI*I*dux*sx*(-nx/2));
<a name="l00733"></a>00733     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=nx/2+1; i&lt;nx; i++){
<a name="l00734"></a>00734         ux[i]=ux[i-1]*cx;
<a name="l00735"></a>00735     }
<a name="l00736"></a>00736     uy[0]=1;
<a name="l00737"></a>00737     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1; i&lt;ny/2; i++){
<a name="l00738"></a>00738         uy[i]=uy[i-1]*cy;
<a name="l00739"></a>00739     }
<a name="l00740"></a>00740     uy[ny/2]=cexp(-2*M_PI*I*duy*sy*(-ny/2));
<a name="l00741"></a>00741     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=ny/2+1; i&lt;ny; i++){
<a name="l00742"></a>00742         uy[i]=uy[i-1]*cy;
<a name="l00743"></a>00743     }
<a name="l00744"></a>00744     }
<a name="l00745"></a>00745     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;ny; iy++){
<a name="l00746"></a>00746     dcomplex *p=otf-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>+iy*nx;
<a name="l00747"></a>00747     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;nx; ix++){
<a name="l00748"></a>00748         p[ix]*=ux[ix]*uy[iy];
<a name="l00749"></a>00749     }
<a name="l00750"></a>00750     }
<a name="l00751"></a>00751 }
</pre></div>
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 29 14:37:09 2010 for maos-0.6.4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
