<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>maos-0.7.5: lib/dsp.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lib/dsp.h File Reference</h1>Contains functions for double sparse <a class="el" href="structdsp.html" title="a sparse array of double numbers stored in compressed column format, i.e.">dsp</a>.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#ad23f2152cd2622871367fd28ac0ff6b">spnew</a> (long nx, long ny, long nzmax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a nx*ny X(sp) matrix with memory for nmax max elements allocated.  <a href="#ad23f2152cd2622871367fd28ac0ff6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#1d8ab659242097d58923075d276a6f91">spref</a> (<a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reference a sparse object.  <a href="#1d8ab659242097d58923075d276a6f91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#0d9b12b1ee8ecdc1e2c138bdf6560faa">spdup</a> (const <a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy a X(sp) matrix to another.  <a href="#0d9b12b1ee8ecdc1e2c138bdf6560faa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#3d1611bee106c350a6c0466a6d6b7781">spmove</a> (<a class="el" href="structdsp.html">dsp</a> *A, <a class="el" href="structdsp.html">dsp</a> *res)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">move the matrix from res to A.  <a href="#3d1611bee106c350a6c0466a6d6b7781"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#0998fd70b78adf3e011d1b6d4d91b2b9">spnew2</a> (const <a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(sp) matrix of the same size as A.  <a href="#0998fd70b78adf3e011d1b6d4d91b2b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#c5b885a1b4079e6c79142b1b8353a9a8">spnewrandu</a> (int nx, int ny, const double mean, double fill, <a class="el" href="structmt__state.html">rand_t</a> *rstat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(sp) matrix and fill in uniform random numbers with filling factor of 'fill'.  <a href="#c5b885a1b4079e6c79142b1b8353a9a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#3e88790d921e0805e21feded80f4b0e2">spsetnzmax</a> (<a class="el" href="structdsp.html">dsp</a> *sp, long nzmax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">resize a X(sp) matrix  <a href="#3e88790d921e0805e21feded80f4b0e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#22ad3b9d1922988ae7d7def3db88f43b">spfree_do</a> (<a class="el" href="structdsp.html">dsp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(sp) matrix  <a href="#22ad3b9d1922988ae7d7def3db88f43b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#c4a9220a4bd635c7027ef27e9cd7b677">sparrfree</a> (<a class="el" href="structdsp.html">dsp</a> **sparr, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(sp) array  <a href="#c4a9220a4bd635c7027ef27e9cd7b677"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#4e4eb16a6ed7e84f8986859963a2e8fc">spdisp</a> (const <a class="el" href="structdsp.html">dsp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display a X(sp) array.  <a href="#4e4eb16a6ed7e84f8986859963a2e8fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#1384dfdc7252ab765fb661fedc8762c6">spcheck</a> (const <a class="el" href="structdsp.html">dsp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check a X(sp) array for wrong orders.  <a href="#1384dfdc7252ab765fb661fedc8762c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#faa3952d0fe7fe67d119e6afadadb39f">spscale</a> (<a class="el" href="structdsp.html">dsp</a> *A, const double beta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace scale X(sp) matrix elements.  <a href="#faa3952d0fe7fe67d119e6afadadb39f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#0ae19ce5e389a9b4a79fb53a675879ca">spcellscale</a> (<a class="el" href="structspcell.html">spcell</a> *A, const double beta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace scale a X(spcell) object  <a href="#0ae19ce5e389a9b4a79fb53a675879ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#6a222ac146078e5f05857a7f93a697bf">spnewdiag</a> (long N, double *vec, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new sparse matrix with diagonal elements set to vec*alpha.  <a href="#6a222ac146078e5f05857a7f93a697bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#4ea42aa0d2d0eace02336cffaa933921">spdiag</a> (const <a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract diagonal element of A and return.  <a href="#4ea42aa0d2d0eace02336cffaa933921"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#86006ab127b4b047f9a78d567be1aae8">spmuldiag</a> (<a class="el" href="structdsp.html">dsp</a> *restrict A, const double *w, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a X(sp) matrix inplace with a diagonal weighting matrix whose diagonal values are stored in w.  <a href="#86006ab127b4b047f9a78d567be1aae8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#0081ae8f4ee8ab199c70e70c97ba6ed6">spmulvec_thread</a> (double *restrict y, const <a class="el" href="structdsp.html">dsp</a> *A, const double *restrict x, double alpha, int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a sparse with a vector using multithread.  <a href="#0081ae8f4ee8ab199c70e70c97ba6ed6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#901d9dc69e7cba48bd4426cb95f9c740">spmulvec</a> (double *restrict y, const <a class="el" href="structdsp.html">dsp</a> *A, const double *restrict x, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sparse matrix multiply with a vector  <a href="#901d9dc69e7cba48bd4426cb95f9c740"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#d14bb136cb7b8eef7ed55c732999f026">spmulcreal</a> (double *restrict y, const <a class="el" href="structdsp.html">dsp</a> *A, const dcomplex *restrict x, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a sparse matrix with the real part of a complex vector.  <a href="#d14bb136cb7b8eef7ed55c732999f026"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#64f8516410a0672044fea7cc929eac7d">sptmulvec</a> (double *restrict y, const <a class="el" href="structdsp.html">dsp</a> *A, const double *restrict x, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply transpose of a sparse matrix with a vector.  <a href="#64f8516410a0672044fea7cc929eac7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#914f0cb44155fa214c1e64283b732f9e">sptmulvec_thread</a> (double *restrict y, const <a class="el" href="structdsp.html">dsp</a> *A, const double *restrict x, const double alpha, int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Threaded version of sptmulvec.  <a href="#914f0cb44155fa214c1e64283b732f9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#4c30a51c7a0d15e4ff0e58bdbc43c932">spmulmat</a> (<a class="el" href="structdmat.html">dmat</a> **yout, const <a class="el" href="structdsp.html">dsp</a> *A, const <a class="el" href="structdmat.html">dmat</a> *x, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a sparse matrix X(sp) with a dense matrix X(mat).  <a href="#4c30a51c7a0d15e4ff0e58bdbc43c932"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#7f7a73c20dd1397db2034e9b39e05bff">sptmulmat</a> (<a class="el" href="structdmat.html">dmat</a> **yout, const <a class="el" href="structdsp.html">dsp</a> *A, const <a class="el" href="structdmat.html">dmat</a> *x, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">y=y+alpha*A'*x;  <a href="#7f7a73c20dd1397db2034e9b39e05bff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#ba76a5d52b2a40a6b36d4d50db0b3ae1">spwdinn</a> (const <a class="el" href="structdmat.html">dmat</a> *y, const <a class="el" href="structdsp.html">dsp</a> *A, const <a class="el" href="structdmat.html">dmat</a> *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two matrices with weighting by sparse matrix.  <a href="#ba76a5d52b2a40a6b36d4d50db0b3ae1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#852ea0920763cd05529ca582b6d4030a">spcellwdinn</a> (const <a class="el" href="structdcell.html">dcell</a> *y, const <a class="el" href="structspcell.html">spcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two cell arrays with weighting by sparse matrix.  <a href="#852ea0920763cd05529ca582b6d4030a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#8d54733ac98a65ca9f99c97713362125">spcellmulmat</a> (<a class="el" href="structdcell.html">dcell</a> **C, const <a class="el" href="structspcell.html">spcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with a dense cell: C=C+A*B*alpha.  <a href="#8d54733ac98a65ca9f99c97713362125"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#730a5070a85111231144cdd535a9f952">sptcellmulmat</a> (<a class="el" href="structdcell.html">dcell</a> **C, const <a class="el" href="structspcell.html">spcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C=C+A'*B*alpha.  <a href="#730a5070a85111231144cdd535a9f952"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#982d5b6a6ebe469d8fc222eab370da9d">spcellmulmat_thread</a> (<a class="el" href="structdcell.html">dcell</a> **C, const <a class="el" href="structspcell.html">spcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B, const double alpha, const int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">threaded version of Y(spcellmulmat)  <a href="#982d5b6a6ebe469d8fc222eab370da9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#22d09bf9b395e05d1fd28865ef4db635">sptcellmulmat_thread</a> (<a class="el" href="structdcell.html">dcell</a> **C, const <a class="el" href="structspcell.html">spcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B, const double alpha, const int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">threaded version of Y(sptcellmulmat  <a href="#22d09bf9b395e05d1fd28865ef4db635"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#9a785d3808177480518763c653593930">spcellmulmat_each</a> (<a class="el" href="structdcell.html">dcell</a> **xout, <a class="el" href="structspcell.html">spcell</a> *A, <a class="el" href="structdcell.html">dcell</a> *xin, double alpha, int trans, int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Threaded multiply each cell in <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with each cell in <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>.  <a href="#9a785d3808177480518763c653593930"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#1f816ec221da7595c0e1b598caaef328">spfull</a> (<a class="el" href="structdmat.html">dmat</a> **out0, const <a class="el" href="structdsp.html">dsp</a> *A, const double f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert sparse matrix into dense matrix and add to output: out0=out0+full(A)*alpha.  <a href="#1f816ec221da7595c0e1b598caaef328"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#f9a447cc8dfb7398a1d9b26b6b905bb4">sptfull</a> (<a class="el" href="structdmat.html">dmat</a> **out0, const <a class="el" href="structdsp.html">dsp</a> *A, const double f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the transpose of a sparse matrix into dense matrix and add to output: out0=out0+full(A')*alpha;.  <a href="#f9a447cc8dfb7398a1d9b26b6b905bb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#515d52002c4c1055b5fd53004b6d7af7">spcellfull</a> (<a class="el" href="structdcell.html">dcell</a> **out0, const <a class="el" href="structspcell.html">spcell</a> *A, const double f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert sparse cell to dense matrix cell: out0=out0+full(A)*alpha.  <a href="#515d52002c4c1055b5fd53004b6d7af7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#8bbbf2bfb30cd998d8584fd4e4cd2f96">sptcellfull</a> (<a class="el" href="structdcell.html">dcell</a> **out0, const <a class="el" href="structspcell.html">spcell</a> *A, const double f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert transpose of sparse cell to dense matrix cell: out0=out0+full(A')*alpha.  <a href="#8bbbf2bfb30cd998d8584fd4e4cd2f96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#a55aa866dc8f53618cdb5ded64643f69">spadd2</a> (<a class="el" href="structdsp.html">dsp</a> *A, <a class="el" href="structdsp.html">dsp</a> *B, double a, double b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Added two sparse matrices: return A*a+B*b.  <a href="#a55aa866dc8f53618cdb5ded64643f69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#55a721406266e38174283509208e78c8">spadd</a> (<a class="el" href="structdsp.html">dsp</a> **A0, const <a class="el" href="structdsp.html">dsp</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a sparse matrix to another: A0=A0+B.  <a href="#55a721406266e38174283509208e78c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#50a4c44bf6e5fdbc087a94fa815ed94a">spcelladd</a> (<a class="el" href="structspcell.html">spcell</a> **A0, const <a class="el" href="structspcell.html">spcell</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a sparse cell to another: A0=A0+B.  <a href="#50a4c44bf6e5fdbc087a94fa815ed94a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#d42323e7141830c2275bd7c5e6d0556c">spaddI</a> (<a class="el" href="structdsp.html">dsp</a> **A0, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add alpha times identity to a sparse matrix.  <a href="#d42323e7141830c2275bd7c5e6d0556c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#e87c19de7800d82f18c211b88943f841">spcelladdI</a> (<a class="el" href="structspcell.html">spcell</a> *A0, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add alpha times identity to sparse array.  <a href="#e87c19de7800d82f18c211b88943f841"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#c8975e7b8152e52b2c8cd8e785c25310">sptrans</a> (const <a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose a sparse array.  <a href="#c8975e7b8152e52b2c8cd8e785c25310"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#ccfcfe9fff4e25824ae3ad516f01b864">spmulsp</a> (const <a class="el" href="structdsp.html">dsp</a> *A, const <a class="el" href="structdsp.html">dsp</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two sparse arrays: return A*B.  <a href="#ccfcfe9fff4e25824ae3ad516f01b864"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#b3929bab7dcd7cf4be34e9e4f7579c90">sptmulsp</a> (const <a class="el" href="structdsp.html">dsp</a> *A, const <a class="el" href="structdsp.html">dsp</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply the transpose of a sparse with another: return A'*B.  <a href="#b3929bab7dcd7cf4be34e9e4f7579c90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#79439ae66ccac26a63d90b0937aa89a6">spmulsp2</a> (<a class="el" href="structdsp.html">dsp</a> **C0, const <a class="el" href="structdsp.html">dsp</a> *A, const <a class="el" href="structdsp.html">dsp</a> *B, const double scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two sparse arrays and add to the third: C0=C0+A*B*scale.  <a href="#79439ae66ccac26a63d90b0937aa89a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#5ba25787c1b6292d42da40d941cea273">spcellmulspcell</a> (const <a class="el" href="structspcell.html">spcell</a> *A, const <a class="el" href="structspcell.html">spcell</a> *B, const double scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two sparse cell.  <a href="#5ba25787c1b6292d42da40d941cea273"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#af5362fa0fc6afc00fc3af29e4fb536d">spcellnew</a> (const long nx, const long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new sparse cell.  <a href="#af5362fa0fc6afc00fc3af29e4fb536d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#a4691afd2563e44ec261422a3648ff01">spcelltrans</a> (const <a class="el" href="structspcell.html">spcell</a> *spc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose a sparse cell.  <a href="#a4691afd2563e44ec261422a3648ff01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#6279b6b982b02b5ed30ba76643e5c989">spcellfree_do</a> (<a class="el" href="structspcell.html">spcell</a> *spc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a sparse cell data.  <a href="#6279b6b982b02b5ed30ba76643e5c989"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#9c43a97ba91966d8bb56640fe0b9cd40">spcat</a> (const <a class="el" href="structdsp.html">dsp</a> *A, const <a class="el" href="structdsp.html">dsp</a> *B, int type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate two sparse array along dim dimension.  <a href="#9c43a97ba91966d8bb56640fe0b9cd40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#5d94fe9f6ba76a7d6b4ea76243e70198">spcell2sp</a> (const <a class="el" href="structspcell.html">spcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> to sparse array.  <a href="#5d94fe9f6ba76a7d6b4ea76243e70198"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#236a93b9ea7b5b6f0a5bbc6373fbb562">spsum</a> (const <a class="el" href="structdsp.html">dsp</a> *A, int col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sum elements of sparse array along dimension dim.  <a href="#236a93b9ea7b5b6f0a5bbc6373fbb562"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#f8f59b688fb6512840f2f87a2e27dd86">spsumabs</a> (const <a class="el" href="structdsp.html">dsp</a> *A, int col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sum abs of elements of sparse array along dimension dim.  <a href="#f8f59b688fb6512840f2f87a2e27dd86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#7ee8766f664c9b29f5a5377347e70360">spclean</a> (<a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clean up a sparse array by dropping zeros.  <a href="#7ee8766f664c9b29f5a5377347e70360"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#e192894e1e52e4bec2fbf06d37565251">spcellmulvec</a> (double *restrict yc, const <a class="el" href="structspcell.html">spcell</a> *Ac, const double *restrict xc, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with vectors.  <a href="#e192894e1e52e4bec2fbf06d37565251"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#0e4197d10a998676c7d7f1ab5e1a6d4a">spdropeps</a> (<a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop elements that are EPS times the largest value.  <a href="#0e4197d10a998676c7d7f1ab5e1a6d4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#86932c91ee953ec4cbfb6ece9f6de414">spcelldropeps</a> (<a class="el" href="structspcell.html">spcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop elements that are EPS times the largest value.  <a href="#86932c91ee953ec4cbfb6ece9f6de414"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#076986e054ddc89e713fba2c7f071911">spsort</a> (<a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make sure the elements are sorted correctly.  <a href="#076986e054ddc89e713fba2c7f071911"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#928b798c235560783e958341fbc1c401">spcellsort</a> (<a class="el" href="structspcell.html">spcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make sure the elements are sorted correctly.  <a href="#928b798c235560783e958341fbc1c401"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#6725c247cbf3d417249b6a7d4ab5159d">spsym</a> (<a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">symmetricize a X(sp) matrix and drop values below a threshold.  <a href="#6725c247cbf3d417249b6a7d4ab5159d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#e575353f52b29ec1c1faec4cc4fa42c4">spcellsym</a> (<a class="el" href="structspcell.html">spcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">symmetricize a X(sp) cell and drop values below a threshold.  <a href="#e575353f52b29ec1c1faec4cc4fa42c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#56681bcd783ee04dcd2b3e74bd56833d">spconvolvop</a> (<a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a X(sp) convolution operator C with C(i,j)=A(i-j); A must be very X(sp) with only a view non-zero value otherwise C will be too full.  <a href="#56681bcd783ee04dcd2b3e74bd56833d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#3338a45fa3da4ef03cd3b7e37e2d0ed8">spperm</a> (<a class="el" href="structdsp.html">dsp</a> *A, int reverse, long *pcol, long *prow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Permute rows and columns of X(sp) matrix A;.  <a href="#3338a45fa3da4ef03cd3b7e37e2d0ed8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#650a5b5e2f5fe7c7a74941d141ccd34b">spinvbdiag</a> (const <a class="el" href="structdsp.html">dsp</a> *A, long bs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invert a SPD X(sp) matrix that is block diagonal with block sizes of bs.  <a href="#650a5b5e2f5fe7c7a74941d141ccd34b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#3e59d81ab1a258a9da09a5a0cb150715">spblockextract</a> (const <a class="el" href="structdsp.html">dsp</a> *A, long bs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extrat the diagonal blocks of size bs into cell arrays.  <a href="#3e59d81ab1a258a9da09a5a0cb150715"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Contains functions for double sparse <a class="el" href="structdsp.html" title="a sparse array of double numbers stored in compressed column format, i.e.">dsp</a>. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ad23f2152cd2622871367fd28ac0ff6b"></a><!-- doxytag: member="dsp.h::spnew" ref="ad23f2152cd2622871367fd28ac0ff6b" args="(long nx, long ny, long nzmax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spnew           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nzmax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a nx*ny X(sp) matrix with memory for nmax max elements allocated. 
<p>

</div>
</div><p>
<a class="anchor" name="1d8ab659242097d58923075d276a6f91"></a><!-- doxytag: member="dsp.h::spref" ref="1d8ab659242097d58923075d276a6f91" args="(dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spref           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reference a sparse object. 
<p>

</div>
</div><p>
<a class="anchor" name="0d9b12b1ee8ecdc1e2c138bdf6560faa"></a><!-- doxytag: member="dsp.h::spdup" ref="0d9b12b1ee8ecdc1e2c138bdf6560faa" args="(const dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spdup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy a X(sp) matrix to another. 
<p>

</div>
</div><p>
<a class="anchor" name="3d1611bee106c350a6c0466a6d6b7781"></a><!-- doxytag: member="dsp.h::spmove" ref="3d1611bee106c350a6c0466a6d6b7781" args="(dsp *A, dsp *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spmove           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
move the matrix from res to A. 
<p>

</div>
</div><p>
<a class="anchor" name="0998fd70b78adf3e011d1b6d4d91b2b9"></a><!-- doxytag: member="dsp.h::spnew2" ref="0998fd70b78adf3e011d1b6d4d91b2b9" args="(const dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spnew2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(sp) matrix of the same size as A. 
<p>

</div>
</div><p>
<a class="anchor" name="c5b885a1b4079e6c79142b1b8353a9a8"></a><!-- doxytag: member="dsp.h::spnewrandu" ref="c5b885a1b4079e6c79142b1b8353a9a8" args="(int nx, int ny, const double mean, double fill, rand_t *rstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spnewrandu           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmt__state.html">rand_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rstat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(sp) matrix and fill in uniform random numbers with filling factor of 'fill'. 
<p>

</div>
</div><p>
<a class="anchor" name="3e88790d921e0805e21feded80f4b0e2"></a><!-- doxytag: member="dsp.h::spsetnzmax" ref="3e88790d921e0805e21feded80f4b0e2" args="(dsp *sp, long nzmax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spsetnzmax           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nzmax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
resize a X(sp) matrix 
<p>

</div>
</div><p>
<a class="anchor" name="22ad3b9d1922988ae7d7def3db88f43b"></a><!-- doxytag: member="dsp.h::spfree_do" ref="22ad3b9d1922988ae7d7def3db88f43b" args="(dsp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(sp) matrix 
<p>

</div>
</div><p>
<a class="anchor" name="c4a9220a4bd635c7027ef27e9cd7b677"></a><!-- doxytag: member="dsp.h::sparrfree" ref="c4a9220a4bd635c7027ef27e9cd7b677" args="(dsp **sparr, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparrfree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> **&nbsp;</td>
          <td class="paramname"> <em>sparr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(sp) array 
<p>

</div>
</div><p>
<a class="anchor" name="4e4eb16a6ed7e84f8986859963a2e8fc"></a><!-- doxytag: member="dsp.h::spdisp" ref="4e4eb16a6ed7e84f8986859963a2e8fc" args="(const dsp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdisp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Display a X(sp) array. 
<p>

</div>
</div><p>
<a class="anchor" name="1384dfdc7252ab765fb661fedc8762c6"></a><!-- doxytag: member="dsp.h::spcheck" ref="1384dfdc7252ab765fb661fedc8762c6" args="(const dsp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcheck           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check a X(sp) array for wrong orders. 
<p>

</div>
</div><p>
<a class="anchor" name="faa3952d0fe7fe67d119e6afadadb39f"></a><!-- doxytag: member="dsp.h::spscale" ref="faa3952d0fe7fe67d119e6afadadb39f" args="(dsp *A, const double beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace scale X(sp) matrix elements. 
<p>

</div>
</div><p>
<a class="anchor" name="0ae19ce5e389a9b4a79fb53a675879ca"></a><!-- doxytag: member="dsp.h::spcellscale" ref="0ae19ce5e389a9b4a79fb53a675879ca" args="(spcell *A, const double beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace scale a X(spcell) object 
<p>

</div>
</div><p>
<a class="anchor" name="6a222ac146078e5f05857a7f93a697bf"></a><!-- doxytag: member="dsp.h::spnewdiag" ref="6a222ac146078e5f05857a7f93a697bf" args="(long N, double *vec, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spnewdiag           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new sparse matrix with diagonal elements set to vec*alpha. 
<p>

</div>
</div><p>
<a class="anchor" name="4ea42aa0d2d0eace02336cffaa933921"></a><!-- doxytag: member="dsp.h::spdiag" ref="4ea42aa0d2d0eace02336cffaa933921" args="(const dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* spdiag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract diagonal element of A and return. 
<p>

</div>
</div><p>
<a class="anchor" name="86006ab127b4b047f9a78d567be1aae8"></a><!-- doxytag: member="dsp.h::spmuldiag" ref="86006ab127b4b047f9a78d567be1aae8" args="(dsp *restrict A, const double *w, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spmuldiag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a X(sp) matrix inplace with a diagonal weighting matrix whose diagonal values are stored in w. 
<p>
W_ii=w_i; W_ij=0 if i!=j A=A*W*alpha; W is a diagonal X(sp) matrix. diag(W) is w multiply w[i] to all numbers in column[i] 
</div>
</div><p>
<a class="anchor" name="0081ae8f4ee8ab199c70e70c97ba6ed6"></a><!-- doxytag: member="dsp.h::spmulvec_thread" ref="0081ae8f4ee8ab199c70e70c97ba6ed6" args="(double *restrict y, const dsp *A, const double *restrict x, double alpha, int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spmulvec_thread           </td>
          <td>(</td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a sparse with a vector using multithread. 
<p>
Speed up is not signicant because need to allocate new memory. 
</div>
</div><p>
<a class="anchor" name="901d9dc69e7cba48bd4426cb95f9c740"></a><!-- doxytag: member="dsp.h::spmulvec" ref="901d9dc69e7cba48bd4426cb95f9c740" args="(double *restrict y, const dsp *A, const double *restrict x, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spmulvec           </td>
          <td>(</td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
sparse matrix multiply with a vector 
<p>

</div>
</div><p>
<a class="anchor" name="d14bb136cb7b8eef7ed55c732999f026"></a><!-- doxytag: member="dsp.h::spmulcreal" ref="d14bb136cb7b8eef7ed55c732999f026" args="(double *restrict y, const dsp *A, const dcomplex *restrict x, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spmulcreal           </td>
          <td>(</td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a sparse matrix with the real part of a complex vector. 
<p>

</div>
</div><p>
<a class="anchor" name="64f8516410a0672044fea7cc929eac7d"></a><!-- doxytag: member="dsp.h::sptmulvec" ref="64f8516410a0672044fea7cc929eac7d" args="(double *restrict y, const dsp *A, const double *restrict x, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptmulvec           </td>
          <td>(</td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply transpose of a sparse matrix with a vector. 
<p>

</div>
</div><p>
<a class="anchor" name="914f0cb44155fa214c1e64283b732f9e"></a><!-- doxytag: member="dsp.h::sptmulvec_thread" ref="914f0cb44155fa214c1e64283b732f9e" args="(double *restrict y, const dsp *A, const double *restrict x, const double alpha, int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptmulvec_thread           </td>
          <td>(</td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Threaded version of sptmulvec. 
<p>

</div>
</div><p>
<a class="anchor" name="4c30a51c7a0d15e4ff0e58bdbc43c932"></a><!-- doxytag: member="dsp.h::spmulmat" ref="4c30a51c7a0d15e4ff0e58bdbc43c932" args="(dmat **yout, const dsp *A, const dmat *x, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a sparse matrix X(sp) with a dense matrix X(mat). 
<p>

</div>
</div><p>
<a class="anchor" name="7f7a73c20dd1397db2034e9b39e05bff"></a><!-- doxytag: member="dsp.h::sptmulmat" ref="7f7a73c20dd1397db2034e9b39e05bff" args="(dmat **yout, const dsp *A, const dmat *x, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
y=y+alpha*A'*x; 
<p>

</div>
</div><p>
<a class="anchor" name="ba76a5d52b2a40a6b36d4d50db0b3ae1"></a><!-- doxytag: member="dsp.h::spwdinn" ref="ba76a5d52b2a40a6b36d4d50db0b3ae1" args="(const dmat *y, const dsp *A, const dmat *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double spwdinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two matrices with weighting by sparse matrix. 
<p>
return y'*(A*x) 
</div>
</div><p>
<a class="anchor" name="852ea0920763cd05529ca582b6d4030a"></a><!-- doxytag: member="dsp.h::spcellwdinn" ref="852ea0920763cd05529ca582b6d4030a" args="(const dcell *y, const spcell *A, const dcell *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double spcellwdinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two cell arrays with weighting by sparse matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="8d54733ac98a65ca9f99c97713362125"></a><!-- doxytag: member="dsp.h::spcellmulmat" ref="8d54733ac98a65ca9f99c97713362125" args="(dcell **C, const spcell *A, const dcell *B, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with a dense cell: C=C+A*B*alpha. 
<p>

</div>
</div><p>
<a class="anchor" name="730a5070a85111231144cdd535a9f952"></a><!-- doxytag: member="dsp.h::sptcellmulmat" ref="730a5070a85111231144cdd535a9f952" args="(dcell **C, const spcell *A, const dcell *B, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptcellmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
C=C+A'*B*alpha. 
<p>

</div>
</div><p>
<a class="anchor" name="982d5b6a6ebe469d8fc222eab370da9d"></a><!-- doxytag: member="dsp.h::spcellmulmat_thread" ref="982d5b6a6ebe469d8fc222eab370da9d" args="(dcell **C, const spcell *A, const dcell *B, const double alpha, const int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellmulmat_thread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
threaded version of Y(spcellmulmat) 
<p>

</div>
</div><p>
<a class="anchor" name="22d09bf9b395e05d1fd28865ef4db635"></a><!-- doxytag: member="dsp.h::sptcellmulmat_thread" ref="22d09bf9b395e05d1fd28865ef4db635" args="(dcell **C, const spcell *A, const dcell *B, const double alpha, const int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptcellmulmat_thread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
threaded version of Y(sptcellmulmat 
<p>

</div>
</div><p>
<a class="anchor" name="9a785d3808177480518763c653593930"></a><!-- doxytag: member="dsp.h::spcellmulmat_each" ref="9a785d3808177480518763c653593930" args="(dcell **xout, spcell *A, dcell *xin, double alpha, int trans, int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellmulmat_each           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>xout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>xin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Threaded multiply each cell in <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with each cell in <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="1f816ec221da7595c0e1b598caaef328"></a><!-- doxytag: member="dsp.h::spfull" ref="1f816ec221da7595c0e1b598caaef328" args="(dmat **out0, const dsp *A, const double f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert sparse matrix into dense matrix and add to output: out0=out0+full(A)*alpha. 
<p>

</div>
</div><p>
<a class="anchor" name="f9a447cc8dfb7398a1d9b26b6b905bb4"></a><!-- doxytag: member="dsp.h::sptfull" ref="f9a447cc8dfb7398a1d9b26b6b905bb4" args="(dmat **out0, const dsp *A, const double f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the transpose of a sparse matrix into dense matrix and add to output: out0=out0+full(A')*alpha;. 
<p>

</div>
</div><p>
<a class="anchor" name="515d52002c4c1055b5fd53004b6d7af7"></a><!-- doxytag: member="dsp.h::spcellfull" ref="515d52002c4c1055b5fd53004b6d7af7" args="(dcell **out0, const spcell *A, const double f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert sparse cell to dense matrix cell: out0=out0+full(A)*alpha. 
<p>

</div>
</div><p>
<a class="anchor" name="8bbbf2bfb30cd998d8584fd4e4cd2f96"></a><!-- doxytag: member="dsp.h::sptcellfull" ref="8bbbf2bfb30cd998d8584fd4e4cd2f96" args="(dcell **out0, const spcell *A, const double f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptcellfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert transpose of sparse cell to dense matrix cell: out0=out0+full(A')*alpha. 
<p>

</div>
</div><p>
<a class="anchor" name="a55aa866dc8f53618cdb5ded64643f69"></a><!-- doxytag: member="dsp.h::spadd2" ref="a55aa866dc8f53618cdb5ded64643f69" args="(dsp *A, dsp *B, double a, double b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spadd2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Added two sparse matrices: return A*a+B*b. 
<p>

</div>
</div><p>
<a class="anchor" name="55a721406266e38174283509208e78c8"></a><!-- doxytag: member="dsp.h::spadd" ref="55a721406266e38174283509208e78c8" args="(dsp **A0, const dsp *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spadd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a sparse matrix to another: A0=A0+B. 
<p>

</div>
</div><p>
<a class="anchor" name="50a4c44bf6e5fdbc087a94fa815ed94a"></a><!-- doxytag: member="dsp.h::spcelladd" ref="50a4c44bf6e5fdbc087a94fa815ed94a" args="(spcell **A0, const spcell *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcelladd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspcell.html">spcell</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a sparse cell to another: A0=A0+B. 
<p>

</div>
</div><p>
<a class="anchor" name="d42323e7141830c2275bd7c5e6d0556c"></a><!-- doxytag: member="dsp.h::spaddI" ref="d42323e7141830c2275bd7c5e6d0556c" args="(dsp **A0, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spaddI           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add alpha times identity to a sparse matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="e87c19de7800d82f18c211b88943f841"></a><!-- doxytag: member="dsp.h::spcelladdI" ref="e87c19de7800d82f18c211b88943f841" args="(spcell *A0, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcelladdI           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add alpha times identity to sparse array. 
<p>

</div>
</div><p>
<a class="anchor" name="c8975e7b8152e52b2c8cd8e785c25310"></a><!-- doxytag: member="dsp.h::sptrans" ref="c8975e7b8152e52b2c8cd8e785c25310" args="(const dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* sptrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transpose a sparse array. 
<p>

</div>
</div><p>
<a class="anchor" name="ccfcfe9fff4e25824ae3ad516f01b864"></a><!-- doxytag: member="dsp.h::spmulsp" ref="ccfcfe9fff4e25824ae3ad516f01b864" args="(const dsp *A, const dsp *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spmulsp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two sparse arrays: return A*B. 
<p>

</div>
</div><p>
<a class="anchor" name="b3929bab7dcd7cf4be34e9e4f7579c90"></a><!-- doxytag: member="dsp.h::sptmulsp" ref="b3929bab7dcd7cf4be34e9e4f7579c90" args="(const dsp *A, const dsp *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* sptmulsp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply the transpose of a sparse with another: return A'*B. 
<p>

</div>
</div><p>
<a class="anchor" name="79439ae66ccac26a63d90b0937aa89a6"></a><!-- doxytag: member="dsp.h::spmulsp2" ref="79439ae66ccac26a63d90b0937aa89a6" args="(dsp **C0, const dsp *A, const dsp *B, const double scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spmulsp2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> **&nbsp;</td>
          <td class="paramname"> <em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two sparse arrays and add to the third: C0=C0+A*B*scale. 
<p>

</div>
</div><p>
<a class="anchor" name="5ba25787c1b6292d42da40d941cea273"></a><!-- doxytag: member="dsp.h::spcellmulspcell" ref="5ba25787c1b6292d42da40d941cea273" args="(const spcell *A, const spcell *B, const double scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspcell.html">spcell</a>* spcellmulspcell           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two sparse cell. 
<p>

</div>
</div><p>
<a class="anchor" name="af5362fa0fc6afc00fc3af29e4fb536d"></a><!-- doxytag: member="dsp.h::spcellnew" ref="af5362fa0fc6afc00fc3af29e4fb536d" args="(const long nx, const long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspcell.html">spcell</a>* spcellnew           </td>
          <td>(</td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new sparse cell. 
<p>

</div>
</div><p>
<a class="anchor" name="a4691afd2563e44ec261422a3648ff01"></a><!-- doxytag: member="dsp.h::spcelltrans" ref="a4691afd2563e44ec261422a3648ff01" args="(const spcell *spc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspcell.html">spcell</a>* spcelltrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>spc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transpose a sparse cell. 
<p>

</div>
</div><p>
<a class="anchor" name="6279b6b982b02b5ed30ba76643e5c989"></a><!-- doxytag: member="dsp.h::spcellfree_do" ref="6279b6b982b02b5ed30ba76643e5c989" args="(spcell *spc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>spc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a sparse cell data. 
<p>

</div>
</div><p>
<a class="anchor" name="9c43a97ba91966d8bb56640fe0b9cd40"></a><!-- doxytag: member="dsp.h::spcat" ref="9c43a97ba91966d8bb56640fe0b9cd40" args="(const dsp *A, const dsp *B, int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spcat           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenate two sparse array along dim dimension. 
<p>

</div>
</div><p>
<a class="anchor" name="5d94fe9f6ba76a7d6b4ea76243e70198"></a><!-- doxytag: member="dsp.h::spcell2sp" ref="5d94fe9f6ba76a7d6b4ea76243e70198" args="(const spcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spcell2sp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenate a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> to sparse array. 
<p>

</div>
</div><p>
<a class="anchor" name="236a93b9ea7b5b6f0a5bbc6373fbb562"></a><!-- doxytag: member="dsp.h::spsum" ref="236a93b9ea7b5b6f0a5bbc6373fbb562" args="(const dsp *A, int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* spsum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sum elements of sparse array along dimension dim. 
<p>

</div>
</div><p>
<a class="anchor" name="f8f59b688fb6512840f2f87a2e27dd86"></a><!-- doxytag: member="dsp.h::spsumabs" ref="f8f59b688fb6512840f2f87a2e27dd86" args="(const dsp *A, int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* spsumabs           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sum abs of elements of sparse array along dimension dim. 
<p>

</div>
</div><p>
<a class="anchor" name="7ee8766f664c9b29f5a5377347e70360"></a><!-- doxytag: member="dsp.h::spclean" ref="7ee8766f664c9b29f5a5377347e70360" args="(dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spclean           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clean up a sparse array by dropping zeros. 
<p>

</div>
</div><p>
<a class="anchor" name="e192894e1e52e4bec2fbf06d37565251"></a><!-- doxytag: member="dsp.h::spcellmulvec" ref="e192894e1e52e4bec2fbf06d37565251" args="(double *restrict yc, const spcell *Ac, const double *restrict xc, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellmulvec           </td>
          <td>(</td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>yc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>Ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *restrict&nbsp;</td>
          <td class="paramname"> <em>xc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with vectors. 
<p>

</div>
</div><p>
<a class="anchor" name="0e4197d10a998676c7d7f1ab5e1a6d4a"></a><!-- doxytag: member="dsp.h::spdropeps" ref="0e4197d10a998676c7d7f1ab5e1a6d4a" args="(dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdropeps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drop elements that are EPS times the largest value. 
<p>

</div>
</div><p>
<a class="anchor" name="86932c91ee953ec4cbfb6ece9f6de414"></a><!-- doxytag: member="dsp.h::spcelldropeps" ref="86932c91ee953ec4cbfb6ece9f6de414" args="(spcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcelldropeps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drop elements that are EPS times the largest value. 
<p>

</div>
</div><p>
<a class="anchor" name="076986e054ddc89e713fba2c7f071911"></a><!-- doxytag: member="dsp.h::spsort" ref="076986e054ddc89e713fba2c7f071911" args="(dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spsort           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make sure the elements are sorted correctly. 
<p>
Does not change the location of data. can be done without harm. 
</div>
</div><p>
<a class="anchor" name="928b798c235560783e958341fbc1c401"></a><!-- doxytag: member="dsp.h::spcellsort" ref="928b798c235560783e958341fbc1c401" args="(spcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellsort           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make sure the elements are sorted correctly. 
<p>

</div>
</div><p>
<a class="anchor" name="6725c247cbf3d417249b6a7d4ab5159d"></a><!-- doxytag: member="dsp.h::spsym" ref="6725c247cbf3d417249b6a7d4ab5159d" args="(dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spsym           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
symmetricize a X(sp) matrix and drop values below a threshold. 
<p>

</div>
</div><p>
<a class="anchor" name="e575353f52b29ec1c1faec4cc4fa42c4"></a><!-- doxytag: member="dsp.h::spcellsym" ref="e575353f52b29ec1c1faec4cc4fa42c4" args="(spcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellsym           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
symmetricize a X(sp) cell and drop values below a threshold. 
<p>

</div>
</div><p>
<a class="anchor" name="56681bcd783ee04dcd2b3e74bd56833d"></a><!-- doxytag: member="dsp.h::spconvolvop" ref="56681bcd783ee04dcd2b3e74bd56833d" args="(dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spconvolvop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a X(sp) convolution operator C with C(i,j)=A(i-j); A must be very X(sp) with only a view non-zero value otherwise C will be too full. 
<p>

</div>
</div><p>
<a class="anchor" name="3338a45fa3da4ef03cd3b7e37e2d0ed8"></a><!-- doxytag: member="dsp.h::spperm" ref="3338a45fa3da4ef03cd3b7e37e2d0ed8" args="(dsp *A, int reverse, long *pcol, long *prow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spperm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>pcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>prow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Permute rows and columns of X(sp) matrix A;. 
<p>

</div>
</div><p>
<a class="anchor" name="650a5b5e2f5fe7c7a74941d141ccd34b"></a><!-- doxytag: member="dsp.h::spinvbdiag" ref="650a5b5e2f5fe7c7a74941d141ccd34b" args="(const dsp *A, long bs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spinvbdiag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>bs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invert a SPD X(sp) matrix that is block diagonal with block sizes of bs. 
<p>

</div>
</div><p>
<a class="anchor" name="3e59d81ab1a258a9da09a5a0cb150715"></a><!-- doxytag: member="dsp.h::spblockextract" ref="3e59d81ab1a258a9da09a5a0cb150715" args="(const dsp *A, long bs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* spblockextract           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>bs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extrat the diagonal blocks of size bs into cell arrays. 
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Nov 24 14:46:54 2010 for maos-0.7.5 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
