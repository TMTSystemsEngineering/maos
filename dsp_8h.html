<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>maos-0.6.1: lib/dsp.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lib/dsp.h File Reference</h1>Contains functions for double sparse <a class="el" href="structdsp.html" title="a sparse array of double numbers stored in compressed column format, i.e.">dsp</a>.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#ad23f2152cd2622871367fd28ac0ff6b">spnew</a> (long nx, long ny, long nzmax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a nx*ny X(sp) matrix with memory for nmax max elements allocated.  <a href="#ad23f2152cd2622871367fd28ac0ff6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#1d8ab659242097d58923075d276a6f91">spref</a> (<a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reference a sparse object.  <a href="#1d8ab659242097d58923075d276a6f91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#0d9b12b1ee8ecdc1e2c138bdf6560faa">spdup</a> (const <a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy a X(sp) matrix to another.  <a href="#0d9b12b1ee8ecdc1e2c138bdf6560faa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#3d1611bee106c350a6c0466a6d6b7781">spmove</a> (<a class="el" href="structdsp.html">dsp</a> *A, <a class="el" href="structdsp.html">dsp</a> *res)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">move the matrix from res to A.  <a href="#3d1611bee106c350a6c0466a6d6b7781"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#0998fd70b78adf3e011d1b6d4d91b2b9">spnew2</a> (const <a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(sp) matrix of the same size as A.  <a href="#0998fd70b78adf3e011d1b6d4d91b2b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#f459bd82a4c718dfcecc01d408516119">spnewrandu</a> (int nx, int ny, const double mean, double fill, <a class="el" href="structmt__state.html">mt_state</a> *rstat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(sp) matrix and fill in uniform random numbers with filling factor of 'fill'.  <a href="#f459bd82a4c718dfcecc01d408516119"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b055b5ac6173aa959bba11b2a820a96"></a><!-- doxytag: member="dsp.h::spshm_ro" ref="3b055b5ac6173aa959bba11b2a820a96" args="(key_t shmkey)" -->
<a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>spshm_ro</b> (key_t shmkey)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="78635036b263dbe1b62bf7d423bacd14"></a><!-- doxytag: member="dsp.h::spshm_rw" ref="78635036b263dbe1b62bf7d423bacd14" args="(key_t shmkey, int m, int n, int nzmax, int type)" -->
<a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>spshm_rw</b> (key_t shmkey, int m, int n, int nzmax, int type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#3e88790d921e0805e21feded80f4b0e2">spsetnzmax</a> (<a class="el" href="structdsp.html">dsp</a> *sp, long nzmax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">resize a X(sp) matrix  <a href="#3e88790d921e0805e21feded80f4b0e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#22ad3b9d1922988ae7d7def3db88f43b">spfree_do</a> (<a class="el" href="structdsp.html">dsp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(sp) matrix  <a href="#22ad3b9d1922988ae7d7def3db88f43b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#c4a9220a4bd635c7027ef27e9cd7b677">sparrfree</a> (<a class="el" href="structdsp.html">dsp</a> **sparr, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(sp) array  <a href="#c4a9220a4bd635c7027ef27e9cd7b677"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#4e4eb16a6ed7e84f8986859963a2e8fc">spdisp</a> (const <a class="el" href="structdsp.html">dsp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display a X(sp) array.  <a href="#4e4eb16a6ed7e84f8986859963a2e8fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#1384dfdc7252ab765fb661fedc8762c6">spcheck</a> (const <a class="el" href="structdsp.html">dsp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check a X(sp) array for wrong orders.  <a href="#1384dfdc7252ab765fb661fedc8762c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#faa3952d0fe7fe67d119e6afadadb39f">spscale</a> (<a class="el" href="structdsp.html">dsp</a> *A, const double beta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace scale X(sp) matrix elements.  <a href="#faa3952d0fe7fe67d119e6afadadb39f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#0ae19ce5e389a9b4a79fb53a675879ca">spcellscale</a> (<a class="el" href="structspcell.html">spcell</a> *A, const double beta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace scale a X(spcell) object  <a href="#0ae19ce5e389a9b4a79fb53a675879ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#6a222ac146078e5f05857a7f93a697bf">spnewdiag</a> (long N, double *vec, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new sparse matrix with diagonal elements set to vec*alpha.  <a href="#6a222ac146078e5f05857a7f93a697bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#4ea42aa0d2d0eace02336cffaa933921">spdiag</a> (const <a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract diagonal element of A and return.  <a href="#4ea42aa0d2d0eace02336cffaa933921"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#86006ab127b4b047f9a78d567be1aae8">spmuldiag</a> (<a class="el" href="structdsp.html">dsp</a> *restrict A, const double *w, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a X(sp) matrix inplace with a diagonal weighting matrix whose diagonal values are stored in w.  <a href="#86006ab127b4b047f9a78d567be1aae8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#0081ae8f4ee8ab199c70e70c97ba6ed6">spmulvec_thread</a> (double *restrict y, const <a class="el" href="structdsp.html">dsp</a> *A, const double *restrict x, double alpha, int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a sparse with a vector using multithread.  <a href="#0081ae8f4ee8ab199c70e70c97ba6ed6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#901d9dc69e7cba48bd4426cb95f9c740">spmulvec</a> (double *restrict y, const <a class="el" href="structdsp.html">dsp</a> *A, const double *restrict x, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sparse matrix multiply with a vector  <a href="#901d9dc69e7cba48bd4426cb95f9c740"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cee30c4488dc9d9771749d17292e49a7"></a><!-- doxytag: member="dsp.h::spmulvec_mkl" ref="cee30c4488dc9d9771749d17292e49a7" args="(double *restrict y, const dsp *A, const double *restrict x, double alpha)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>spmulvec_mkl</b> (double *restrict y, const <a class="el" href="structdsp.html">dsp</a> *A, const double *restrict x, double alpha)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#d14bb136cb7b8eef7ed55c732999f026">spmulcreal</a> (double *restrict y, const <a class="el" href="structdsp.html">dsp</a> *A, const dcomplex *restrict x, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a sparse matrix with the real part of a complex vector.  <a href="#d14bb136cb7b8eef7ed55c732999f026"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#64f8516410a0672044fea7cc929eac7d">sptmulvec</a> (double *restrict y, const <a class="el" href="structdsp.html">dsp</a> *A, const double *restrict x, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply transpose of a sparse matrix with a vector.  <a href="#64f8516410a0672044fea7cc929eac7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#914f0cb44155fa214c1e64283b732f9e">sptmulvec_thread</a> (double *restrict y, const <a class="el" href="structdsp.html">dsp</a> *A, const double *restrict x, const double alpha, int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Threaded version of sptmulvec.  <a href="#914f0cb44155fa214c1e64283b732f9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#4c30a51c7a0d15e4ff0e58bdbc43c932">spmulmat</a> (<a class="el" href="structdmat.html">dmat</a> **yout, const <a class="el" href="structdsp.html">dsp</a> *A, const <a class="el" href="structdmat.html">dmat</a> *x, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a sparse matrix X(sp) with a dense matrix X(mat).  <a href="#4c30a51c7a0d15e4ff0e58bdbc43c932"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#7f7a73c20dd1397db2034e9b39e05bff">sptmulmat</a> (<a class="el" href="structdmat.html">dmat</a> **yout, const <a class="el" href="structdsp.html">dsp</a> *A, const <a class="el" href="structdmat.html">dmat</a> *x, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">y=y+alpha*A'*x;  <a href="#7f7a73c20dd1397db2034e9b39e05bff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#ba76a5d52b2a40a6b36d4d50db0b3ae1">spwdinn</a> (const <a class="el" href="structdmat.html">dmat</a> *y, const <a class="el" href="structdsp.html">dsp</a> *A, const <a class="el" href="structdmat.html">dmat</a> *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two matrices with weighting by sparse matrix.  <a href="#ba76a5d52b2a40a6b36d4d50db0b3ae1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#852ea0920763cd05529ca582b6d4030a">spcellwdinn</a> (const <a class="el" href="structdcell.html">dcell</a> *y, const <a class="el" href="structspcell.html">spcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two cell arrays with weighting by sparse matrix.  <a href="#852ea0920763cd05529ca582b6d4030a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#8d54733ac98a65ca9f99c97713362125">spcellmulmat</a> (<a class="el" href="structdcell.html">dcell</a> **C, const <a class="el" href="structspcell.html">spcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with a dense cell: C=C+A*B*alpha.  <a href="#8d54733ac98a65ca9f99c97713362125"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#730a5070a85111231144cdd535a9f952">sptcellmulmat</a> (<a class="el" href="structdcell.html">dcell</a> **C, const <a class="el" href="structspcell.html">spcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C=C+A'*B*alpha.  <a href="#730a5070a85111231144cdd535a9f952"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#982d5b6a6ebe469d8fc222eab370da9d">spcellmulmat_thread</a> (<a class="el" href="structdcell.html">dcell</a> **C, const <a class="el" href="structspcell.html">spcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B, const double alpha, const int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">threaded version of Y(spcellmulmat)  <a href="#982d5b6a6ebe469d8fc222eab370da9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#22d09bf9b395e05d1fd28865ef4db635">sptcellmulmat_thread</a> (<a class="el" href="structdcell.html">dcell</a> **C, const <a class="el" href="structspcell.html">spcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B, const double alpha, const int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">threaded version of Y(sptcellmulmat  <a href="#22d09bf9b395e05d1fd28865ef4db635"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#1f816ec221da7595c0e1b598caaef328">spfull</a> (<a class="el" href="structdmat.html">dmat</a> **out0, const <a class="el" href="structdsp.html">dsp</a> *A, const double f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert sparse matrix into dense matrix and add to output: out0=out0+full(A)*alpha.  <a href="#1f816ec221da7595c0e1b598caaef328"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#f9a447cc8dfb7398a1d9b26b6b905bb4">sptfull</a> (<a class="el" href="structdmat.html">dmat</a> **out0, const <a class="el" href="structdsp.html">dsp</a> *A, const double f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the transpose of a sparse matrix into dense matrix and add to output: out0=out0+full(A')*alpha;.  <a href="#f9a447cc8dfb7398a1d9b26b6b905bb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#515d52002c4c1055b5fd53004b6d7af7">spcellfull</a> (<a class="el" href="structdcell.html">dcell</a> **out0, const <a class="el" href="structspcell.html">spcell</a> *A, const double f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert sparse cell to dense matrix cell: out0=out0+full(A)*alpha.  <a href="#515d52002c4c1055b5fd53004b6d7af7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#8bbbf2bfb30cd998d8584fd4e4cd2f96">sptcellfull</a> (<a class="el" href="structdcell.html">dcell</a> **out0, const <a class="el" href="structspcell.html">spcell</a> *A, const double f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert transpose of sparse cell to dense matrix cell: out0=out0+full(A')*alpha.  <a href="#8bbbf2bfb30cd998d8584fd4e4cd2f96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#a55aa866dc8f53618cdb5ded64643f69">spadd2</a> (<a class="el" href="structdsp.html">dsp</a> *A, <a class="el" href="structdsp.html">dsp</a> *B, double a, double b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Added two sparse matrices: return A*a+B*b.  <a href="#a55aa866dc8f53618cdb5ded64643f69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#55a721406266e38174283509208e78c8">spadd</a> (<a class="el" href="structdsp.html">dsp</a> **A0, const <a class="el" href="structdsp.html">dsp</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a sparse matrix to another: A0=A0+B.  <a href="#55a721406266e38174283509208e78c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#50a4c44bf6e5fdbc087a94fa815ed94a">spcelladd</a> (<a class="el" href="structspcell.html">spcell</a> **A0, const <a class="el" href="structspcell.html">spcell</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a sparse cell to another: A0=A0+B.  <a href="#50a4c44bf6e5fdbc087a94fa815ed94a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#c8975e7b8152e52b2c8cd8e785c25310">sptrans</a> (const <a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose a sparse array.  <a href="#c8975e7b8152e52b2c8cd8e785c25310"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#ccfcfe9fff4e25824ae3ad516f01b864">spmulsp</a> (const <a class="el" href="structdsp.html">dsp</a> *A, const <a class="el" href="structdsp.html">dsp</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two sparse arrays: return A*B.  <a href="#ccfcfe9fff4e25824ae3ad516f01b864"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#b3929bab7dcd7cf4be34e9e4f7579c90">sptmulsp</a> (const <a class="el" href="structdsp.html">dsp</a> *A, const <a class="el" href="structdsp.html">dsp</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply the transpose of a sparse with another: return A'*B.  <a href="#b3929bab7dcd7cf4be34e9e4f7579c90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#79439ae66ccac26a63d90b0937aa89a6">spmulsp2</a> (<a class="el" href="structdsp.html">dsp</a> **C0, const <a class="el" href="structdsp.html">dsp</a> *A, const <a class="el" href="structdsp.html">dsp</a> *B, const double scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two sparse arrays and add to the third: C0=C0+A*B*scale.  <a href="#79439ae66ccac26a63d90b0937aa89a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#5ba25787c1b6292d42da40d941cea273">spcellmulspcell</a> (const <a class="el" href="structspcell.html">spcell</a> *A, const <a class="el" href="structspcell.html">spcell</a> *B, const double scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two sparse cell.  <a href="#5ba25787c1b6292d42da40d941cea273"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#af5362fa0fc6afc00fc3af29e4fb536d">spcellnew</a> (const long nx, const long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new sparse cell.  <a href="#af5362fa0fc6afc00fc3af29e4fb536d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#a4691afd2563e44ec261422a3648ff01">spcelltrans</a> (const <a class="el" href="structspcell.html">spcell</a> *spc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose a sparse cell.  <a href="#a4691afd2563e44ec261422a3648ff01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#6279b6b982b02b5ed30ba76643e5c989">spcellfree_do</a> (<a class="el" href="structspcell.html">spcell</a> *spc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a sparse cell data.  <a href="#6279b6b982b02b5ed30ba76643e5c989"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#9c43a97ba91966d8bb56640fe0b9cd40">spcat</a> (const <a class="el" href="structdsp.html">dsp</a> *A, const <a class="el" href="structdsp.html">dsp</a> *B, int type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate two sparse array along dim dimension.  <a href="#9c43a97ba91966d8bb56640fe0b9cd40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#5d94fe9f6ba76a7d6b4ea76243e70198">spcell2sp</a> (const <a class="el" href="structspcell.html">spcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> to sparse array.  <a href="#5d94fe9f6ba76a7d6b4ea76243e70198"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#236a93b9ea7b5b6f0a5bbc6373fbb562">spsum</a> (const <a class="el" href="structdsp.html">dsp</a> *A, int col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sum elements of sparse array along dimension dim.  <a href="#236a93b9ea7b5b6f0a5bbc6373fbb562"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#f8f59b688fb6512840f2f87a2e27dd86">spsumabs</a> (const <a class="el" href="structdsp.html">dsp</a> *A, int col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sum abs of elements of sparse array along dimension dim.  <a href="#f8f59b688fb6512840f2f87a2e27dd86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7ee8766f664c9b29f5a5377347e70360"></a><!-- doxytag: member="dsp.h::spclean" ref="7ee8766f664c9b29f5a5377347e70360" args="(dsp *A)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>spclean</b> (<a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#e192894e1e52e4bec2fbf06d37565251">spcellmulvec</a> (double *restrict yc, const <a class="el" href="structspcell.html">spcell</a> *Ac, const double *restrict xc, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with vectors.  <a href="#e192894e1e52e4bec2fbf06d37565251"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#0e4197d10a998676c7d7f1ab5e1a6d4a">spdropeps</a> (<a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop elements that are EPS times the largest value.  <a href="#0e4197d10a998676c7d7f1ab5e1a6d4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#86932c91ee953ec4cbfb6ece9f6de414">spcelldropeps</a> (<a class="el" href="structspcell.html">spcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop elements that are EPS times the largest value.  <a href="#86932c91ee953ec4cbfb6ece9f6de414"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#076986e054ddc89e713fba2c7f071911">spsort</a> (<a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make sure the elements are sorted correctly.  <a href="#076986e054ddc89e713fba2c7f071911"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#928b798c235560783e958341fbc1c401">spcellsort</a> (<a class="el" href="structspcell.html">spcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make sure the elements are sorted correctly.  <a href="#928b798c235560783e958341fbc1c401"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#6725c247cbf3d417249b6a7d4ab5159d">spsym</a> (<a class="el" href="structdsp.html">dsp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">symmetricize a X(sp) matrix and drop values below a threshold.  <a href="#6725c247cbf3d417249b6a7d4ab5159d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#e575353f52b29ec1c1faec4cc4fa42c4">spcellsym</a> (<a class="el" href="structspcell.html">spcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">symmetricize a X(sp) cell and drop values below a threshold.  <a href="#e575353f52b29ec1c1faec4cc4fa42c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#56681bcd783ee04dcd2b3e74bd56833d">spconvolvop</a> (<a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a X(sp) convolution operator C with C(i,j)=A(i-j); A must be very X(sp) with only a view non-zero value otherwise C will be too full.  <a href="#56681bcd783ee04dcd2b3e74bd56833d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#3338a45fa3da4ef03cd3b7e37e2d0ed8">spperm</a> (<a class="el" href="structdsp.html">dsp</a> *A, int reverse, long *pcol, long *prow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Permute rows and columns of X(sp) matrix A;.  <a href="#3338a45fa3da4ef03cd3b7e37e2d0ed8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#650a5b5e2f5fe7c7a74941d141ccd34b">spinvbdiag</a> (const <a class="el" href="structdsp.html">dsp</a> *A, long bs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invert a SPD X(sp) matrix that is block diagonal with block sizes of bs.  <a href="#650a5b5e2f5fe7c7a74941d141ccd34b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp_8h.html#3e59d81ab1a258a9da09a5a0cb150715">spblockextract</a> (const <a class="el" href="structdsp.html">dsp</a> *A, long bs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extrat the diagonal blocks of size bs into cell arrays.  <a href="#3e59d81ab1a258a9da09a5a0cb150715"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Contains functions for double sparse <a class="el" href="structdsp.html" title="a sparse array of double numbers stored in compressed column format, i.e.">dsp</a>. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ad23f2152cd2622871367fd28ac0ff6b"></a><!-- doxytag: member="dsp.h::spnew" ref="ad23f2152cd2622871367fd28ac0ff6b" args="(long nx, long ny, long nzmax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spnew           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nzmax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a nx*ny X(sp) matrix with memory for nmax max elements allocated. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00102"></a>00102                                              {
<a name="l00103"></a>00103 
<a name="l00104"></a>00104     X(sp) *sp;
<a name="l00105"></a>00105     sp = calloc(1, <span class="keyword">sizeof</span>(X(sp)));
<a name="l00106"></a>00106     <span class="keywordflow">if</span>(nzmax&gt;0){
<a name="l00107"></a>00107     sp-&gt;p=malloc((ny+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l00108"></a>00108     sp-&gt;i=malloc(nzmax*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l00109"></a>00109     sp-&gt;x=malloc(nzmax*<span class="keyword">sizeof</span>(T));
<a name="l00110"></a>00110     }
<a name="l00111"></a>00111     sp-&gt;m=nx;
<a name="l00112"></a>00112     sp-&gt;n=ny;
<a name="l00113"></a>00113     sp-&gt;nzmax=nzmax;
<a name="l00114"></a>00114     sp-&gt;nz=-1;
<a name="l00115"></a>00115     sp-&gt;nref=calloc(1,<span class="keyword">sizeof</span>(T));
<a name="l00116"></a>00116     sp-&gt;nref[0]=1;
<a name="l00117"></a>00117     <span class="keywordflow">return</span> sp;
<a name="l00118"></a>00118 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1d8ab659242097d58923075d276a6f91"></a><!-- doxytag: member="dsp.h::spref" ref="1d8ab659242097d58923075d276a6f91" args="(dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spref           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reference a sparse object. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00123"></a>00123                          {
<a name="l00124"></a>00124     X(sp) *out = calloc(1, <span class="keyword">sizeof</span>(X(sp)));
<a name="l00125"></a>00125     <span class="keywordflow">if</span>(!A-&gt;<a class="code" href="structdsp.html#d100457c6ca3e5bd88ee8845cf168a4c" title="reference counting like dmat">nref</a>){
<a name="l00126"></a>00126     A-&gt;<a class="code" href="structdsp.html#d100457c6ca3e5bd88ee8845cf168a4c" title="reference counting like dmat">nref</a>=calloc(1, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l00127"></a>00127     A-&gt;<a class="code" href="structdsp.html#d100457c6ca3e5bd88ee8845cf168a4c" title="reference counting like dmat">nref</a>[0]=1;
<a name="l00128"></a>00128     }
<a name="l00129"></a>00129     memcpy(out,A,<span class="keyword">sizeof</span>(X(sp)));
<a name="l00130"></a>00130     out-&gt;nref[0]++;
<a name="l00131"></a>00131     <span class="keywordflow">return</span> out;
<a name="l00132"></a>00132 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0d9b12b1ee8ecdc1e2c138bdf6560faa"></a><!-- doxytag: member="dsp.h::spdup" ref="0d9b12b1ee8ecdc1e2c138bdf6560faa" args="(const dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spdup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy a X(sp) matrix to another. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00137"></a>00137                                {
<a name="l00138"></a>00138     <span class="keywordtype">long</span> nmax=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>];
<a name="l00139"></a>00139     X(sp) *out;
<a name="l00140"></a>00140     out=Y(spnew)(A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>, A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>, nmax);
<a name="l00141"></a>00141     memcpy(out-&gt;p, A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*(A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>+1));
<a name="l00142"></a>00142     memcpy(out-&gt;i, A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*nmax);
<a name="l00143"></a>00143     memcpy(out-&gt;x, A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>, <span class="keyword">sizeof</span>(T)*nmax);
<a name="l00144"></a>00144     <span class="keywordflow">return</span> out;
<a name="l00145"></a>00145 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3d1611bee106c350a6c0466a6d6b7781"></a><!-- doxytag: member="dsp.h::spmove" ref="3d1611bee106c350a6c0466a6d6b7781" args="(dsp *A, dsp *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spmove           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
move the matrix from res to A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00150"></a>00150                                     {
<a name="l00151"></a>00151     <span class="keywordflow">if</span>(!res || !A) 
<a name="l00152"></a>00152     error(<span class="stringliteral">"Trying to move an NULL matrix\n"</span>);
<a name="l00153"></a>00153     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>){
<a name="l00154"></a>00154     free(A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>); 
<a name="l00155"></a>00155     free(A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>); 
<a name="l00156"></a>00156     free(A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>); 
<a name="l00157"></a>00157     free(A-&gt;<a class="code" href="structdsp.html#d100457c6ca3e5bd88ee8845cf168a4c" title="reference counting like dmat">nref</a>);
<a name="l00158"></a>00158     }
<a name="l00159"></a>00159     memcpy(A,res,<span class="keyword">sizeof</span>(X(sp)));
<a name="l00160"></a>00160     free(res);
<a name="l00161"></a>00161 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0998fd70b78adf3e011d1b6d4d91b2b9"></a><!-- doxytag: member="dsp.h::spnew2" ref="0998fd70b78adf3e011d1b6d4d91b2b9" args="(const dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spnew2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(sp) matrix of the same size as A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00166"></a>00166                                 {
<a name="l00167"></a>00167     <span class="keywordflow">return</span> Y(spnew)(A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>, A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>, A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>]);
<a name="l00168"></a>00168 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f459bd82a4c718dfcecc01d408516119"></a><!-- doxytag: member="dsp.h::spnewrandu" ref="f459bd82a4c718dfcecc01d408516119" args="(int nx, int ny, const double mean, double fill, mt_state *rstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spnewrandu           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmt__state.html">mt_state</a> *&nbsp;</td>
          <td class="paramname"> <em>rstat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(sp) matrix and fill in uniform random numbers with filling factor of 'fill'. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00174"></a>00174                                             {
<a name="l00175"></a>00175     <span class="keywordflow">if</span>(fill&gt;1) fill=1.;
<a name="l00176"></a>00176     <span class="keywordflow">if</span>(fill&lt;0) fill=0.;
<a name="l00177"></a>00177     <span class="keyword">const</span> <span class="keywordtype">long</span> nzmax=nx*ny;
<a name="l00178"></a>00178     <span class="keywordtype">long</span> nz1=nx*ny*fill*4;
<a name="l00179"></a>00179     <span class="keywordflow">if</span>(nz1&gt;nzmax) nz1=nzmax;
<a name="l00180"></a>00180     X(sp) *A=Y(spnew)(nx,ny,nz1);
<a name="l00181"></a>00181     <span class="keywordtype">long</span> *pp=A-&gt;p;
<a name="l00182"></a>00182     <span class="keywordtype">long</span> *pi=A-&gt;i;
<a name="l00183"></a>00183     T *px=A-&gt;x;
<a name="l00184"></a>00184     <span class="keywordtype">long</span> count=0;
<a name="l00185"></a>00185     <span class="keywordtype">double</span> thres=1.-fill;
<a name="l00186"></a>00186     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;n; icol++){
<a name="l00187"></a>00187     pp[icol]=count;
<a name="l00188"></a>00188     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=0; irow&lt;A-&gt;m; irow++){
<a name="l00189"></a>00189         <span class="keywordflow">if</span>(randu(rstat)&gt;thres){
<a name="l00190"></a>00190         pi[count]=irow;
<a name="l00191"></a>00191         px[count]=RANDU(rstat)*mean;
<a name="l00192"></a>00192         count++;
<a name="l00193"></a>00193         <span class="keywordflow">if</span>(count&gt;nz1){
<a name="l00194"></a>00194             <span class="comment">//check out of bound;</span>
<a name="l00195"></a>00195             nz1=nz1*2; <span class="keywordflow">if</span>(nz1&gt;nzmax) nz1=nzmax;
<a name="l00196"></a>00196             Y(spsetnzmax)(A,nz1);
<a name="l00197"></a>00197             <span class="comment">//the pointers may change</span>
<a name="l00198"></a>00198             pp=A-&gt;p;
<a name="l00199"></a>00199             pi=A-&gt;i;
<a name="l00200"></a>00200             px=A-&gt;x;
<a name="l00201"></a>00201         }
<a name="l00202"></a>00202         }
<a name="l00203"></a>00203     }
<a name="l00204"></a>00204     }
<a name="l00205"></a>00205     pp[A-&gt;n]=count;
<a name="l00206"></a>00206     Y(spsetnzmax)(A,count);
<a name="l00207"></a>00207     <span class="keywordflow">return</span> A;
<a name="l00208"></a>00208 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3e88790d921e0805e21feded80f4b0e2"></a><!-- doxytag: member="dsp.h::spsetnzmax" ref="3e88790d921e0805e21feded80f4b0e2" args="(dsp *sp, long nzmax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spsetnzmax           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nzmax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
resize a X(sp) matrix 
<p>
<div class="fragment"><pre class="fragment"><a name="l00213"></a>00213                                          {
<a name="l00214"></a>00214     <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structdsp.html#870a449e24356b8a08ec11a4916be6a0" title="maximum number of entries">nzmax</a>!=nzmax){
<a name="l00215"></a>00215     sp-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>=realloc(sp-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*nzmax);
<a name="l00216"></a>00216     sp-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>=realloc(sp-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>, <span class="keyword">sizeof</span>(T)*nzmax);
<a name="l00217"></a>00217     sp-&gt;<a class="code" href="structdsp.html#870a449e24356b8a08ec11a4916be6a0" title="maximum number of entries">nzmax</a>=nzmax;
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="22ad3b9d1922988ae7d7def3db88f43b"></a><!-- doxytag: member="dsp.h::spfree_do" ref="22ad3b9d1922988ae7d7def3db88f43b" args="(dsp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(sp) matrix 
<p>
<div class="fragment"><pre class="fragment"><a name="l00222"></a>00222                             {
<a name="l00223"></a>00223     <span class="keywordflow">if</span>(!sp) <span class="keywordflow">return</span>;
<a name="l00224"></a>00224     <span class="keywordflow">if</span>(!sp-&gt;<a class="code" href="structdsp.html#d100457c6ca3e5bd88ee8845cf168a4c" title="reference counting like dmat">nref</a> || sp-&gt;<a class="code" href="structdsp.html#d100457c6ca3e5bd88ee8845cf168a4c" title="reference counting like dmat">nref</a>[0]&lt;=1){
<a name="l00225"></a>00225     <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structdsp.html#d100457c6ca3e5bd88ee8845cf168a4c" title="reference counting like dmat">nref</a>[0]!=1){
<a name="l00226"></a>00226         warning(<span class="stringliteral">"nref should nevre be less than 1\n"</span>);
<a name="l00227"></a>00227     }
<a name="l00228"></a>00228     free(sp-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>);
<a name="l00229"></a>00229     free(sp-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>);
<a name="l00230"></a>00230     free(sp-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>);
<a name="l00231"></a>00231     <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structdsp.html#d100457c6ca3e5bd88ee8845cf168a4c" title="reference counting like dmat">nref</a>){
<a name="l00232"></a>00232         free(sp-&gt;<a class="code" href="structdsp.html#d100457c6ca3e5bd88ee8845cf168a4c" title="reference counting like dmat">nref</a>);
<a name="l00233"></a>00233     }<span class="keywordflow">else</span>{
<a name="l00234"></a>00234         warning(<span class="stringliteral">"X(sp) was corrected incorrectly\n"</span>);
<a name="l00235"></a>00235     }
<a name="l00236"></a>00236     }<span class="keywordflow">else</span>{
<a name="l00237"></a>00237     sp-&gt;<a class="code" href="structdsp.html#d100457c6ca3e5bd88ee8845cf168a4c" title="reference counting like dmat">nref</a>[0]--;
<a name="l00238"></a>00238     <span class="comment">//warning("data is retained. nref=%ld\n",sp-&gt;nref[0]);</span>
<a name="l00239"></a>00239     }
<a name="l00240"></a>00240     free(sp);
<a name="l00241"></a>00241 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c4a9220a4bd635c7027ef27e9cd7b677"></a><!-- doxytag: member="dsp.h::sparrfree" ref="c4a9220a4bd635c7027ef27e9cd7b677" args="(dsp **sparr, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparrfree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> **&nbsp;</td>
          <td class="paramname"> <em>sparr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(sp) array 
<p>
<div class="fragment"><pre class="fragment"><a name="l00244"></a>00244                                        {
<a name="l00245"></a>00245     <span class="keywordtype">int</span> i;
<a name="l00246"></a>00246     <span class="keywordflow">if</span>(sparr){
<a name="l00247"></a>00247     <span class="keywordflow">for</span>(i=0; i&lt;n; i++){
<a name="l00248"></a>00248         Y(spfree)(sparr[i]);
<a name="l00249"></a>00249     }
<a name="l00250"></a>00250     free(sparr); 
<a name="l00251"></a>00251     }
<a name="l00252"></a>00252 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4e4eb16a6ed7e84f8986859963a2e8fc"></a><!-- doxytag: member="dsp.h::spdisp" ref="4e4eb16a6ed7e84f8986859963a2e8fc" args="(const dsp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdisp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Display a X(sp) array. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00255"></a>00255                                {
<a name="l00256"></a>00256     <span class="keywordtype">long</span> ic,ir;
<a name="l00257"></a>00257     <span class="keywordtype">long</span> imax;
<a name="l00258"></a>00258     <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structdsp.html#870a449e24356b8a08ec11a4916be6a0" title="maximum number of entries">nzmax</a>==0){
<a name="l00259"></a>00259     info(<span class="stringliteral">"Y(spdisp): All zeros\n"</span>);
<a name="l00260"></a>00260     }<span class="keywordflow">else</span>{
<a name="l00261"></a>00261     info(<span class="stringliteral">"Y(spdisp):\n"</span>);
<a name="l00262"></a>00262     <span class="keywordflow">for</span>(ic=0; ic&lt;sp-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; ic++){
<a name="l00263"></a>00263         imax=-1;
<a name="l00264"></a>00264         <span class="keywordflow">for</span>(ir=sp-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[ic];ir&lt;sp-&gt;p[ic+1];ir++){ 
<a name="l00265"></a>00265 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l00266"></a>00266 <span class="preprocessor"></span>        printf(<span class="stringliteral">"(%ld,%ld)=(%g,%g)\n"</span>, 
<a name="l00267"></a>00267                sp-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ir], ic, creal(sp-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ir]),cimag(sp-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ir]));
<a name="l00268"></a>00268 <span class="preprocessor">#else       </span>
<a name="l00269"></a>00269 <span class="preprocessor"></span>        printf(<span class="stringliteral">"(%ld,%ld)=%g\n"</span>, sp-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ir], ic, sp-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ir]);
<a name="l00270"></a>00270 <span class="preprocessor">#endif</span>
<a name="l00271"></a>00271 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ir]&gt;imax){
<a name="l00272"></a>00272             imax=sp-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ir];
<a name="l00273"></a>00273         }<span class="keywordflow">else</span>{
<a name="l00274"></a>00274             warning(<span class="stringliteral">"Wrong order"</span>);
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276         }
<a name="l00277"></a>00277     }
<a name="l00278"></a>00278     }
<a name="l00279"></a>00279 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1384dfdc7252ab765fb661fedc8762c6"></a><!-- doxytag: member="dsp.h::spcheck" ref="1384dfdc7252ab765fb661fedc8762c6" args="(const dsp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcheck           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check a X(sp) array for wrong orders. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00282"></a>00282                                 {
<a name="l00283"></a>00283     <span class="keywordflow">if</span>(sp){
<a name="l00284"></a>00284     <span class="keywordtype">long</span> ic,ir;
<a name="l00285"></a>00285     <span class="keywordtype">long</span> imax;
<a name="l00286"></a>00286     <span class="keywordflow">for</span>(ic=0; ic&lt;sp-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; ic++){
<a name="l00287"></a>00287         imax=-1;
<a name="l00288"></a>00288         <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[ic+1]&lt;sp-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[ic]){
<a name="l00289"></a>00289         error(<span class="stringliteral">"p in column %ld is smaller than %ld\n"</span>,ic+1,ic);
<a name="l00290"></a>00290         }
<a name="l00291"></a>00291         <span class="keywordflow">for</span>(ir=sp-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[ic];ir&lt;sp-&gt;p[ic+1];ir++){ 
<a name="l00292"></a>00292         <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ir]&gt;imax){
<a name="l00293"></a>00293             imax=sp-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ir];
<a name="l00294"></a>00294         }<span class="keywordflow">else</span>{
<a name="l00295"></a>00295             warning(<span class="stringliteral">"Wrong order at column %ld"</span>,ic);
<a name="l00296"></a>00296         }
<a name="l00297"></a>00297         }
<a name="l00298"></a>00298         <span class="keywordflow">if</span>(imax&gt;=sp-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>){
<a name="l00299"></a>00299         error(<span class="stringliteral">"imax=%ld exceeds column size at column %ld\n"</span>,imax,ic);
<a name="l00300"></a>00300         }
<a name="l00301"></a>00301     }
<a name="l00302"></a>00302     <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[sp-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>]!=sp-&gt;<a class="code" href="structdsp.html#870a449e24356b8a08ec11a4916be6a0" title="maximum number of entries">nzmax</a>){
<a name="l00303"></a>00303         warning(<span class="stringliteral">"real nzmax is %ld, allocated is %ld\n"</span>,sp-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[sp-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>],sp-&gt;<a class="code" href="structdsp.html#870a449e24356b8a08ec11a4916be6a0" title="maximum number of entries">nzmax</a>);
<a name="l00304"></a>00304     }
<a name="l00305"></a>00305     }
<a name="l00306"></a>00306 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="faa3952d0fe7fe67d119e6afadadb39f"></a><!-- doxytag: member="dsp.h::spscale" ref="faa3952d0fe7fe67d119e6afadadb39f" args="(dsp *A, const double beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace scale X(sp) matrix elements. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00309"></a>00309                                        {
<a name="l00310"></a>00310     <span class="keywordflow">if</span>(A){
<a name="l00311"></a>00311     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>]; i++){
<a name="l00312"></a>00312         A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[i]*=beta;
<a name="l00313"></a>00313     }
<a name="l00314"></a>00314     }
<a name="l00315"></a>00315 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0ae19ce5e389a9b4a79fb53a675879ca"></a><!-- doxytag: member="dsp.h::spcellscale" ref="0ae19ce5e389a9b4a79fb53a675879ca" args="(spcell *A, const double beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace scale a X(spcell) object 
<p>
<div class="fragment"><pre class="fragment"><a name="l00318"></a>00318                                                {
<a name="l00319"></a>00319     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>*A-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>; i++){
<a name="l00320"></a>00320     Y(spscale)(A-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>[i],beta);
<a name="l00321"></a>00321     }
<a name="l00322"></a>00322 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6a222ac146078e5f05857a7f93a697bf"></a><!-- doxytag: member="dsp.h::spnewdiag" ref="6a222ac146078e5f05857a7f93a697bf" args="(long N, double *vec, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spnewdiag           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new sparse matrix with diagonal elements set to vec*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00325"></a>00325                                             {
<a name="l00326"></a>00326     X(sp) *out=Y(spnew)(N,N,N);
<a name="l00327"></a>00327     <span class="keywordtype">long</span> *pp=out-&gt;p;
<a name="l00328"></a>00328     <span class="keywordtype">long</span> *pi=out-&gt;i;
<a name="l00329"></a>00329     T *px=out-&gt;x;
<a name="l00330"></a>00330     <span class="keywordtype">long</span> count=0;
<a name="l00331"></a>00331     <span class="keywordflow">if</span>(vec){
<a name="l00332"></a>00332     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;out-&gt;n; icol++){
<a name="l00333"></a>00333         pp[icol]=count;
<a name="l00334"></a>00334         pi[count]=icol;
<a name="l00335"></a>00335         px[count]=vec[icol]*alpha;
<a name="l00336"></a>00336         count++;
<a name="l00337"></a>00337     }
<a name="l00338"></a>00338     }<span class="keywordflow">else</span>{
<a name="l00339"></a>00339     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;out-&gt;n; icol++){
<a name="l00340"></a>00340         pp[icol]=count;
<a name="l00341"></a>00341         pi[count]=icol;
<a name="l00342"></a>00342         px[count]=alpha;
<a name="l00343"></a>00343         count++;
<a name="l00344"></a>00344     }
<a name="l00345"></a>00345     }
<a name="l00346"></a>00346     pp[out-&gt;n]=count;
<a name="l00347"></a>00347     <span class="keywordflow">return</span> out;
<a name="l00348"></a>00348 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4ea42aa0d2d0eace02336cffaa933921"></a><!-- doxytag: member="dsp.h::spdiag" ref="4ea42aa0d2d0eace02336cffaa933921" args="(const dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* spdiag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract diagonal element of A and return. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00352"></a>00352                                  {
<a name="l00353"></a>00353     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>!=A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>){
<a name="l00354"></a>00354     error(<span class="stringliteral">"Only work for square matrix\n"</span>);
<a name="l00355"></a>00355     }
<a name="l00356"></a>00356     X(mat) *out=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>,1);
<a name="l00357"></a>00357     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00358"></a>00358     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l00359"></a>00359         <span class="keywordtype">long</span> row=A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[irow];
<a name="l00360"></a>00360         <span class="keywordflow">if</span>(row==icol){
<a name="l00361"></a>00361         out-&gt;p[icol]=A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[irow];
<a name="l00362"></a>00362         }
<a name="l00363"></a>00363     }
<a name="l00364"></a>00364     }
<a name="l00365"></a>00365     <span class="keywordflow">return</span> out;
<a name="l00366"></a>00366 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="86006ab127b4b047f9a78d567be1aae8"></a><!-- doxytag: member="dsp.h::spmuldiag" ref="86006ab127b4b047f9a78d567be1aae8" args="(dsp *restrict A, const double *w, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spmuldiag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a X(sp) matrix inplace with a diagonal weighting matrix whose diagonal values are stored in w. 
<p>
W_ii=w_i; W_ij=0 if i!=j A=A*W*alpha; W is a diagonal X(sp) matrix. diag(W) is w multiply w[i] to all numbers in column[i] <div class="fragment"><pre class="fragment"><a name="l00375"></a>00375                                                          {
<a name="l00376"></a>00376     <span class="keywordflow">if</span>(A &amp;&amp; w){
<a name="l00377"></a>00377     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00378"></a>00378         <span class="keyword">const</span> T wi=w[icol]*alpha;
<a name="l00379"></a>00379         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00380"></a>00380         A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix]*=wi;
<a name="l00381"></a>00381         }
<a name="l00382"></a>00382     }
<a name="l00383"></a>00383     }
<a name="l00384"></a>00384 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0081ae8f4ee8ab199c70e70c97ba6ed6"></a><!-- doxytag: member="dsp.h::spmulvec_thread" ref="0081ae8f4ee8ab199c70e70c97ba6ed6" args="(double *restrict y, const dsp *A, const double *restrict x, double alpha, int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spmulvec_thread           </td>
          <td>(</td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a sparse with a vector using multithread. 
<p>
Speed up is not signicant because need to allocate new memory. <div class="fragment"><pre class="fragment"><a name="l00434"></a>00434                                                        {
<a name="l00435"></a>00435     <span class="keywordflow">if</span>(!A || !x) <span class="keywordflow">return</span>;    
<a name="l00436"></a>00436     assert(y);
<a name="l00437"></a>00437     <span class="keywordflow">if</span>(nthread&lt;=1){
<a name="l00438"></a>00438     <span class="comment">/* </span>
<a name="l00439"></a>00439 <span class="comment">       When I did the timing, calling spmulvec is twice as slow as calling</span>
<a name="l00440"></a>00440 <span class="comment">       spmulvec directly from the calling routine. I don't understand.</span>
<a name="l00441"></a>00441 <span class="comment">    */</span>
<a name="l00442"></a>00442     <span class="keywordtype">long</span> icol, ix;
<a name="l00443"></a>00443     <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l00444"></a>00444         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00445"></a>00445         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00446"></a>00446             y[A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]]+=A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix]*x[icol];
<a name="l00447"></a>00447         }
<a name="l00448"></a>00448         }
<a name="l00449"></a>00449     }<span class="keywordflow">else</span>{
<a name="l00450"></a>00450         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00451"></a>00451         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00452"></a>00452             y[A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]]+=alpha*A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix]*x[icol];
<a name="l00453"></a>00453         }
<a name="l00454"></a>00454         }
<a name="l00455"></a>00455     }
<a name="l00456"></a>00456     }<span class="keywordflow">else</span>{
<a name="l00457"></a>00457     sp_thread_t data;
<a name="l00458"></a>00458     data.A=A;
<a name="l00459"></a>00459     data.y=y;
<a name="l00460"></a>00460     data.<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>=x;
<a name="l00461"></a>00461     data.alpha=alpha;
<a name="l00462"></a>00462     data.ytmp=calloc(nthread,<span class="keyword">sizeof</span>(T*));
<a name="l00463"></a>00463     data.nthread=nthread;
<a name="l00464"></a>00464     thread_t mul[nthread];
<a name="l00465"></a>00465     thread_t acc[nthread];
<a name="l00466"></a>00466     thread_prep(mul, 0, A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>, 0, nthread, &amp;data);
<a name="l00467"></a>00467     CALL_EACH(Y(spmulvec_thread_do_mul), mul, nthread);
<a name="l00468"></a>00468     thread_prep(acc, 0, A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>, 0, nthread, &amp;data);
<a name="l00469"></a>00469     CALL_EACH(Y(spmulvec_thread_do_acc), acc, nthread);
<a name="l00470"></a>00470     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ithread=0; ithread&lt;nthread; ithread++){
<a name="l00471"></a>00471         free(data.ytmp[ithread]);
<a name="l00472"></a>00472     }
<a name="l00473"></a>00473     free(data.ytmp);
<a name="l00474"></a>00474     }
<a name="l00475"></a>00475 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="901d9dc69e7cba48bd4426cb95f9c740"></a><!-- doxytag: member="dsp.h::spmulvec" ref="901d9dc69e7cba48bd4426cb95f9c740" args="(double *restrict y, const dsp *A, const double *restrict x, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spmulvec           </td>
          <td>(</td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
sparse matrix multiply with a vector 
<p>
<div class="fragment"><pre class="fragment"><a name="l00479"></a>00479                                        {
<a name="l00480"></a>00480     <span class="keywordflow">if</span>(A &amp;&amp; x){
<a name="l00481"></a>00481     <span class="keywordtype">long</span> icol, ix;
<a name="l00482"></a>00482     assert(y);
<a name="l00483"></a>00483     <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l00484"></a>00484         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00485"></a>00485         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00486"></a>00486             y[A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]]+=A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix]*x[icol];
<a name="l00487"></a>00487         }
<a name="l00488"></a>00488         }
<a name="l00489"></a>00489     }<span class="keywordflow">else</span>{
<a name="l00490"></a>00490         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00491"></a>00491         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00492"></a>00492             y[A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]]+=alpha*A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix]*x[icol];
<a name="l00493"></a>00493         }
<a name="l00494"></a>00494         }
<a name="l00495"></a>00495     }
<a name="l00496"></a>00496     }
<a name="l00497"></a>00497 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d14bb136cb7b8eef7ed55c732999f026"></a><!-- doxytag: member="dsp.h::spmulcreal" ref="d14bb136cb7b8eef7ed55c732999f026" args="(double *restrict y, const dsp *A, const dcomplex *restrict x, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spmulcreal           </td>
          <td>(</td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a sparse matrix with the real part of a complex vector. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00586"></a>00586                    {
<a name="l00587"></a>00587     <span class="comment">//y=y+alpha*A*creal(x);</span>
<a name="l00588"></a>00588     <span class="keywordflow">if</span>(A &amp;&amp; x){
<a name="l00589"></a>00589     <span class="keywordtype">long</span> icol, ix;
<a name="l00590"></a>00590     <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l00591"></a>00591         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00592"></a>00592         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00593"></a>00593             y[A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]]+=A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix]*creal(x[icol]);
<a name="l00594"></a>00594         }
<a name="l00595"></a>00595         }
<a name="l00596"></a>00596     }<span class="keywordflow">else</span>{
<a name="l00597"></a>00597         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00598"></a>00598         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00599"></a>00599             y[A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]]+=alpha*A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix]*creal(x[icol]);
<a name="l00600"></a>00600         }
<a name="l00601"></a>00601         }
<a name="l00602"></a>00602     }
<a name="l00603"></a>00603     }
<a name="l00604"></a>00604 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="64f8516410a0672044fea7cc929eac7d"></a><!-- doxytag: member="dsp.h::sptmulvec" ref="64f8516410a0672044fea7cc929eac7d" args="(double *restrict y, const dsp *A, const double *restrict x, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptmulvec           </td>
          <td>(</td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply transpose of a sparse matrix with a vector. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00562"></a>00562                                              {
<a name="l00563"></a>00563     <span class="keywordflow">if</span>(A &amp;&amp; x){
<a name="l00564"></a>00564     <span class="comment">//y=y+alpha*A'*x;</span>
<a name="l00565"></a>00565     assert(y);
<a name="l00566"></a>00566     <span class="keywordtype">long</span> icol, ix;
<a name="l00567"></a>00567     <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l00568"></a>00568         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00569"></a>00569         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00570"></a>00570             y[icol]+=CONJ(A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix])*x[A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]];
<a name="l00571"></a>00571         }
<a name="l00572"></a>00572         }
<a name="l00573"></a>00573     }<span class="keywordflow">else</span>{
<a name="l00574"></a>00574         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00575"></a>00575         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00576"></a>00576             y[icol]+=alpha*CONJ(A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix])*x[A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]];
<a name="l00577"></a>00577         }
<a name="l00578"></a>00578         }
<a name="l00579"></a>00579     }
<a name="l00580"></a>00580     }
<a name="l00581"></a>00581 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="914f0cb44155fa214c1e64283b732f9e"></a><!-- doxytag: member="dsp.h::sptmulvec_thread" ref="914f0cb44155fa214c1e64283b732f9e" args="(double *restrict y, const dsp *A, const double *restrict x, const double alpha, int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptmulvec_thread           </td>
          <td>(</td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Threaded version of sptmulvec. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00527"></a>00527                                                              {
<a name="l00528"></a>00528     tic;
<a name="l00529"></a>00529     <span class="keywordflow">if</span>(!A || !x) <span class="keywordflow">return</span>;
<a name="l00530"></a>00530     assert(y);
<a name="l00531"></a>00531     <span class="keywordflow">if</span>(nthread&lt;=1){
<a name="l00532"></a>00532     <span class="keywordtype">long</span> icol, ix;
<a name="l00533"></a>00533     <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l00534"></a>00534         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00535"></a>00535         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00536"></a>00536             y[icol]+=CONJ(A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix])*x[A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]];
<a name="l00537"></a>00537         }
<a name="l00538"></a>00538         }
<a name="l00539"></a>00539     }<span class="keywordflow">else</span>{
<a name="l00540"></a>00540         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00541"></a>00541         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00542"></a>00542             y[icol]+=alpha*CONJ(A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix])*x[A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]];
<a name="l00543"></a>00543         }
<a name="l00544"></a>00544         }
<a name="l00545"></a>00545     }
<a name="l00546"></a>00546     }<span class="keywordflow">else</span>{
<a name="l00547"></a>00547     sp_thread_t data;
<a name="l00548"></a>00548     data.A=A;
<a name="l00549"></a>00549     data.y=y;
<a name="l00550"></a>00550     data.<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>=x;
<a name="l00551"></a>00551     data.alpha=alpha;
<a name="l00552"></a>00552     data.nthread=nthread;
<a name="l00553"></a>00553     thread_t mul[nthread];
<a name="l00554"></a>00554     thread_prep(mul, 0, A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>, 0, nthread, &amp;data);<span class="comment">//interlaced is not good.</span>
<a name="l00555"></a>00555     toc(<span class="stringliteral">"prep"</span>);
<a name="l00556"></a>00556     CALL_EACH(Y(sptmulvec_thread_do), mul, nthread);
<a name="l00557"></a>00557     }
<a name="l00558"></a>00558 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4c30a51c7a0d15e4ff0e58bdbc43c932"></a><!-- doxytag: member="dsp.h::spmulmat" ref="4c30a51c7a0d15e4ff0e58bdbc43c932" args="(dmat **yout, const dsp *A, const dmat *x, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a sparse matrix X(sp) with a dense matrix X(mat). 
<p>
<div class="fragment"><pre class="fragment"><a name="l00609"></a>00609                        {
<a name="l00610"></a>00610     <span class="keywordflow">if</span>(A&amp;&amp;x){
<a name="l00611"></a>00611     <span class="comment">// y=y+alpha*A*x;</span>
<a name="l00612"></a>00612     <span class="keywordtype">long</span> icol, ix;
<a name="l00613"></a>00613     <span class="keywordflow">if</span>(!*yout){
<a name="l00614"></a>00614         *yout=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>, x-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>); 
<a name="l00615"></a>00615     }
<a name="l00616"></a>00616     X(mat) *y=*yout;
<a name="l00617"></a>00617     assert(x-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==y-&gt;ny);
<a name="l00618"></a>00618     assert(A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>==x-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>);
<a name="l00619"></a>00619     <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1){
<a name="l00620"></a>00620         Y(spmulvec)(y-&gt;p, A, x-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>,  alpha);
<a name="l00621"></a>00621     }<span class="keywordflow">else</span>{
<a name="l00622"></a>00622         <span class="keywordtype">int</span> jcol;
<a name="l00623"></a>00623         T (* restrict Y)[y-&gt;nx]=(T(*)[y-&gt;nx])y-&gt;p;
<a name="l00624"></a>00624         T (* restrict X)[x-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>]=(T(*)[x-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>])x-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00625"></a>00625         <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l00626"></a>00626         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00627"></a>00627             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00628"></a>00628             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;ny; jcol++){
<a name="l00629"></a>00629                 Y[jcol][A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]]+=A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix]*X[jcol][icol];
<a name="l00630"></a>00630             }
<a name="l00631"></a>00631             }
<a name="l00632"></a>00632         }
<a name="l00633"></a>00633         }<span class="keywordflow">else</span>{
<a name="l00634"></a>00634         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00635"></a>00635             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00636"></a>00636             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;ny; jcol++){
<a name="l00637"></a>00637                 Y[jcol][A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]]+=alpha*A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix]*X[jcol][icol];
<a name="l00638"></a>00638             }
<a name="l00639"></a>00639             }
<a name="l00640"></a>00640         }
<a name="l00641"></a>00641         }
<a name="l00642"></a>00642     }
<a name="l00643"></a>00643     }
<a name="l00644"></a>00644 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7f7a73c20dd1397db2034e9b39e05bff"></a><!-- doxytag: member="dsp.h::sptmulmat" ref="7f7a73c20dd1397db2034e9b39e05bff" args="(dmat **yout, const dsp *A, const dmat *x, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
y=y+alpha*A'*x; 
<p>
<div class="fragment"><pre class="fragment"><a name="l00648"></a>00648                                                                                 {
<a name="l00649"></a>00649     <span class="keywordflow">if</span>(A&amp;&amp;x){
<a name="l00650"></a>00650     <span class="keywordtype">long</span> icol, ix;
<a name="l00651"></a>00651     <span class="keywordflow">if</span>(!*yout){
<a name="l00652"></a>00652         *yout=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>, x-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00653"></a>00653     }
<a name="l00654"></a>00654     X(mat) *y=*yout;
<a name="l00655"></a>00655     assert(x-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==y-&gt;ny);
<a name="l00656"></a>00656     assert(A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>==y-&gt;nx);
<a name="l00657"></a>00657     <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1){
<a name="l00658"></a>00658         Y(sptmulvec)(y-&gt;p, A, x-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>, alpha);
<a name="l00659"></a>00659     }<span class="keywordflow">else</span>{
<a name="l00660"></a>00660         <span class="keywordtype">int</span> jcol;
<a name="l00661"></a>00661         PMAT(x,X);
<a name="l00662"></a>00662         PMAT(y,Y);
<a name="l00663"></a>00663         <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l00664"></a>00664         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00665"></a>00665             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00666"></a>00666             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;ny; jcol++){
<a name="l00667"></a>00667                 Y[jcol][icol]+=CONJ(A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix])*X[jcol][A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]];
<a name="l00668"></a>00668             }
<a name="l00669"></a>00669             }
<a name="l00670"></a>00670         }
<a name="l00671"></a>00671         }<span class="keywordflow">else</span>{
<a name="l00672"></a>00672         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00673"></a>00673             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00674"></a>00674             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;ny; jcol++){
<a name="l00675"></a>00675                 Y[jcol][icol]+=alpha*CONJ(A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix])*X[jcol][A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]];
<a name="l00676"></a>00676             }
<a name="l00677"></a>00677             }
<a name="l00678"></a>00678         }
<a name="l00679"></a>00679         }
<a name="l00680"></a>00680     }
<a name="l00681"></a>00681     }
<a name="l00682"></a>00682 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ba76a5d52b2a40a6b36d4d50db0b3ae1"></a><!-- doxytag: member="dsp.h::spwdinn" ref="ba76a5d52b2a40a6b36d4d50db0b3ae1" args="(const dmat *y, const dsp *A, const dmat *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double spwdinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two matrices with weighting by sparse matrix. 
<p>
return y'*(A*x) <div class="fragment"><pre class="fragment"><a name="l00685"></a>00685                                                               {
<a name="l00686"></a>00686     <span class="comment">//X(sp) weighted ddot.</span>
<a name="l00687"></a>00687     <span class="comment">//computes y'*(A*x). x,y are vectors</span>
<a name="l00688"></a>00688     T res=0;
<a name="l00689"></a>00689     <span class="keywordflow">if</span>(x &amp;&amp; y){
<a name="l00690"></a>00690     <span class="keywordflow">if</span>(A){
<a name="l00691"></a>00691         assert(x-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1 &amp;&amp; y-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1 &amp;&amp; A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>==y-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> &amp;&amp; A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>==x-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>);
<a name="l00692"></a>00692         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00693"></a>00693         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00694"></a>00694             res+=y-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]]*A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix]*x-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[icol];
<a name="l00695"></a>00695         }
<a name="l00696"></a>00696         }
<a name="l00697"></a>00697     }<span class="keywordflow">else</span>{
<a name="l00698"></a>00698         res=X(inn)(x,y);
<a name="l00699"></a>00699     }
<a name="l00700"></a>00700     }
<a name="l00701"></a>00701     <span class="keywordflow">return</span> res;
<a name="l00702"></a>00702 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="852ea0920763cd05529ca582b6d4030a"></a><!-- doxytag: member="dsp.h::spcellwdinn" ref="852ea0920763cd05529ca582b6d4030a" args="(const dcell *y, const spcell *A, const dcell *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double spcellwdinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two cell arrays with weighting by sparse matrix. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00705"></a>00705                                                                         {
<a name="l00706"></a>00706     <span class="comment">//computes y'*(A*x)</span>
<a name="l00707"></a>00707     T res=0;
<a name="l00708"></a>00708     <span class="keywordflow">if</span>(x &amp;&amp; y){
<a name="l00709"></a>00709     <span class="keywordflow">if</span>(A){
<a name="l00710"></a>00710         assert(x-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>==1 &amp;&amp; y-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>==1 &amp;&amp; A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>==y-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a> &amp;&amp; A-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>==x-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>);
<a name="l00711"></a>00711         X(sp) *(*Ap)[A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>]=(X(sp) *(*)[A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>])A-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>;
<a name="l00712"></a>00712         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;ny; iy++){
<a name="l00713"></a>00713         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>; ix++){
<a name="l00714"></a>00714             res+=Y(spwdinn)(y-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[ix], Ap[iy][ix], x-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[iy]);
<a name="l00715"></a>00715         }
<a name="l00716"></a>00716         }
<a name="l00717"></a>00717     }<span class="keywordflow">else</span>{
<a name="l00718"></a>00718         res = X(cellinn)(x,y);
<a name="l00719"></a>00719     }
<a name="l00720"></a>00720     }
<a name="l00721"></a>00721     <span class="keywordflow">return</span> res;
<a name="l00722"></a>00722 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8d54733ac98a65ca9f99c97713362125"></a><!-- doxytag: member="dsp.h::spcellmulmat" ref="8d54733ac98a65ca9f99c97713362125" args="(dcell **C, const spcell *A, const dcell *B, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with a dense cell: C=C+A*B*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00762"></a>00762                                                                                     {
<a name="l00763"></a>00763     <span class="keywordflow">return</span> Y(spcellmulmat2)(C,A,B,alpha,0);
<a name="l00764"></a>00764 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="730a5070a85111231144cdd535a9f952"></a><!-- doxytag: member="dsp.h::sptcellmulmat" ref="730a5070a85111231144cdd535a9f952" args="(dcell **C, const spcell *A, const dcell *B, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptcellmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
C=C+A'*B*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00767"></a>00767                                                                                      {
<a name="l00768"></a>00768     <span class="keywordflow">return</span> Y(spcellmulmat2)(C,A,B,alpha,1);
<a name="l00769"></a>00769 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="982d5b6a6ebe469d8fc222eab370da9d"></a><!-- doxytag: member="dsp.h::spcellmulmat_thread" ref="982d5b6a6ebe469d8fc222eab370da9d" args="(dcell **C, const spcell *A, const dcell *B, const double alpha, const int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellmulmat_thread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
threaded version of Y(spcellmulmat) 
<p>
<div class="fragment"><pre class="fragment"><a name="l00830"></a>00830                                   {
<a name="l00831"></a>00831     Y(spcellmulmat_thread2)(C,A,B,alpha,0,nthread);
<a name="l00832"></a>00832 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="22d09bf9b395e05d1fd28865ef4db635"></a><!-- doxytag: member="dsp.h::sptcellmulmat_thread" ref="22d09bf9b395e05d1fd28865ef4db635" args="(dcell **C, const spcell *A, const dcell *B, const double alpha, const int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptcellmulmat_thread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
threaded version of Y(sptcellmulmat 
<p>
<div class="fragment"><pre class="fragment"><a name="l00837"></a>00837                                    {
<a name="l00838"></a>00838     Y(spcellmulmat_thread2)(C,A,B,alpha,1,nthread);
<a name="l00839"></a>00839 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1f816ec221da7595c0e1b598caaef328"></a><!-- doxytag: member="dsp.h::spfull" ref="1f816ec221da7595c0e1b598caaef328" args="(dmat **out0, const dsp *A, const double f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert sparse matrix into dense matrix and add to output: out0=out0+full(A)*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00843"></a>00843                                                             {
<a name="l00844"></a>00844     <span class="keywordflow">if</span>(!A)
<a name="l00845"></a>00845     <span class="keywordflow">return</span>;<span class="comment"></span>
<a name="l00846"></a>00846 <span class="comment">    /**</span>
<a name="l00847"></a>00847 <span class="comment">       add A*f to dense matrix located in p;</span>
<a name="l00848"></a>00848 <span class="comment">    */</span>
<a name="l00849"></a>00849     <span class="keywordtype">long</span> nx=A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>;
<a name="l00850"></a>00850     <span class="keywordtype">long</span> icol,ix,irow;
<a name="l00851"></a>00851     <span class="keywordflow">if</span>(!*out0){
<a name="l00852"></a>00852     *out0=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>, A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>);
<a name="l00853"></a>00853     }
<a name="l00854"></a>00854     X(mat) *out=*out0;
<a name="l00855"></a>00855     assert(out-&gt;nx==A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a> &amp;&amp; out-&gt;ny==A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>);
<a name="l00856"></a>00856     PMAT(out,pp);
<a name="l00857"></a>00857     <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00858"></a>00858     <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00859"></a>00859         irow=A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix];
<a name="l00860"></a>00860         <span class="keywordflow">if</span>(irow&gt;=nx)
<a name="l00861"></a>00861         error(<span class="stringliteral">"invalid row:%ld, %ld"</span>,irow,nx);
<a name="l00862"></a>00862         pp[icol][irow]+=alpha*A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix];
<a name="l00863"></a>00863     }
<a name="l00864"></a>00864     }
<a name="l00865"></a>00865 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f9a447cc8dfb7398a1d9b26b6b905bb4"></a><!-- doxytag: member="dsp.h::sptfull" ref="f9a447cc8dfb7398a1d9b26b6b905bb4" args="(dmat **out0, const dsp *A, const double f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the transpose of a sparse matrix into dense matrix and add to output: out0=out0+full(A')*alpha;. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00869"></a>00869                                                              {
<a name="l00870"></a>00870     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;<span class="comment"></span>
<a name="l00871"></a>00871 <span class="comment">    /**</span>
<a name="l00872"></a>00872 <span class="comment">       add A*f to dense matrix located in p;</span>
<a name="l00873"></a>00873 <span class="comment">    */</span>
<a name="l00874"></a>00874     <span class="keywordtype">long</span> nx=A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>;
<a name="l00875"></a>00875     <span class="keywordtype">long</span> icol,ix,irow;
<a name="l00876"></a>00876     <span class="keywordflow">if</span>(!*out0){
<a name="l00877"></a>00877     *out0=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>, A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>);
<a name="l00878"></a>00878     }
<a name="l00879"></a>00879     X(mat) *out=*out0;
<a name="l00880"></a>00880     assert(out-&gt;nx==A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a> &amp;&amp; out-&gt;ny==A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>);
<a name="l00881"></a>00881     PMAT(out,pp);
<a name="l00882"></a>00882     <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l00883"></a>00883     <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l00884"></a>00884         irow=A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix];
<a name="l00885"></a>00885         <span class="keywordflow">if</span>(irow&gt;=nx)
<a name="l00886"></a>00886         error(<span class="stringliteral">"invalid row:%ld, %ld"</span>,irow,nx);
<a name="l00887"></a>00887         pp[irow][icol]+=alpha*A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix];
<a name="l00888"></a>00888     }
<a name="l00889"></a>00889     }
<a name="l00890"></a>00890 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="515d52002c4c1055b5fd53004b6d7af7"></a><!-- doxytag: member="dsp.h::spcellfull" ref="515d52002c4c1055b5fd53004b6d7af7" args="(dcell **out0, const spcell *A, const double f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert sparse cell to dense matrix cell: out0=out0+full(A)*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00893"></a>00893                                                                      {
<a name="l00894"></a>00894     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00895"></a>00895     X(cell) *out=*out0;
<a name="l00896"></a>00896     <span class="keywordflow">if</span>(!out){
<a name="l00897"></a>00897     out=*out0=X(cellnew)(A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>, A-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>);
<a name="l00898"></a>00898     }<span class="keywordflow">else</span>{
<a name="l00899"></a>00899     assert(out-&gt;nx==A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a> &amp;&amp; out-&gt;ny==A-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>);
<a name="l00900"></a>00900     }
<a name="l00901"></a>00901     PSPCELL(A,pA);
<a name="l00902"></a>00902     PXCELL(out,pout);
<a name="l00903"></a>00903     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>; iy++){
<a name="l00904"></a>00904     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>; ix++){
<a name="l00905"></a>00905         Y(spfull)(&amp;pout[iy][ix], pA[iy][ix], alpha);
<a name="l00906"></a>00906     }
<a name="l00907"></a>00907     }
<a name="l00908"></a>00908 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8bbbf2bfb30cd998d8584fd4e4cd2f96"></a><!-- doxytag: member="dsp.h::sptcellfull" ref="8bbbf2bfb30cd998d8584fd4e4cd2f96" args="(dcell **out0, const spcell *A, const double f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sptcellfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert transpose of sparse cell to dense matrix cell: out0=out0+full(A')*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00911"></a>00911                                                                       {
<a name="l00912"></a>00912     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00913"></a>00913     X(cell) *out=*out0;
<a name="l00914"></a>00914     <span class="keywordflow">if</span>(!out){
<a name="l00915"></a>00915     out=*out0=X(cellnew)(A-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>, A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>);
<a name="l00916"></a>00916     }<span class="keywordflow">else</span>{
<a name="l00917"></a>00917     assert(out-&gt;nx==A-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a> &amp;&amp; out-&gt;ny==A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>);
<a name="l00918"></a>00918     }
<a name="l00919"></a>00919     PSPCELL(A,pA);
<a name="l00920"></a>00920     PXCELL(out, pout);
<a name="l00921"></a>00921     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>; iy++){
<a name="l00922"></a>00922     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>; ix++){
<a name="l00923"></a>00923         Y(spfull)(&amp;pout[ix][iy], pA[iy][ix], alpha);
<a name="l00924"></a>00924     }
<a name="l00925"></a>00925     } 
<a name="l00926"></a>00926 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a55aa866dc8f53618cdb5ded64643f69"></a><!-- doxytag: member="dsp.h::spadd2" ref="a55aa866dc8f53618cdb5ded64643f69" args="(dsp *A, dsp *B, double a, double b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spadd2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Added two sparse matrices: return A*a+B*b. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00929"></a>00929                                           {
<a name="l00930"></a>00930     X(sp) *C=Y(cs_add)(A,B,a,b);
<a name="l00931"></a>00931     Y(cs_dropzeros)(C);
<a name="l00932"></a>00932     <span class="keywordflow">return</span> C;
<a name="l00933"></a>00933 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="55a721406266e38174283509208e78c8"></a><!-- doxytag: member="dsp.h::spadd" ref="55a721406266e38174283509208e78c8" args="(dsp **A0, const dsp *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spadd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a sparse matrix to another: A0=A0+B. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00936"></a>00936                                          {
<a name="l00937"></a>00937     <span class="comment">//add B to A.</span>
<a name="l00938"></a>00938     <span class="keywordflow">if</span>(B){
<a name="l00939"></a>00939     <span class="keywordflow">if</span>(!*A0) 
<a name="l00940"></a>00940         *A0=Y(spdup)(B);
<a name="l00941"></a>00941     <span class="keywordflow">else</span>{
<a name="l00942"></a>00942         <span class="keywordflow">if</span>((*A0)-&gt;m!=B-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a> || (*A0)-&gt;n!=B-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>) {
<a name="l00943"></a>00943         error(<span class="stringliteral">"X(sp) matrix mismatch: (%ldx%ld) vs (%ldx%ld\n"</span>,
<a name="l00944"></a>00944               (*A0)-&gt;m, (*A0)-&gt;n, B-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>, B-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>);
<a name="l00945"></a>00945         }
<a name="l00946"></a>00946         X(sp) *res=Y(cs_add)(*A0,B,1.,1.);
<a name="l00947"></a>00947         Y(cs_dropzeros)(res);
<a name="l00948"></a>00948         <span class="comment">//move the data over.</span>
<a name="l00949"></a>00949         Y(spmove)(*A0,res);<span class="comment">//move the data from res to A.</span>
<a name="l00950"></a>00950     }
<a name="l00951"></a>00951     }
<a name="l00952"></a>00952 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="50a4c44bf6e5fdbc087a94fa815ed94a"></a><!-- doxytag: member="dsp.h::spcelladd" ref="50a4c44bf6e5fdbc087a94fa815ed94a" args="(spcell **A0, const spcell *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcelladd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspcell.html">spcell</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a sparse cell to another: A0=A0+B. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00955"></a>00955                                                      {
<a name="l00956"></a>00956     <span class="keywordflow">if</span>(B){
<a name="l00957"></a>00957     <span class="keywordflow">if</span>(!*A0){
<a name="l00958"></a>00958         *A0=Y(spcellnew)(B-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>, B-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>);
<a name="l00959"></a>00959     }
<a name="l00960"></a>00960     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;B-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>*B-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>; i++){
<a name="l00961"></a>00961         Y(spadd)(&amp;((*A0)-&gt;p[i]), B-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>[i]);
<a name="l00962"></a>00962     }
<a name="l00963"></a>00963     }
<a name="l00964"></a>00964 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c8975e7b8152e52b2c8cd8e785c25310"></a><!-- doxytag: member="dsp.h::sptrans" ref="c8975e7b8152e52b2c8cd8e785c25310" args="(const dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* sptrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transpose a sparse array. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00967"></a>00967                                  {
<a name="l00968"></a>00968     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l00969"></a>00969     X(sp) *res=Y(cs_transpose)(A,1);
<a name="l00970"></a>00970     Y(cs_dropzeros)(res);
<a name="l00971"></a>00971     <span class="keywordflow">return</span> res;
<a name="l00972"></a>00972 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ccfcfe9fff4e25824ae3ad516f01b864"></a><!-- doxytag: member="dsp.h::spmulsp" ref="ccfcfe9fff4e25824ae3ad516f01b864" args="(const dsp *A, const dsp *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spmulsp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two sparse arrays: return A*B. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00975"></a>00975                                                  {      
<a name="l00976"></a>00976     <span class="comment">//return C=(A*B)</span>
<a name="l00977"></a>00977     <span class="keywordflow">if</span>(!A || !B) <span class="keywordflow">return</span> NULL;
<a name="l00978"></a>00978     X(sp) *C=Y(cs_multiply)(A, B);
<a name="l00979"></a>00979     Y(cs_dropzeros)(C);
<a name="l00980"></a>00980     <span class="keywordflow">return</span> C;
<a name="l00981"></a>00981 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b3929bab7dcd7cf4be34e9e4f7579c90"></a><!-- doxytag: member="dsp.h::sptmulsp" ref="b3929bab7dcd7cf4be34e9e4f7579c90" args="(const dsp *A, const dsp *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* sptmulsp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply the transpose of a sparse with another: return A'*B. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00984"></a>00984                                                   {
<a name="l00985"></a>00985     <span class="comment">//return A'*B;</span>
<a name="l00986"></a>00986     <span class="comment">//fixme : may need to improve this so that tranpose of A is not necessary.</span>
<a name="l00987"></a>00987     X(sp) *At=Y(sptrans)(A);
<a name="l00988"></a>00988     X(sp) *C=Y(spmulsp)(At, B);
<a name="l00989"></a>00989     Y(spfree)(At);
<a name="l00990"></a>00990     Y(cs_dropzeros)(C);
<a name="l00991"></a>00991     <span class="keywordflow">return</span> C;
<a name="l00992"></a>00992 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="79439ae66ccac26a63d90b0937aa89a6"></a><!-- doxytag: member="dsp.h::spmulsp2" ref="79439ae66ccac26a63d90b0937aa89a6" args="(dsp **C0, const dsp *A, const dsp *B, const double scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spmulsp2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> **&nbsp;</td>
          <td class="paramname"> <em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two sparse arrays and add to the third: C0=C0+A*B*scale. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00996"></a>00996                        {
<a name="l00997"></a>00997     <span class="comment">//return C=C+ alpha*(A*B)</span>
<a name="l00998"></a>00998     <span class="keywordflow">if</span>(!A || !B) <span class="keywordflow">return</span>;
<a name="l00999"></a>00999     X(sp) *res=Y(cs_multiply)(A, B);
<a name="l01000"></a>01000     <span class="keywordflow">if</span>(ABS(scale-1.)&gt;EPS){
<a name="l01001"></a>01001     Y(spscale)(res, scale);
<a name="l01002"></a>01002     }
<a name="l01003"></a>01003     <span class="keywordflow">if</span>(!*C0) 
<a name="l01004"></a>01004     *C0=res;
<a name="l01005"></a>01005     <span class="keywordflow">else</span>{
<a name="l01006"></a>01006     Y(spadd)(C0, res);
<a name="l01007"></a>01007     Y(spfree)(res);
<a name="l01008"></a>01008     }
<a name="l01009"></a>01009     Y(cs_dropzeros)(*C0);
<a name="l01010"></a>01010 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5ba25787c1b6292d42da40d941cea273"></a><!-- doxytag: member="dsp.h::spcellmulspcell" ref="5ba25787c1b6292d42da40d941cea273" args="(const spcell *A, const spcell *B, const double scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspcell.html">spcell</a>* spcellmulspcell           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two sparse cell. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01015"></a>01015                                 {
<a name="l01016"></a>01016     <span class="comment">//return C=A*B;</span>
<a name="l01017"></a>01017     <span class="keywordflow">if</span>(!A || !B) <span class="keywordflow">return</span> NULL;
<a name="l01018"></a>01018     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>!=B-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>) error(<span class="stringliteral">"mismatch\n"</span>);
<a name="l01019"></a>01019     Y(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>) *C=Y(spcellnew)(A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>, B-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>);
<a name="l01020"></a>01020     X(sp) *(*Ap)[A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>] = (X(sp) *(*)[A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>]) A-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>;
<a name="l01021"></a>01021     X(sp) *(*Bp)[B-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>] = (X(sp) *(*)[B-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>]) B-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>;
<a name="l01022"></a>01022     X(sp) *(*Cp)[C-&gt;nx] = (X(sp) *(*)[C-&gt;nx]) C-&gt;p;
<a name="l01023"></a>01023     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;B-&gt;ny; iy++){
<a name="l01024"></a>01024     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>; ix++){
<a name="l01025"></a>01025         Cp[iy][ix]=NULL;
<a name="l01026"></a>01026         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz=0; iz&lt;A-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>; iz++){
<a name="l01027"></a>01027         Y(spmulsp2)(&amp;Cp[iy][ix],Ap[iz][ix],Bp[iy][iz],scale);
<a name="l01028"></a>01028         }
<a name="l01029"></a>01029     }
<a name="l01030"></a>01030     }
<a name="l01031"></a>01031     <span class="keywordflow">return</span> C;
<a name="l01032"></a>01032 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="af5362fa0fc6afc00fc3af29e4fb536d"></a><!-- doxytag: member="dsp.h::spcellnew" ref="af5362fa0fc6afc00fc3af29e4fb536d" args="(const long nx, const long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspcell.html">spcell</a>* spcellnew           </td>
          <td>(</td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new sparse cell. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01035"></a>01035                                                      {
<a name="l01036"></a>01036     Y(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>) *spc;
<a name="l01037"></a>01037     spc=calloc(1, <span class="keyword">sizeof</span>(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>));
<a name="l01038"></a>01038     spc-&gt;nx=nx;
<a name="l01039"></a>01039     spc-&gt;ny=ny;
<a name="l01040"></a>01040     spc-&gt;p=calloc(nx*ny, <span class="keyword">sizeof</span>(X(sp) *));
<a name="l01041"></a>01041     <span class="keywordflow">return</span> spc;
<a name="l01042"></a>01042 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a4691afd2563e44ec261422a3648ff01"></a><!-- doxytag: member="dsp.h::spcelltrans" ref="a4691afd2563e44ec261422a3648ff01" args="(const spcell *spc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspcell.html">spcell</a>* spcelltrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>spc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transpose a sparse cell. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01045"></a>01045                                                {
<a name="l01046"></a>01046     <span class="keywordflow">if</span>(!spc) <span class="keywordflow">return</span> NULL;
<a name="l01047"></a>01047     <span class="keywordtype">long</span> nx,ny;
<a name="l01048"></a>01048     nx=spc-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>;
<a name="l01049"></a>01049     ny=spc-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>;
<a name="l01050"></a>01050     Y(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>) *spct=Y(spcellnew)(ny,nx);
<a name="l01051"></a>01051     
<a name="l01052"></a>01052     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;ny; iy++){
<a name="l01053"></a>01053     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;nx; ix++){
<a name="l01054"></a>01054         spct-&gt;p[iy+ix*ny]=Y(sptrans)(spc-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>[ix+iy*nx]);
<a name="l01055"></a>01055     }
<a name="l01056"></a>01056     }
<a name="l01057"></a>01057     <span class="keywordflow">return</span> spct;
<a name="l01058"></a>01058 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6279b6b982b02b5ed30ba76643e5c989"></a><!-- doxytag: member="dsp.h::spcellfree_do" ref="6279b6b982b02b5ed30ba76643e5c989" args="(spcell *spc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>spc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a sparse cell data. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01061"></a>01061                                      {
<a name="l01062"></a>01062     <span class="keywordflow">if</span>(!spc || !spc-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>) <span class="keywordflow">return</span>;
<a name="l01063"></a>01063     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;spc-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>*spc-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>; ix++){
<a name="l01064"></a>01064     Y(spfree)(spc-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>[ix]);
<a name="l01065"></a>01065     }
<a name="l01066"></a>01066     free(spc-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>);
<a name="l01067"></a>01067     free(spc);
<a name="l01068"></a>01068 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9c43a97ba91966d8bb56640fe0b9cd40"></a><!-- doxytag: member="dsp.h::spcat" ref="9c43a97ba91966d8bb56640fe0b9cd40" args="(const dsp *A, const dsp *B, int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spcat           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenate two sparse array along dim dimension. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01071"></a>01071                                                         {
<a name="l01072"></a>01072     X(sp) *C=NULL;
<a name="l01073"></a>01073     <span class="keywordflow">if</span>(dim==0){
<a name="l01074"></a>01074     error(<span class="stringliteral">"Not implemented\n"</span>);
<a name="l01075"></a>01075     <span class="comment">/*</span>
<a name="l01076"></a>01076 <span class="comment">      |A|</span>
<a name="l01077"></a>01077 <span class="comment">      |B|</span>
<a name="l01078"></a>01078 <span class="comment">    */</span>
<a name="l01079"></a>01079     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim==1){
<a name="l01080"></a>01080     <span class="comment">/*|AB|*/</span>
<a name="l01081"></a>01081     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a> != B-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>){
<a name="l01082"></a>01082         error(<span class="stringliteral">"X(sp) matrix doesn't match\n"</span>);
<a name="l01083"></a>01083     }
<a name="l01084"></a>01084     <span class="keyword">const</span> <span class="keywordtype">long</span> nzmax=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>]+B-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[B-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>];
<a name="l01085"></a>01085     C=Y(spnew)(A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>, A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>+B-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>, nzmax);
<a name="l01086"></a>01086     memcpy(C-&gt;p, A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>, A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l01087"></a>01087     memcpy(C-&gt;i, A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>, A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>]*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l01088"></a>01088     memcpy(C-&gt;x, A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>, A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>]*<span class="keyword">sizeof</span>(T));
<a name="l01089"></a>01089     memcpy(C-&gt;i+A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>], B-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>, B-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[B-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>]*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l01090"></a>01090     memcpy(C-&gt;x+A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>], B-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>, B-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[B-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>]*<span class="keyword">sizeof</span>(T));
<a name="l01091"></a>01091     <span class="keyword">const</span> <span class="keywordtype">long</span> Anzmax=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>];
<a name="l01092"></a>01092     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;B-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>+1; i++){
<a name="l01093"></a>01093         C-&gt;p[i+A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>]=Anzmax+B-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[i];
<a name="l01094"></a>01094     }
<a name="l01095"></a>01095     }<span class="keywordflow">else</span>{
<a name="l01096"></a>01096     error(<span class="stringliteral">"Wrong dimension\n"</span>);
<a name="l01097"></a>01097     }
<a name="l01098"></a>01098     <span class="keywordflow">return</span> C;
<a name="l01099"></a>01099 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5d94fe9f6ba76a7d6b4ea76243e70198"></a><!-- doxytag: member="dsp.h::spcell2sp" ref="5d94fe9f6ba76a7d6b4ea76243e70198" args="(const spcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spcell2sp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenate a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> to sparse array. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01102"></a>01102                                        {
<a name="l01103"></a>01103     <span class="comment">//convert Y(spcell) to sparse.</span>
<a name="l01104"></a>01104     X(sp) *(*Ap)[A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>] = (X(sp) *(*)[A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>])A-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>;
<a name="l01105"></a>01105     <span class="keywordtype">long</span> nx=0,ny=0,nzmax=0;
<a name="l01106"></a>01106     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;nx; ix++){
<a name="l01107"></a>01107     nx+=Ap[0][ix]-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>;
<a name="l01108"></a>01108     }
<a name="l01109"></a>01109     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>; iy++){
<a name="l01110"></a>01110     ny+=Ap[iy][0]-&gt;n;
<a name="l01111"></a>01111     }
<a name="l01112"></a>01112     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>*A-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>; i++){
<a name="l01113"></a>01113     nzmax+=A-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>[i]-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[A-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>[i]-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>];
<a name="l01114"></a>01114     <span class="comment">//nzmax+=A-&gt;p[i]-&gt;nzmax;</span>
<a name="l01115"></a>01115     }
<a name="l01116"></a>01116     X(sp) *out=Y(spnew)(nx,ny,nzmax);
<a name="l01117"></a>01117     <span class="keywordtype">long</span> count=0;
<a name="l01118"></a>01118     <span class="keywordtype">long</span> jcol=0;
<a name="l01119"></a>01119     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>; iy++){
<a name="l01120"></a>01120     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;Ap[iy][0]-&gt;n; icol++){
<a name="l01121"></a>01121         out-&gt;p[jcol+icol]=count;
<a name="l01122"></a>01122         <span class="keywordtype">long</span> kr=0;
<a name="l01123"></a>01123         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>; ix++){
<a name="l01124"></a>01124         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ir=Ap[iy][ix]-&gt;p[icol]; 
<a name="l01125"></a>01125             ir&lt;Ap[iy][ix]-&gt;p[icol+1]; ir++){
<a name="l01126"></a>01126             out-&gt;x[count]=Ap[iy][ix]-&gt;x[ir];
<a name="l01127"></a>01127             out-&gt;i[count]=Ap[iy][ix]-&gt;i[ir]+kr;
<a name="l01128"></a>01128             count++;
<a name="l01129"></a>01129         }
<a name="l01130"></a>01130         kr+=Ap[iy][ix]-&gt;m;
<a name="l01131"></a>01131         }
<a name="l01132"></a>01132     }
<a name="l01133"></a>01133     jcol+=Ap[iy][0]-&gt;n;
<a name="l01134"></a>01134     }
<a name="l01135"></a>01135     out-&gt;p[ny]=count;
<a name="l01136"></a>01136     <span class="keywordflow">if</span>(count&gt;nzmax){
<a name="l01137"></a>01137     error(<span class="stringliteral">"Y(spcell2sp) gets Wrong results. count=%ld, nzmax=%ld\n"</span>,count,nzmax);
<a name="l01138"></a>01138     }
<a name="l01139"></a>01139     <span class="comment">//nzmax maybe smaller than A-&gt;p[A-&gt;n] </span>
<a name="l01140"></a>01140     <span class="comment">//because nzmax simply show the slots available.</span>
<a name="l01141"></a>01141     <span class="keywordflow">return</span> out;
<a name="l01142"></a>01142 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="236a93b9ea7b5b6f0a5bbc6373fbb562"></a><!-- doxytag: member="dsp.h::spsum" ref="236a93b9ea7b5b6f0a5bbc6373fbb562" args="(const dsp *A, int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* spsum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sum elements of sparse array along dimension dim. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01147"></a>01147                                          {
<a name="l01148"></a>01148     <span class="comment">//Sum X(sp) matrix along col or row to form a vector</span>
<a name="l01149"></a>01149     X(mat) *v=NULL;
<a name="l01150"></a>01150     T *p;
<a name="l01151"></a>01151     <span class="keywordflow">switch</span>(dim){
<a name="l01152"></a>01152     <span class="keywordflow">case</span> 1:<span class="comment">//sum along col</span>
<a name="l01153"></a>01153     v=X(<span class="keyword">new</span>)(1,A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>);
<a name="l01154"></a>01154     p=v-&gt;p;
<a name="l01155"></a>01155     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l01156"></a>01156         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l01157"></a>01157         p[icol]+=A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[irow];
<a name="l01158"></a>01158         }
<a name="l01159"></a>01159     }
<a name="l01160"></a>01160     <span class="keywordflow">break</span>;
<a name="l01161"></a>01161     <span class="keywordflow">case</span> 2:<span class="comment">//sum along row</span>
<a name="l01162"></a>01162     v=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>,1);
<a name="l01163"></a>01163     p=v-&gt;p;
<a name="l01164"></a>01164     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l01165"></a>01165         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l01166"></a>01166         p[A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[irow]]+=A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[irow];
<a name="l01167"></a>01167         }
<a name="l01168"></a>01168     }
<a name="l01169"></a>01169     <span class="keywordflow">break</span>;
<a name="l01170"></a>01170     <span class="keywordflow">default</span>:
<a name="l01171"></a>01171     error(<span class="stringliteral">"Invalid\n"</span>);
<a name="l01172"></a>01172     }
<a name="l01173"></a>01173     <span class="keywordflow">return</span> v;
<a name="l01174"></a>01174 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f8f59b688fb6512840f2f87a2e27dd86"></a><!-- doxytag: member="dsp.h::spsumabs" ref="f8f59b688fb6512840f2f87a2e27dd86" args="(const dsp *A, int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* spsumabs           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sum abs of elements of sparse array along dimension dim. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01177"></a>01177                                             {
<a name="l01178"></a>01178     X(mat) *v=NULL;
<a name="l01179"></a>01179     T *p;
<a name="l01180"></a>01180     <span class="keywordflow">switch</span>(col){
<a name="l01181"></a>01181     <span class="keywordflow">case</span> 1:<span class="comment">//sum along col</span>
<a name="l01182"></a>01182     v=X(<span class="keyword">new</span>)(1,A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>);
<a name="l01183"></a>01183     p=v-&gt;p;
<a name="l01184"></a>01184     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l01185"></a>01185         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l01186"></a>01186         p[icol]+=ABS(A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[irow]);
<a name="l01187"></a>01187         }
<a name="l01188"></a>01188     }
<a name="l01189"></a>01189     <span class="keywordflow">break</span>;
<a name="l01190"></a>01190     <span class="keywordflow">case</span> 2:<span class="comment">//sum along row</span>
<a name="l01191"></a>01191     v=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>,1);
<a name="l01192"></a>01192     p=v-&gt;p;
<a name="l01193"></a>01193     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l01194"></a>01194         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l01195"></a>01195         p[A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[irow]]+=ABS(A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[irow]);
<a name="l01196"></a>01196         }
<a name="l01197"></a>01197     }
<a name="l01198"></a>01198     <span class="keywordflow">break</span>;
<a name="l01199"></a>01199     <span class="keywordflow">default</span>:
<a name="l01200"></a>01200     error(<span class="stringliteral">"Invalid\n"</span>);
<a name="l01201"></a>01201     }
<a name="l01202"></a>01202     <span class="keywordflow">return</span> v;
<a name="l01203"></a>01203 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e192894e1e52e4bec2fbf06d37565251"></a><!-- doxytag: member="dsp.h::spcellmulvec" ref="e192894e1e52e4bec2fbf06d37565251" args="(double *restrict yc, const spcell *Ac, const double *restrict xc, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellmulvec           </td>
          <td>(</td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>yc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>Ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *restrict&nbsp;</td>
          <td class="paramname"> <em>xc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with vectors. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01212"></a>01212                                             {
<a name="l01213"></a>01213     <span class="comment">//y=y+alpha*A*creal(x); Ac X(sp) cell. xc is vector.</span>
<a name="l01214"></a>01214     <span class="keywordflow">if</span>(Ac &amp;&amp; xc){
<a name="l01215"></a>01215     <span class="keyword">const</span> T *restrict x=xc;
<a name="l01216"></a>01216     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icy=0; icy&lt;Ac-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>; icy++){
<a name="l01217"></a>01217         T *restrict y=yc;
<a name="l01218"></a>01218         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icx=0; icx&lt;Ac-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>; icx++){
<a name="l01219"></a>01219         <span class="keyword">const</span> X(sp) *A=Ac-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>[icx+icy*Ac-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>];
<a name="l01220"></a>01220         Y(spmulvec)(y,A,x,alpha);
<a name="l01221"></a>01221         y+=A-&gt;m;
<a name="l01222"></a>01222         }
<a name="l01223"></a>01223         x+=Ac-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>[icy*Ac-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>]-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>;
<a name="l01224"></a>01224     }
<a name="l01225"></a>01225     }
<a name="l01226"></a>01226 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0e4197d10a998676c7d7f1ab5e1a6d4a"></a><!-- doxytag: member="dsp.h::spdropeps" ref="0e4197d10a998676c7d7f1ab5e1a6d4a" args="(dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdropeps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drop elements that are EPS times the largest value. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01230"></a>01230                            {
<a name="l01231"></a>01231     <span class="keywordtype">double</span> max;
<a name="l01232"></a>01232 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l01233"></a>01233 <span class="preprocessor"></span>    maxmincmp(A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>,A-&gt;<a class="code" href="structdsp.html#870a449e24356b8a08ec11a4916be6a0" title="maximum number of entries">nzmax</a>,&amp;max,NULL,NULL);
<a name="l01234"></a>01234 <span class="preprocessor">#else</span>
<a name="l01235"></a>01235 <span class="preprocessor"></span>    max=<a class="code" href="mathmisc_8c.html#ac7d23a6f61a359934d93f1fbdc570ea" title="compute the maximum of the abs of double vector">maxabs</a>(A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>, A-&gt;<a class="code" href="structdsp.html#870a449e24356b8a08ec11a4916be6a0" title="maximum number of entries">nzmax</a>);
<a name="l01236"></a>01236 <span class="preprocessor">#endif</span>
<a name="l01237"></a>01237 <span class="preprocessor"></span>    Y(cs_droptol)(A, max*EPS);
<a name="l01238"></a>01238 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="86932c91ee953ec4cbfb6ece9f6de414"></a><!-- doxytag: member="dsp.h::spcelldropeps" ref="86932c91ee953ec4cbfb6ece9f6de414" args="(spcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcelldropeps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drop elements that are EPS times the largest value. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01242"></a>01242                                    {
<a name="l01243"></a>01243     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>*A-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>; i++){
<a name="l01244"></a>01244     Y(spdropeps)(A-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>[i]);
<a name="l01245"></a>01245     }
<a name="l01246"></a>01246 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="076986e054ddc89e713fba2c7f071911"></a><!-- doxytag: member="dsp.h::spsort" ref="076986e054ddc89e713fba2c7f071911" args="(dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spsort           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make sure the elements are sorted correctly. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01258"></a>01258                         {
<a name="l01259"></a>01259     spelem *col=NULL;
<a name="l01260"></a>01260     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; i++){
<a name="l01261"></a>01261     <span class="keywordtype">long</span> nelem=(A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[i+1]-A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[i]);
<a name="l01262"></a>01262     <span class="keywordflow">if</span>(nelem==0) <span class="keywordflow">continue</span>;
<a name="l01263"></a>01263     col=realloc(col, nelem*<span class="keyword">sizeof</span>(spelem));
<a name="l01264"></a>01264     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;nelem; j++){
<a name="l01265"></a>01265         col[j].i=A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[i]+j];
<a name="l01266"></a>01266         col[j].x=A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[i]+j];
<a name="l01267"></a>01267     }
<a name="l01268"></a>01268     qsort(col, nelem, <span class="keyword">sizeof</span>(spelem), (<span class="keywordtype">int</span>(*)(<span class="keyword">const</span> <span class="keywordtype">void</span>*,<span class="keyword">const</span> <span class="keywordtype">void</span>*))spelemcmp);
<a name="l01269"></a>01269     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;nelem; j++){
<a name="l01270"></a>01270         A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[i]+j]=col[j].i;
<a name="l01271"></a>01271         A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[i]+j]=col[j].x;
<a name="l01272"></a>01272     }
<a name="l01273"></a>01273     }
<a name="l01274"></a>01274     free(col);
<a name="l01275"></a>01275 
<a name="l01276"></a>01276 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="928b798c235560783e958341fbc1c401"></a><!-- doxytag: member="dsp.h::spcellsort" ref="928b798c235560783e958341fbc1c401" args="(spcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellsort           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make sure the elements are sorted correctly. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01280"></a>01280                                 {
<a name="l01281"></a>01281     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>*A-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>; i++){
<a name="l01282"></a>01282     Y(spsort)(A-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>[i]);
<a name="l01283"></a>01283     }
<a name="l01284"></a>01284 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6725c247cbf3d417249b6a7d4ab5159d"></a><!-- doxytag: member="dsp.h::spsym" ref="6725c247cbf3d417249b6a7d4ab5159d" args="(dsp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spsym           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
symmetricize a X(sp) matrix and drop values below a threshold. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01289"></a>01289                        {
<a name="l01290"></a>01290     X(sp) *B=Y(sptrans)(A);
<a name="l01291"></a>01291     Y(spadd)(&amp;A,B);
<a name="l01292"></a>01292     Y(spscale)(A,0.5);
<a name="l01293"></a>01293     Y(spfree)(B);
<a name="l01294"></a>01294     Y(spdropeps)(A);
<a name="l01295"></a>01295     Y(spsort)(A);<span class="comment">//This is important to make chol work.</span>
<a name="l01296"></a>01296 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e575353f52b29ec1c1faec4cc4fa42c4"></a><!-- doxytag: member="dsp.h::spcellsym" ref="e575353f52b29ec1c1faec4cc4fa42c4" args="(spcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellsym           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
symmetricize a X(sp) cell and drop values below a threshold. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01301"></a>01301                                {
<a name="l01302"></a>01302     Y(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>) *B=Y(spcelltrans)(A);
<a name="l01303"></a>01303     Y(spcelladd)(&amp;A,B);
<a name="l01304"></a>01304     Y(spcellfree)(B);
<a name="l01305"></a>01305     Y(spcellscale)(A,0.5);
<a name="l01306"></a>01306     Y(spcelldropeps)(A);
<a name="l01307"></a>01307     Y(spcellsort)(A);
<a name="l01308"></a>01308 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="56681bcd783ee04dcd2b3e74bd56833d"></a><!-- doxytag: member="dsp.h::spconvolvop" ref="56681bcd783ee04dcd2b3e74bd56833d" args="(dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spconvolvop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a X(sp) convolution operator C with C(i,j)=A(i-j); A must be very X(sp) with only a view non-zero value otherwise C will be too full. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01315"></a>01315                                 {
<a name="l01316"></a>01316     <span class="comment">//First collect statistics on A.</span>
<a name="l01317"></a>01317     <span class="keywordtype">long</span> nini=10;
<a name="l01318"></a>01318     T *vals=calloc(nini, <span class="keyword">sizeof</span>(T));
<a name="l01319"></a>01319     <span class="keywordtype">long</span> *sepx=calloc(nini, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l01320"></a>01320     <span class="keywordtype">long</span> *sepy=calloc(nini, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l01321"></a>01321     <span class="keywordtype">long</span> count=0;
<a name="l01322"></a>01322     <span class="keyword">const</span> <span class="keywordtype">long</span> nx=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l01323"></a>01323     <span class="keyword">const</span> <span class="keywordtype">long</span> ny=A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l01324"></a>01324     <span class="keyword">const</span> <span class="keywordtype">long</span> nn=nx*ny;
<a name="l01325"></a>01325     PMAT(A,PA);
<a name="l01326"></a>01326     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l01327"></a>01327     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; ix++){
<a name="l01328"></a>01328         <span class="keywordflow">if</span>(ABS(PA[iy][ix])&gt;0){
<a name="l01329"></a>01329         vals[count]=PA[iy][ix];
<a name="l01330"></a>01330         sepx[count]=ix;
<a name="l01331"></a>01331         sepy[count]=iy;
<a name="l01332"></a>01332         count++;
<a name="l01333"></a>01333         }
<a name="l01334"></a>01334         <span class="keywordflow">if</span>(count&gt;=nini){
<a name="l01335"></a>01335         nini*=2;
<a name="l01336"></a>01336         vals=realloc(vals, <span class="keyword">sizeof</span>(T)*nini);
<a name="l01337"></a>01337         sepx=realloc(sepx, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*nini);
<a name="l01338"></a>01338         sepy=realloc(sepy, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*nini);
<a name="l01339"></a>01339         }
<a name="l01340"></a>01340     }
<a name="l01341"></a>01341     }
<a name="l01342"></a>01342     <span class="keywordflow">if</span>(count&gt;10){
<a name="l01343"></a>01343     warning(<span class="stringliteral">"Number of coupled points %ld is too large\n"</span>,count);
<a name="l01344"></a>01344     }
<a name="l01345"></a>01345     <span class="keywordtype">long</span> nsep=count;
<a name="l01346"></a>01346     X(sp) *out=Y(spnew)(nn,nn,nn*count);
<a name="l01347"></a>01347     <span class="keywordtype">long</span> *pp=out-&gt;p;
<a name="l01348"></a>01348     <span class="keywordtype">long</span> *pi=out-&gt;i;
<a name="l01349"></a>01349     T *px=out-&gt;x;
<a name="l01350"></a>01350     count=0;
<a name="l01351"></a>01351     <span class="keywordtype">long</span> icol=0;
<a name="l01352"></a>01352     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iiy=0; iiy&lt;A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iiy++){
<a name="l01353"></a>01353     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iix=0; iix&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; iix++){
<a name="l01354"></a>01354         pp[icol]=count;
<a name="l01355"></a>01355         icol++;
<a name="l01356"></a>01356         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=0; irow&lt;nsep; irow++){
<a name="l01357"></a>01357         <span class="keywordtype">long</span> jix=(iix+sepx[irow])%nx;
<a name="l01358"></a>01358         <span class="keywordtype">long</span> jiy=(iiy+sepy[irow])%ny;
<a name="l01359"></a>01359         pi[count]=jix+jiy*nx;
<a name="l01360"></a>01360         px[count]=vals[irow];
<a name="l01361"></a>01361         count++;
<a name="l01362"></a>01362         }
<a name="l01363"></a>01363     }
<a name="l01364"></a>01364     }
<a name="l01365"></a>01365     pp[nn]=count;
<a name="l01366"></a>01366     free(vals);
<a name="l01367"></a>01367     free(sepx);
<a name="l01368"></a>01368     free(sepy);
<a name="l01369"></a>01369     Y(spsort)(out);
<a name="l01370"></a>01370     <span class="keywordflow">return</span> out;
<a name="l01371"></a>01371 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3338a45fa3da4ef03cd3b7e37e2d0ed8"></a><!-- doxytag: member="dsp.h::spperm" ref="3338a45fa3da4ef03cd3b7e37e2d0ed8" args="(dsp *A, int reverse, long *pcol, long *prow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spperm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>pcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>prow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Permute rows and columns of X(sp) matrix A;. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01407"></a>01407                                                                {
<a name="l01408"></a>01408     X(sp) *out;
<a name="l01409"></a>01409     <span class="keywordflow">if</span>(pcol){
<a name="l01410"></a>01410     out=Y(sppermcol)(A,reverse,pcol);
<a name="l01411"></a>01411     }<span class="keywordflow">else</span>{
<a name="l01412"></a>01412     out=Y(spref)(A);
<a name="l01413"></a>01413     }
<a name="l01414"></a>01414     <span class="keywordflow">if</span>(prow){
<a name="l01415"></a>01415     X(sp) *Ap=Y(sptrans)(out);
<a name="l01416"></a>01416     X(sp) *App=Y(sppermcol)(Ap,reverse,prow);
<a name="l01417"></a>01417     Y(spfree)(Ap);
<a name="l01418"></a>01418     Y(spfree)(out);
<a name="l01419"></a>01419     out=Y(sptrans)(App);
<a name="l01420"></a>01420     Y(spfree)(App);
<a name="l01421"></a>01421     }
<a name="l01422"></a>01422     <span class="keywordflow">return</span> out;
<a name="l01423"></a>01423 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="650a5b5e2f5fe7c7a74941d141ccd34b"></a><!-- doxytag: member="dsp.h::spinvbdiag" ref="650a5b5e2f5fe7c7a74941d141ccd34b" args="(const dsp *A, long bs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spinvbdiag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>bs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invert a SPD X(sp) matrix that is block diagonal with block sizes of bs. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01429"></a>01429                                              {
<a name="l01430"></a>01430     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>!=A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>){
<a name="l01431"></a>01431     error(<span class="stringliteral">"Must be a square matrix\n"</span>);
<a name="l01432"></a>01432     }
<a name="l01433"></a>01433     <span class="keywordtype">long</span> nb=A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>/bs;
<a name="l01434"></a>01434     X(sp) *B=Y(spnew)(A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>, A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>, nb*bs*bs);
<a name="l01435"></a>01435     X(mat) *bk=X(<span class="keyword">new</span>)(bs,bs);
<a name="l01436"></a>01436     PMAT(bk,pbk);
<a name="l01437"></a>01437     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ib=0;ib&lt;nb; ib++){
<a name="l01438"></a>01438     <span class="keywordtype">long</span> is=ib*bs;<span class="comment">//starting col</span>
<a name="l01439"></a>01439     X(zero)(bk);
<a name="l01440"></a>01440 
<a name="l01441"></a>01441     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=is; icol&lt;is+bs; icol++){
<a name="l01442"></a>01442         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l01443"></a>01443         <span class="keywordtype">long</span> row=A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[irow];
<a name="l01444"></a>01444         <span class="keywordtype">long</span> ind=row-is;
<a name="l01445"></a>01445         <span class="keywordflow">if</span>(ind&lt;0 || ind&gt;=bs){
<a name="l01446"></a>01446             info(<span class="stringliteral">"solving block %ld\n"</span>,ib);
<a name="l01447"></a>01447             error(<span class="stringliteral">"The array is not block diagonal matrix or not calculated property\n"</span>);
<a name="l01448"></a>01448         }
<a name="l01449"></a>01449         pbk[icol-is][ind]=A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[irow];
<a name="l01450"></a>01450         }
<a name="l01451"></a>01451     }
<a name="l01452"></a>01452     X(inv_inplace)(bk);
<a name="l01453"></a>01453     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=is; icol&lt;is+bs; icol++){
<a name="l01454"></a>01454         B-&gt;p[icol]=icol*bs;
<a name="l01455"></a>01455         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=0; irow&lt;bs; irow++){
<a name="l01456"></a>01456         B-&gt;i[B-&gt;p[icol]+irow]=irow+is;
<a name="l01457"></a>01457         B-&gt;x[B-&gt;p[icol]+irow]=pbk[icol-is][irow];
<a name="l01458"></a>01458         }
<a name="l01459"></a>01459     }
<a name="l01460"></a>01460     }
<a name="l01461"></a>01461     B-&gt;p[A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>]=nb*bs*bs;
<a name="l01462"></a>01462     <span class="keywordflow">return</span> B;
<a name="l01463"></a>01463 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3e59d81ab1a258a9da09a5a0cb150715"></a><!-- doxytag: member="dsp.h::spblockextract" ref="3e59d81ab1a258a9da09a5a0cb150715" args="(const dsp *A, long bs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* spblockextract           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>bs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extrat the diagonal blocks of size bs into cell arrays. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01467"></a>01467                                                    {
<a name="l01468"></a>01468     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>!=A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>){
<a name="l01469"></a>01469     error(<span class="stringliteral">"Must be a square matrix\n"</span>);
<a name="l01470"></a>01470     }
<a name="l01471"></a>01471     <span class="keywordtype">long</span> nb=A-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>/bs;
<a name="l01472"></a>01472     X(cell) *out=X(cellnew)(nb,1);
<a name="l01473"></a>01473     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ib=0;ib&lt;nb; ib++){
<a name="l01474"></a>01474     <span class="keywordtype">long</span> is=ib*bs;<span class="comment">//starting col</span>
<a name="l01475"></a>01475     out-&gt;p[ib]=X(<span class="keyword">new</span>)(bs,bs);
<a name="l01476"></a>01476     PMAT(out-&gt;p[ib],pbk);
<a name="l01477"></a>01477     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=is; icol&lt;is+bs; icol++){
<a name="l01478"></a>01478         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l01479"></a>01479         <span class="keywordtype">long</span> row=A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[irow];
<a name="l01480"></a>01480         <span class="keywordtype">long</span> ind=row-is;
<a name="l01481"></a>01481         <span class="keywordflow">if</span>(ind&lt;0 || ind&gt;=bs){
<a name="l01482"></a>01482             info(<span class="stringliteral">"solving block %ld\n"</span>,ib);
<a name="l01483"></a>01483             error(<span class="stringliteral">"The array is not block diagonal matrix or not calculated property\n"</span>);
<a name="l01484"></a>01484         }
<a name="l01485"></a>01485         pbk[icol-is][ind]=A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[irow];
<a name="l01486"></a>01486         }
<a name="l01487"></a>01487     }
<a name="l01488"></a>01488     }
<a name="l01489"></a>01489     <span class="keywordflow">return</span> out;
<a name="l01490"></a>01490 }
</pre></div>
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Oct 27 12:43:13 2010 for maos-0.6.1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
