<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>maos-0.7.5: lib/csp.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lib/csp.h File Reference</h1>Contains functions for complex sparse <a class="el" href="structcsp.html" title="a sparse array of double complex numbers stored in compressed column format">csp</a>.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#c487a2b9ebd0931e631626a37965fd24">cspnew</a> (long nx, long ny, long nzmax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a nx*ny X(sp) matrix with memory for nmax max elements allocated.  <a href="#c487a2b9ebd0931e631626a37965fd24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#80f3f0a59125204877db212a85e8c6c7">cspref</a> (<a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reference a sparse object.  <a href="#80f3f0a59125204877db212a85e8c6c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#6f0c670abe3c96cce9afb0f0e733b350">cspdup</a> (const <a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy a X(sp) matrix to another.  <a href="#6f0c670abe3c96cce9afb0f0e733b350"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#978de1ab5d2901e086f61668140f7339">cspmove</a> (<a class="el" href="structcsp.html">csp</a> *A, <a class="el" href="structcsp.html">csp</a> *res)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">move the matrix from res to A.  <a href="#978de1ab5d2901e086f61668140f7339"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#ba26181f356f45e0c66bb677a6c32698">cspnew2</a> (const <a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(sp) matrix of the same size as A.  <a href="#ba26181f356f45e0c66bb677a6c32698"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#44da99a2eead0d399880a17533e36b2b">cspnewrandu</a> (int nx, int ny, const dcomplex mean, double fill, <a class="el" href="structmt__state.html">rand_t</a> *rstat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(sp) matrix and fill in uniform random numbers with filling factor of 'fill'.  <a href="#44da99a2eead0d399880a17533e36b2b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#0f62850af8a0a48f2cc063bf95df8856">cspsetnzmax</a> (<a class="el" href="structcsp.html">csp</a> *sp, long nzmax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">resize a X(sp) matrix  <a href="#0f62850af8a0a48f2cc063bf95df8856"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#4ae0a8c3586b6bc85cc273b3217b2db4">cspfree_do</a> (<a class="el" href="structcsp.html">csp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(sp) matrix  <a href="#4ae0a8c3586b6bc85cc273b3217b2db4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#d23c83475ff51aac1ee3fc9aaa58d490">csparrfree</a> (<a class="el" href="structcsp.html">csp</a> **sparr, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(sp) array  <a href="#d23c83475ff51aac1ee3fc9aaa58d490"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#dc5754766a10048b0412d4fd7d6d4f21">cspdisp</a> (const <a class="el" href="structcsp.html">csp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display a X(sp) array.  <a href="#dc5754766a10048b0412d4fd7d6d4f21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#da6187466a85d6d4471143963d1a0b35">cspcheck</a> (const <a class="el" href="structcsp.html">csp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check a X(sp) array for wrong orders.  <a href="#da6187466a85d6d4471143963d1a0b35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#dd8d261f3e339da0ae0b34f77c49efe5">cspscale</a> (<a class="el" href="structcsp.html">csp</a> *A, const dcomplex beta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace scale X(sp) matrix elements.  <a href="#dd8d261f3e339da0ae0b34f77c49efe5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#abcc5d0cae60d4f3dc19a6c3465a873e">cspcellscale</a> (<a class="el" href="structcspcell.html">cspcell</a> *A, const dcomplex beta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace scale a X(spcell) object  <a href="#abcc5d0cae60d4f3dc19a6c3465a873e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#1cb1312e34d6d65db22b2277ef34080c">cspnewdiag</a> (long N, dcomplex *vec, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new sparse matrix with diagonal elements set to vec*alpha.  <a href="#1cb1312e34d6d65db22b2277ef34080c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#78a7b8edb5848dbeefb21d3f04eb66e6">cspdiag</a> (const <a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract diagonal element of A and return.  <a href="#78a7b8edb5848dbeefb21d3f04eb66e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#41e52911fa532cd4d5651e2a9c75e91d">cspmuldiag</a> (<a class="el" href="structcsp.html">csp</a> *restrict A, const dcomplex *w, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a X(sp) matrix inplace with a diagonal weighting matrix whose diagonal values are stored in w.  <a href="#41e52911fa532cd4d5651e2a9c75e91d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#8e28cfb4fabbf2ca0080e55d488304a3">cspmulvec_thread</a> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, dcomplex alpha, int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a sparse with a vector using multithread.  <a href="#8e28cfb4fabbf2ca0080e55d488304a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#54fc8f015cdea3064a1dd4d404e428c1">cspmulvec</a> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sparse matrix multiply with a vector  <a href="#54fc8f015cdea3064a1dd4d404e428c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#9a5940fca0abf0d7876eafd923bc78e9">cspmulcreal</a> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a sparse matrix with the real part of a complex vector.  <a href="#9a5940fca0abf0d7876eafd923bc78e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#ae38da51fa42e1dba34308f3e27b068b">csptmulvec</a> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply transpose of a sparse matrix with a vector.  <a href="#ae38da51fa42e1dba34308f3e27b068b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#9c9f61dd9e10e0a18545069dd3a493bb">csptmulvec_thread</a> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, const dcomplex alpha, int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Threaded version of sptmulvec.  <a href="#9c9f61dd9e10e0a18545069dd3a493bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#979d62d76e351b60cb8ce8f270a1b866">cspmulmat</a> (<a class="el" href="structcmat.html">cmat</a> **yout, const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcmat.html">cmat</a> *x, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a sparse matrix X(sp) with a dense matrix X(mat).  <a href="#979d62d76e351b60cb8ce8f270a1b866"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#d33258da06cc2612c4c7c66e5af5306b">csptmulmat</a> (<a class="el" href="structcmat.html">cmat</a> **yout, const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcmat.html">cmat</a> *x, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">y=y+alpha*A'*x;  <a href="#d33258da06cc2612c4c7c66e5af5306b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#084a73490868acd8a291793aabbad3a5">cspwdinn</a> (const <a class="el" href="structcmat.html">cmat</a> *y, const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcmat.html">cmat</a> *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two matrices with weighting by sparse matrix.  <a href="#084a73490868acd8a291793aabbad3a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#d52ad07f584725c01825cd2e1fa38724">cspcellwdinn</a> (const <a class="el" href="structccell.html">ccell</a> *y, const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structccell.html">ccell</a> *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two cell arrays with weighting by sparse matrix.  <a href="#d52ad07f584725c01825cd2e1fa38724"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#e0baf2d188be6beae581db14384e88d1">cspcellmulmat</a> (<a class="el" href="structccell.html">ccell</a> **C, const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with a dense cell: C=C+A*B*alpha.  <a href="#e0baf2d188be6beae581db14384e88d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#2ae96154a8e626b25e038fda1af50032">csptcellmulmat</a> (<a class="el" href="structccell.html">ccell</a> **C, const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C=C+A'*B*alpha.  <a href="#2ae96154a8e626b25e038fda1af50032"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#55b1761ed410406c557bf8e650aa5f61">cspcellmulmat_thread</a> (<a class="el" href="structccell.html">ccell</a> **C, const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, const dcomplex alpha, const int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">threaded version of Y(spcellmulmat)  <a href="#55b1761ed410406c557bf8e650aa5f61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#2016cdf467cae24f45f30eb7cd4c236b">csptcellmulmat_thread</a> (<a class="el" href="structccell.html">ccell</a> **C, const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, const dcomplex alpha, const int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">threaded version of Y(sptcellmulmat  <a href="#2016cdf467cae24f45f30eb7cd4c236b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#7a8a319c9dcfc015746e77a9899bea5a">cspcellmulmat_each</a> (<a class="el" href="structccell.html">ccell</a> **xout, <a class="el" href="structcspcell.html">cspcell</a> *A, <a class="el" href="structccell.html">ccell</a> *xin, dcomplex alpha, int trans, int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Threaded multiply each cell in <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with each cell in <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>.  <a href="#7a8a319c9dcfc015746e77a9899bea5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#6644c43d1ac2abf3b7767935a5e2ab46">cspfull</a> (<a class="el" href="structcmat.html">cmat</a> **out0, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert sparse matrix into dense matrix and add to output: out0=out0+full(A)*alpha.  <a href="#6644c43d1ac2abf3b7767935a5e2ab46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#b2e5c232a1e67f54840d0d8da97bfbfc">csptfull</a> (<a class="el" href="structcmat.html">cmat</a> **out0, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the transpose of a sparse matrix into dense matrix and add to output: out0=out0+full(A')*alpha;.  <a href="#b2e5c232a1e67f54840d0d8da97bfbfc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#7b859f635f4fd699e4b703f64bf57890">cspcellfull</a> (<a class="el" href="structccell.html">ccell</a> **out0, const <a class="el" href="structcspcell.html">cspcell</a> *A, const dcomplex f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert sparse cell to dense matrix cell: out0=out0+full(A)*alpha.  <a href="#7b859f635f4fd699e4b703f64bf57890"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#d0ea8b24ff5f244861b568b7687c8f44">csptcellfull</a> (<a class="el" href="structccell.html">ccell</a> **out0, const <a class="el" href="structcspcell.html">cspcell</a> *A, const dcomplex f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert transpose of sparse cell to dense matrix cell: out0=out0+full(A')*alpha.  <a href="#d0ea8b24ff5f244861b568b7687c8f44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#288e4b42b14730697afd467bd73bf589">cspadd2</a> (<a class="el" href="structcsp.html">csp</a> *A, <a class="el" href="structcsp.html">csp</a> *B, dcomplex a, dcomplex b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Added two sparse matrices: return A*a+B*b.  <a href="#288e4b42b14730697afd467bd73bf589"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#2425634b2e026e5beb40d3e32dbf05a2">cspadd</a> (<a class="el" href="structcsp.html">csp</a> **A0, const <a class="el" href="structcsp.html">csp</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a sparse matrix to another: A0=A0+B.  <a href="#2425634b2e026e5beb40d3e32dbf05a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#11639654ba4aaeea701ad44343239714">cspcelladd</a> (<a class="el" href="structcspcell.html">cspcell</a> **A0, const <a class="el" href="structcspcell.html">cspcell</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a sparse cell to another: A0=A0+B.  <a href="#11639654ba4aaeea701ad44343239714"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#4e8ad98868cebc40355db0ab961814a8">cspaddI</a> (<a class="el" href="structcsp.html">csp</a> **A0, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add alpha times identity to a sparse matrix.  <a href="#4e8ad98868cebc40355db0ab961814a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#260982724b4c9ce3ae3710a75e09df36">cspcelladdI</a> (<a class="el" href="structcspcell.html">cspcell</a> *A0, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add alpha times identity to sparse array.  <a href="#260982724b4c9ce3ae3710a75e09df36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#7c380d6d6ef6d0965e5a35fd4b7ce680">csptrans</a> (const <a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose a sparse array.  <a href="#7c380d6d6ef6d0965e5a35fd4b7ce680"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#1334089c91c23cfe696e5ebfdce273dd">cspmulsp</a> (const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcsp.html">csp</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two sparse arrays: return A*B.  <a href="#1334089c91c23cfe696e5ebfdce273dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#b7e0a8ab070321e84b17ac255ffd8844">csptmulsp</a> (const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcsp.html">csp</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply the transpose of a sparse with another: return A'*B.  <a href="#b7e0a8ab070321e84b17ac255ffd8844"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#1e65a4b563b95329539de9aa99639321">cspmulsp2</a> (<a class="el" href="structcsp.html">csp</a> **C0, const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcsp.html">csp</a> *B, const dcomplex scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two sparse arrays and add to the third: C0=C0+A*B*scale.  <a href="#1e65a4b563b95329539de9aa99639321"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#49dcac88c7db4779a830c7fada6f3cc0">cspcellmulspcell</a> (const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structcspcell.html">cspcell</a> *B, const dcomplex scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two sparse cell.  <a href="#49dcac88c7db4779a830c7fada6f3cc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#0116948f7f49876ec550f83d52527708">cspcellnew</a> (const long nx, const long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new sparse cell.  <a href="#0116948f7f49876ec550f83d52527708"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#505b38d31765196007662b0cc2aaa796">cspcelltrans</a> (const <a class="el" href="structcspcell.html">cspcell</a> *spc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose a sparse cell.  <a href="#505b38d31765196007662b0cc2aaa796"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#81ac17cb4a76babb27068e2441fef625">cspcellfree_do</a> (<a class="el" href="structcspcell.html">cspcell</a> *spc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a sparse cell data.  <a href="#81ac17cb4a76babb27068e2441fef625"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#8789fe1e884e000a6113f62f0e9d2e63">cspcat</a> (const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcsp.html">csp</a> *B, int type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate two sparse array along dim dimension.  <a href="#8789fe1e884e000a6113f62f0e9d2e63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#3b682ec0e120632c083d6e9f5b40a2b3">cspcell2sp</a> (const <a class="el" href="structcspcell.html">cspcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> to sparse array.  <a href="#3b682ec0e120632c083d6e9f5b40a2b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#a3836f4b5764c618db758467cdd24a62">cspsum</a> (const <a class="el" href="structcsp.html">csp</a> *A, int col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sum elements of sparse array along dimension dim.  <a href="#a3836f4b5764c618db758467cdd24a62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#fb8a40bc13c4f0c04b1a1431e7d1a5b5">cspsumabs</a> (const <a class="el" href="structcsp.html">csp</a> *A, int col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sum abs of elements of sparse array along dimension dim.  <a href="#fb8a40bc13c4f0c04b1a1431e7d1a5b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#15d688b55bb9b7ef506cad3f5ccfb772">cspclean</a> (<a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clean up a sparse array by dropping zeros.  <a href="#15d688b55bb9b7ef506cad3f5ccfb772"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#d212aea4c404ea3b85aa820a02f2fe78">cspcellmulvec</a> (dcomplex *restrict yc, const <a class="el" href="structcspcell.html">cspcell</a> *Ac, const dcomplex *restrict xc, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with vectors.  <a href="#d212aea4c404ea3b85aa820a02f2fe78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#de98f70161730502163dbc410cb5740a">cspdropeps</a> (<a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop elements that are EPS times the largest value.  <a href="#de98f70161730502163dbc410cb5740a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#0fbab7792a907baf7e26798089f67fda">cspcelldropeps</a> (<a class="el" href="structcspcell.html">cspcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop elements that are EPS times the largest value.  <a href="#0fbab7792a907baf7e26798089f67fda"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#6fc1f2acedbe1173af2194167055a1dd">cspsort</a> (<a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make sure the elements are sorted correctly.  <a href="#6fc1f2acedbe1173af2194167055a1dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#6b8d5e45b17827f0ae65b1ced936b49d">cspcellsort</a> (<a class="el" href="structcspcell.html">cspcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make sure the elements are sorted correctly.  <a href="#6b8d5e45b17827f0ae65b1ced936b49d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#f1f35ec3c6167455751a8b1a74f35b99">cspsym</a> (<a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">symmetricize a X(sp) matrix and drop values below a threshold.  <a href="#f1f35ec3c6167455751a8b1a74f35b99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#63805c61c7ce831fc8255368cdcd4b71">cspcellsym</a> (<a class="el" href="structcspcell.html">cspcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">symmetricize a X(sp) cell and drop values below a threshold.  <a href="#63805c61c7ce831fc8255368cdcd4b71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#293ebbfa0acf47f8783a3493966ad4ba">cspconvolvop</a> (<a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a X(sp) convolution operator C with C(i,j)=A(i-j); A must be very X(sp) with only a view non-zero value otherwise C will be too full.  <a href="#293ebbfa0acf47f8783a3493966ad4ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#f6059c535e9ed5cdff0c4974dd077c6f">cspperm</a> (<a class="el" href="structcsp.html">csp</a> *A, int reverse, long *pcol, long *prow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Permute rows and columns of X(sp) matrix A;.  <a href="#f6059c535e9ed5cdff0c4974dd077c6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#ae348f4ec8480c2f9ad28bf5c7091bd9">cspinvbdiag</a> (const <a class="el" href="structcsp.html">csp</a> *A, long bs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invert a SPD X(sp) matrix that is block diagonal with block sizes of bs.  <a href="#ae348f4ec8480c2f9ad28bf5c7091bd9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#cecaf203a653ac718dd234bf7119e580">cspblockextract</a> (const <a class="el" href="structcsp.html">csp</a> *A, long bs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extrat the diagonal blocks of size bs into cell arrays.  <a href="#cecaf203a653ac718dd234bf7119e580"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Contains functions for complex sparse <a class="el" href="structcsp.html" title="a sparse array of double complex numbers stored in compressed column format">csp</a>. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="c487a2b9ebd0931e631626a37965fd24"></a><!-- doxytag: member="csp.h::cspnew" ref="c487a2b9ebd0931e631626a37965fd24" args="(long nx, long ny, long nzmax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspnew           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nzmax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a nx*ny X(sp) matrix with memory for nmax max elements allocated. 
<p>

</div>
</div><p>
<a class="anchor" name="80f3f0a59125204877db212a85e8c6c7"></a><!-- doxytag: member="csp.h::cspref" ref="80f3f0a59125204877db212a85e8c6c7" args="(csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspref           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reference a sparse object. 
<p>

</div>
</div><p>
<a class="anchor" name="6f0c670abe3c96cce9afb0f0e733b350"></a><!-- doxytag: member="csp.h::cspdup" ref="6f0c670abe3c96cce9afb0f0e733b350" args="(const csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspdup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy a X(sp) matrix to another. 
<p>

</div>
</div><p>
<a class="anchor" name="978de1ab5d2901e086f61668140f7339"></a><!-- doxytag: member="csp.h::cspmove" ref="978de1ab5d2901e086f61668140f7339" args="(csp *A, csp *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmove           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
move the matrix from res to A. 
<p>

</div>
</div><p>
<a class="anchor" name="ba26181f356f45e0c66bb677a6c32698"></a><!-- doxytag: member="csp.h::cspnew2" ref="ba26181f356f45e0c66bb677a6c32698" args="(const csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspnew2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(sp) matrix of the same size as A. 
<p>

</div>
</div><p>
<a class="anchor" name="44da99a2eead0d399880a17533e36b2b"></a><!-- doxytag: member="csp.h::cspnewrandu" ref="44da99a2eead0d399880a17533e36b2b" args="(int nx, int ny, const dcomplex mean, double fill, rand_t *rstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspnewrandu           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmt__state.html">rand_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rstat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(sp) matrix and fill in uniform random numbers with filling factor of 'fill'. 
<p>

</div>
</div><p>
<a class="anchor" name="0f62850af8a0a48f2cc063bf95df8856"></a><!-- doxytag: member="csp.h::cspsetnzmax" ref="0f62850af8a0a48f2cc063bf95df8856" args="(csp *sp, long nzmax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspsetnzmax           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nzmax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
resize a X(sp) matrix 
<p>

</div>
</div><p>
<a class="anchor" name="4ae0a8c3586b6bc85cc273b3217b2db4"></a><!-- doxytag: member="csp.h::cspfree_do" ref="4ae0a8c3586b6bc85cc273b3217b2db4" args="(csp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(sp) matrix 
<p>

</div>
</div><p>
<a class="anchor" name="d23c83475ff51aac1ee3fc9aaa58d490"></a><!-- doxytag: member="csp.h::csparrfree" ref="d23c83475ff51aac1ee3fc9aaa58d490" args="(csp **sparr, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csparrfree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> **&nbsp;</td>
          <td class="paramname"> <em>sparr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(sp) array 
<p>

</div>
</div><p>
<a class="anchor" name="dc5754766a10048b0412d4fd7d6d4f21"></a><!-- doxytag: member="csp.h::cspdisp" ref="dc5754766a10048b0412d4fd7d6d4f21" args="(const csp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspdisp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Display a X(sp) array. 
<p>

</div>
</div><p>
<a class="anchor" name="da6187466a85d6d4471143963d1a0b35"></a><!-- doxytag: member="csp.h::cspcheck" ref="da6187466a85d6d4471143963d1a0b35" args="(const csp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcheck           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check a X(sp) array for wrong orders. 
<p>

</div>
</div><p>
<a class="anchor" name="dd8d261f3e339da0ae0b34f77c49efe5"></a><!-- doxytag: member="csp.h::cspscale" ref="dd8d261f3e339da0ae0b34f77c49efe5" args="(csp *A, const dcomplex beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace scale X(sp) matrix elements. 
<p>

</div>
</div><p>
<a class="anchor" name="abcc5d0cae60d4f3dc19a6c3465a873e"></a><!-- doxytag: member="csp.h::cspcellscale" ref="abcc5d0cae60d4f3dc19a6c3465a873e" args="(cspcell *A, const dcomplex beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace scale a X(spcell) object 
<p>

</div>
</div><p>
<a class="anchor" name="1cb1312e34d6d65db22b2277ef34080c"></a><!-- doxytag: member="csp.h::cspnewdiag" ref="1cb1312e34d6d65db22b2277ef34080c" args="(long N, dcomplex *vec, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspnewdiag           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex *&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new sparse matrix with diagonal elements set to vec*alpha. 
<p>

</div>
</div><p>
<a class="anchor" name="78a7b8edb5848dbeefb21d3f04eb66e6"></a><!-- doxytag: member="csp.h::cspdiag" ref="78a7b8edb5848dbeefb21d3f04eb66e6" args="(const csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cspdiag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract diagonal element of A and return. 
<p>

</div>
</div><p>
<a class="anchor" name="41e52911fa532cd4d5651e2a9c75e91d"></a><!-- doxytag: member="csp.h::cspmuldiag" ref="41e52911fa532cd4d5651e2a9c75e91d" args="(csp *restrict A, const dcomplex *w, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmuldiag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a X(sp) matrix inplace with a diagonal weighting matrix whose diagonal values are stored in w. 
<p>
W_ii=w_i; W_ij=0 if i!=j A=A*W*alpha; W is a diagonal X(sp) matrix. diag(W) is w multiply w[i] to all numbers in column[i] 
</div>
</div><p>
<a class="anchor" name="8e28cfb4fabbf2ca0080e55d488304a3"></a><!-- doxytag: member="csp.h::cspmulvec_thread" ref="8e28cfb4fabbf2ca0080e55d488304a3" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, dcomplex alpha, int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmulvec_thread           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a sparse with a vector using multithread. 
<p>
Speed up is not signicant because need to allocate new memory. 
</div>
</div><p>
<a class="anchor" name="54fc8f015cdea3064a1dd4d404e428c1"></a><!-- doxytag: member="csp.h::cspmulvec" ref="54fc8f015cdea3064a1dd4d404e428c1" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmulvec           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
sparse matrix multiply with a vector 
<p>

</div>
</div><p>
<a class="anchor" name="9a5940fca0abf0d7876eafd923bc78e9"></a><!-- doxytag: member="csp.h::cspmulcreal" ref="9a5940fca0abf0d7876eafd923bc78e9" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmulcreal           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a sparse matrix with the real part of a complex vector. 
<p>

</div>
</div><p>
<a class="anchor" name="ae38da51fa42e1dba34308f3e27b068b"></a><!-- doxytag: member="csp.h::csptmulvec" ref="ae38da51fa42e1dba34308f3e27b068b" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptmulvec           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply transpose of a sparse matrix with a vector. 
<p>

</div>
</div><p>
<a class="anchor" name="9c9f61dd9e10e0a18545069dd3a493bb"></a><!-- doxytag: member="csp.h::csptmulvec_thread" ref="9c9f61dd9e10e0a18545069dd3a493bb" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, const dcomplex alpha, int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptmulvec_thread           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Threaded version of sptmulvec. 
<p>

</div>
</div><p>
<a class="anchor" name="979d62d76e351b60cb8ce8f270a1b866"></a><!-- doxytag: member="csp.h::cspmulmat" ref="979d62d76e351b60cb8ce8f270a1b866" args="(cmat **yout, const csp *A, const cmat *x, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a sparse matrix X(sp) with a dense matrix X(mat). 
<p>

</div>
</div><p>
<a class="anchor" name="d33258da06cc2612c4c7c66e5af5306b"></a><!-- doxytag: member="csp.h::csptmulmat" ref="d33258da06cc2612c4c7c66e5af5306b" args="(cmat **yout, const csp *A, const cmat *x, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
y=y+alpha*A'*x; 
<p>

</div>
</div><p>
<a class="anchor" name="084a73490868acd8a291793aabbad3a5"></a><!-- doxytag: member="csp.h::cspwdinn" ref="084a73490868acd8a291793aabbad3a5" args="(const cmat *y, const csp *A, const cmat *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cspwdinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two matrices with weighting by sparse matrix. 
<p>
return y'*(A*x) 
</div>
</div><p>
<a class="anchor" name="d52ad07f584725c01825cd2e1fa38724"></a><!-- doxytag: member="csp.h::cspcellwdinn" ref="d52ad07f584725c01825cd2e1fa38724" args="(const ccell *y, const cspcell *A, const ccell *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cspcellwdinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two cell arrays with weighting by sparse matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="e0baf2d188be6beae581db14384e88d1"></a><!-- doxytag: member="csp.h::cspcellmulmat" ref="e0baf2d188be6beae581db14384e88d1" args="(ccell **C, const cspcell *A, const ccell *B, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with a dense cell: C=C+A*B*alpha. 
<p>

</div>
</div><p>
<a class="anchor" name="2ae96154a8e626b25e038fda1af50032"></a><!-- doxytag: member="csp.h::csptcellmulmat" ref="2ae96154a8e626b25e038fda1af50032" args="(ccell **C, const cspcell *A, const ccell *B, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptcellmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
C=C+A'*B*alpha. 
<p>

</div>
</div><p>
<a class="anchor" name="55b1761ed410406c557bf8e650aa5f61"></a><!-- doxytag: member="csp.h::cspcellmulmat_thread" ref="55b1761ed410406c557bf8e650aa5f61" args="(ccell **C, const cspcell *A, const ccell *B, const dcomplex alpha, const int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellmulmat_thread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
threaded version of Y(spcellmulmat) 
<p>

</div>
</div><p>
<a class="anchor" name="2016cdf467cae24f45f30eb7cd4c236b"></a><!-- doxytag: member="csp.h::csptcellmulmat_thread" ref="2016cdf467cae24f45f30eb7cd4c236b" args="(ccell **C, const cspcell *A, const ccell *B, const dcomplex alpha, const int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptcellmulmat_thread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
threaded version of Y(sptcellmulmat 
<p>

</div>
</div><p>
<a class="anchor" name="7a8a319c9dcfc015746e77a9899bea5a"></a><!-- doxytag: member="csp.h::cspcellmulmat_each" ref="7a8a319c9dcfc015746e77a9899bea5a" args="(ccell **xout, cspcell *A, ccell *xin, dcomplex alpha, int trans, int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellmulmat_each           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>xout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>xin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Threaded multiply each cell in <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with each cell in <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="6644c43d1ac2abf3b7767935a5e2ab46"></a><!-- doxytag: member="csp.h::cspfull" ref="6644c43d1ac2abf3b7767935a5e2ab46" args="(cmat **out0, const csp *A, const dcomplex f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert sparse matrix into dense matrix and add to output: out0=out0+full(A)*alpha. 
<p>

</div>
</div><p>
<a class="anchor" name="b2e5c232a1e67f54840d0d8da97bfbfc"></a><!-- doxytag: member="csp.h::csptfull" ref="b2e5c232a1e67f54840d0d8da97bfbfc" args="(cmat **out0, const csp *A, const dcomplex f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the transpose of a sparse matrix into dense matrix and add to output: out0=out0+full(A')*alpha;. 
<p>

</div>
</div><p>
<a class="anchor" name="7b859f635f4fd699e4b703f64bf57890"></a><!-- doxytag: member="csp.h::cspcellfull" ref="7b859f635f4fd699e4b703f64bf57890" args="(ccell **out0, const cspcell *A, const dcomplex f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert sparse cell to dense matrix cell: out0=out0+full(A)*alpha. 
<p>

</div>
</div><p>
<a class="anchor" name="d0ea8b24ff5f244861b568b7687c8f44"></a><!-- doxytag: member="csp.h::csptcellfull" ref="d0ea8b24ff5f244861b568b7687c8f44" args="(ccell **out0, const cspcell *A, const dcomplex f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptcellfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert transpose of sparse cell to dense matrix cell: out0=out0+full(A')*alpha. 
<p>

</div>
</div><p>
<a class="anchor" name="288e4b42b14730697afd467bd73bf589"></a><!-- doxytag: member="csp.h::cspadd2" ref="288e4b42b14730697afd467bd73bf589" args="(csp *A, csp *B, dcomplex a, dcomplex b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspadd2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Added two sparse matrices: return A*a+B*b. 
<p>

</div>
</div><p>
<a class="anchor" name="2425634b2e026e5beb40d3e32dbf05a2"></a><!-- doxytag: member="csp.h::cspadd" ref="2425634b2e026e5beb40d3e32dbf05a2" args="(csp **A0, const csp *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspadd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a sparse matrix to another: A0=A0+B. 
<p>

</div>
</div><p>
<a class="anchor" name="11639654ba4aaeea701ad44343239714"></a><!-- doxytag: member="csp.h::cspcelladd" ref="11639654ba4aaeea701ad44343239714" args="(cspcell **A0, const cspcell *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcelladd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a sparse cell to another: A0=A0+B. 
<p>

</div>
</div><p>
<a class="anchor" name="4e8ad98868cebc40355db0ab961814a8"></a><!-- doxytag: member="csp.h::cspaddI" ref="4e8ad98868cebc40355db0ab961814a8" args="(csp **A0, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspaddI           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add alpha times identity to a sparse matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="260982724b4c9ce3ae3710a75e09df36"></a><!-- doxytag: member="csp.h::cspcelladdI" ref="260982724b4c9ce3ae3710a75e09df36" args="(cspcell *A0, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcelladdI           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add alpha times identity to sparse array. 
<p>

</div>
</div><p>
<a class="anchor" name="7c380d6d6ef6d0965e5a35fd4b7ce680"></a><!-- doxytag: member="csp.h::csptrans" ref="7c380d6d6ef6d0965e5a35fd4b7ce680" args="(const csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* csptrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transpose a sparse array. 
<p>

</div>
</div><p>
<a class="anchor" name="1334089c91c23cfe696e5ebfdce273dd"></a><!-- doxytag: member="csp.h::cspmulsp" ref="1334089c91c23cfe696e5ebfdce273dd" args="(const csp *A, const csp *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspmulsp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two sparse arrays: return A*B. 
<p>

</div>
</div><p>
<a class="anchor" name="b7e0a8ab070321e84b17ac255ffd8844"></a><!-- doxytag: member="csp.h::csptmulsp" ref="b7e0a8ab070321e84b17ac255ffd8844" args="(const csp *A, const csp *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* csptmulsp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply the transpose of a sparse with another: return A'*B. 
<p>

</div>
</div><p>
<a class="anchor" name="1e65a4b563b95329539de9aa99639321"></a><!-- doxytag: member="csp.h::cspmulsp2" ref="1e65a4b563b95329539de9aa99639321" args="(csp **C0, const csp *A, const csp *B, const dcomplex scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmulsp2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> **&nbsp;</td>
          <td class="paramname"> <em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two sparse arrays and add to the third: C0=C0+A*B*scale. 
<p>

</div>
</div><p>
<a class="anchor" name="49dcac88c7db4779a830c7fada6f3cc0"></a><!-- doxytag: member="csp.h::cspcellmulspcell" ref="49dcac88c7db4779a830c7fada6f3cc0" args="(const cspcell *A, const cspcell *B, const dcomplex scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcspcell.html">cspcell</a>* cspcellmulspcell           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two sparse cell. 
<p>

</div>
</div><p>
<a class="anchor" name="0116948f7f49876ec550f83d52527708"></a><!-- doxytag: member="csp.h::cspcellnew" ref="0116948f7f49876ec550f83d52527708" args="(const long nx, const long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcspcell.html">cspcell</a>* cspcellnew           </td>
          <td>(</td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new sparse cell. 
<p>

</div>
</div><p>
<a class="anchor" name="505b38d31765196007662b0cc2aaa796"></a><!-- doxytag: member="csp.h::cspcelltrans" ref="505b38d31765196007662b0cc2aaa796" args="(const cspcell *spc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcspcell.html">cspcell</a>* cspcelltrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>spc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transpose a sparse cell. 
<p>

</div>
</div><p>
<a class="anchor" name="81ac17cb4a76babb27068e2441fef625"></a><!-- doxytag: member="csp.h::cspcellfree_do" ref="81ac17cb4a76babb27068e2441fef625" args="(cspcell *spc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>spc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a sparse cell data. 
<p>

</div>
</div><p>
<a class="anchor" name="8789fe1e884e000a6113f62f0e9d2e63"></a><!-- doxytag: member="csp.h::cspcat" ref="8789fe1e884e000a6113f62f0e9d2e63" args="(const csp *A, const csp *B, int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspcat           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenate two sparse array along dim dimension. 
<p>

</div>
</div><p>
<a class="anchor" name="3b682ec0e120632c083d6e9f5b40a2b3"></a><!-- doxytag: member="csp.h::cspcell2sp" ref="3b682ec0e120632c083d6e9f5b40a2b3" args="(const cspcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspcell2sp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenate a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> to sparse array. 
<p>

</div>
</div><p>
<a class="anchor" name="a3836f4b5764c618db758467cdd24a62"></a><!-- doxytag: member="csp.h::cspsum" ref="a3836f4b5764c618db758467cdd24a62" args="(const csp *A, int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cspsum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sum elements of sparse array along dimension dim. 
<p>

</div>
</div><p>
<a class="anchor" name="fb8a40bc13c4f0c04b1a1431e7d1a5b5"></a><!-- doxytag: member="csp.h::cspsumabs" ref="fb8a40bc13c4f0c04b1a1431e7d1a5b5" args="(const csp *A, int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cspsumabs           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sum abs of elements of sparse array along dimension dim. 
<p>

</div>
</div><p>
<a class="anchor" name="15d688b55bb9b7ef506cad3f5ccfb772"></a><!-- doxytag: member="csp.h::cspclean" ref="15d688b55bb9b7ef506cad3f5ccfb772" args="(csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspclean           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clean up a sparse array by dropping zeros. 
<p>

</div>
</div><p>
<a class="anchor" name="d212aea4c404ea3b85aa820a02f2fe78"></a><!-- doxytag: member="csp.h::cspcellmulvec" ref="d212aea4c404ea3b85aa820a02f2fe78" args="(dcomplex *restrict yc, const cspcell *Ac, const dcomplex *restrict xc, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellmulvec           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>yc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>Ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>xc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with vectors. 
<p>

</div>
</div><p>
<a class="anchor" name="de98f70161730502163dbc410cb5740a"></a><!-- doxytag: member="csp.h::cspdropeps" ref="de98f70161730502163dbc410cb5740a" args="(csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspdropeps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drop elements that are EPS times the largest value. 
<p>

</div>
</div><p>
<a class="anchor" name="0fbab7792a907baf7e26798089f67fda"></a><!-- doxytag: member="csp.h::cspcelldropeps" ref="0fbab7792a907baf7e26798089f67fda" args="(cspcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcelldropeps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drop elements that are EPS times the largest value. 
<p>

</div>
</div><p>
<a class="anchor" name="6fc1f2acedbe1173af2194167055a1dd"></a><!-- doxytag: member="csp.h::cspsort" ref="6fc1f2acedbe1173af2194167055a1dd" args="(csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspsort           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make sure the elements are sorted correctly. 
<p>
Does not change the location of data. can be done without harm. 
</div>
</div><p>
<a class="anchor" name="6b8d5e45b17827f0ae65b1ced936b49d"></a><!-- doxytag: member="csp.h::cspcellsort" ref="6b8d5e45b17827f0ae65b1ced936b49d" args="(cspcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellsort           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make sure the elements are sorted correctly. 
<p>

</div>
</div><p>
<a class="anchor" name="f1f35ec3c6167455751a8b1a74f35b99"></a><!-- doxytag: member="csp.h::cspsym" ref="f1f35ec3c6167455751a8b1a74f35b99" args="(csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspsym           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
symmetricize a X(sp) matrix and drop values below a threshold. 
<p>

</div>
</div><p>
<a class="anchor" name="63805c61c7ce831fc8255368cdcd4b71"></a><!-- doxytag: member="csp.h::cspcellsym" ref="63805c61c7ce831fc8255368cdcd4b71" args="(cspcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellsym           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
symmetricize a X(sp) cell and drop values below a threshold. 
<p>

</div>
</div><p>
<a class="anchor" name="293ebbfa0acf47f8783a3493966ad4ba"></a><!-- doxytag: member="csp.h::cspconvolvop" ref="293ebbfa0acf47f8783a3493966ad4ba" args="(cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspconvolvop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a X(sp) convolution operator C with C(i,j)=A(i-j); A must be very X(sp) with only a view non-zero value otherwise C will be too full. 
<p>

</div>
</div><p>
<a class="anchor" name="f6059c535e9ed5cdff0c4974dd077c6f"></a><!-- doxytag: member="csp.h::cspperm" ref="f6059c535e9ed5cdff0c4974dd077c6f" args="(csp *A, int reverse, long *pcol, long *prow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspperm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>pcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>prow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Permute rows and columns of X(sp) matrix A;. 
<p>

</div>
</div><p>
<a class="anchor" name="ae348f4ec8480c2f9ad28bf5c7091bd9"></a><!-- doxytag: member="csp.h::cspinvbdiag" ref="ae348f4ec8480c2f9ad28bf5c7091bd9" args="(const csp *A, long bs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspinvbdiag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>bs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invert a SPD X(sp) matrix that is block diagonal with block sizes of bs. 
<p>

</div>
</div><p>
<a class="anchor" name="cecaf203a653ac718dd234bf7119e580"></a><!-- doxytag: member="csp.h::cspblockextract" ref="cecaf203a653ac718dd234bf7119e580" args="(const csp *A, long bs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* cspblockextract           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>bs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extrat the diagonal blocks of size bs into cell arrays. 
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Nov 24 14:46:54 2010 for maos-0.7.5 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
