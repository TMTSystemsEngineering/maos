<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>maos-0.6.4: lib/csp.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lib/csp.h File Reference</h1>Contains functions for complex sparse <a class="el" href="structcsp.html" title="a sparse array of double complex numbers stored in compressed column format">csp</a>.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#c487a2b9ebd0931e631626a37965fd24">cspnew</a> (long nx, long ny, long nzmax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a nx*ny X(sp) matrix with memory for nmax max elements allocated.  <a href="#c487a2b9ebd0931e631626a37965fd24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#80f3f0a59125204877db212a85e8c6c7">cspref</a> (<a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reference a sparse object.  <a href="#80f3f0a59125204877db212a85e8c6c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#6f0c670abe3c96cce9afb0f0e733b350">cspdup</a> (const <a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy a X(sp) matrix to another.  <a href="#6f0c670abe3c96cce9afb0f0e733b350"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#978de1ab5d2901e086f61668140f7339">cspmove</a> (<a class="el" href="structcsp.html">csp</a> *A, <a class="el" href="structcsp.html">csp</a> *res)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">move the matrix from res to A.  <a href="#978de1ab5d2901e086f61668140f7339"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#ba26181f356f45e0c66bb677a6c32698">cspnew2</a> (const <a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(sp) matrix of the same size as A.  <a href="#ba26181f356f45e0c66bb677a6c32698"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#491f95a564ed7edeb3ed3c2bc8c76575">cspnewrandu</a> (int nx, int ny, const dcomplex mean, double fill, <a class="el" href="structmt__state.html">mt_state</a> *rstat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(sp) matrix and fill in uniform random numbers with filling factor of 'fill'.  <a href="#491f95a564ed7edeb3ed3c2bc8c76575"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#0f62850af8a0a48f2cc063bf95df8856">cspsetnzmax</a> (<a class="el" href="structcsp.html">csp</a> *sp, long nzmax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">resize a X(sp) matrix  <a href="#0f62850af8a0a48f2cc063bf95df8856"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#4ae0a8c3586b6bc85cc273b3217b2db4">cspfree_do</a> (<a class="el" href="structcsp.html">csp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(sp) matrix  <a href="#4ae0a8c3586b6bc85cc273b3217b2db4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#d23c83475ff51aac1ee3fc9aaa58d490">csparrfree</a> (<a class="el" href="structcsp.html">csp</a> **sparr, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(sp) array  <a href="#d23c83475ff51aac1ee3fc9aaa58d490"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#dc5754766a10048b0412d4fd7d6d4f21">cspdisp</a> (const <a class="el" href="structcsp.html">csp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display a X(sp) array.  <a href="#dc5754766a10048b0412d4fd7d6d4f21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#da6187466a85d6d4471143963d1a0b35">cspcheck</a> (const <a class="el" href="structcsp.html">csp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check a X(sp) array for wrong orders.  <a href="#da6187466a85d6d4471143963d1a0b35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#dd8d261f3e339da0ae0b34f77c49efe5">cspscale</a> (<a class="el" href="structcsp.html">csp</a> *A, const dcomplex beta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace scale X(sp) matrix elements.  <a href="#dd8d261f3e339da0ae0b34f77c49efe5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#abcc5d0cae60d4f3dc19a6c3465a873e">cspcellscale</a> (<a class="el" href="structcspcell.html">cspcell</a> *A, const dcomplex beta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace scale a X(spcell) object  <a href="#abcc5d0cae60d4f3dc19a6c3465a873e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#1cb1312e34d6d65db22b2277ef34080c">cspnewdiag</a> (long N, dcomplex *vec, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new sparse matrix with diagonal elements set to vec*alpha.  <a href="#1cb1312e34d6d65db22b2277ef34080c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#78a7b8edb5848dbeefb21d3f04eb66e6">cspdiag</a> (const <a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract diagonal element of A and return.  <a href="#78a7b8edb5848dbeefb21d3f04eb66e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#41e52911fa532cd4d5651e2a9c75e91d">cspmuldiag</a> (<a class="el" href="structcsp.html">csp</a> *restrict A, const dcomplex *w, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a X(sp) matrix inplace with a diagonal weighting matrix whose diagonal values are stored in w.  <a href="#41e52911fa532cd4d5651e2a9c75e91d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#8e28cfb4fabbf2ca0080e55d488304a3">cspmulvec_thread</a> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, dcomplex alpha, int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a sparse with a vector using multithread.  <a href="#8e28cfb4fabbf2ca0080e55d488304a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#54fc8f015cdea3064a1dd4d404e428c1">cspmulvec</a> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sparse matrix multiply with a vector  <a href="#54fc8f015cdea3064a1dd4d404e428c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d85c0b07b56612cbbbcea5fc0f34fa7c"></a><!-- doxytag: member="csp.h::cspmulvec_mkl" ref="d85c0b07b56612cbbbcea5fc0f34fa7c" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, dcomplex alpha)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>cspmulvec_mkl</b> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, dcomplex alpha)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#9a5940fca0abf0d7876eafd923bc78e9">cspmulcreal</a> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a sparse matrix with the real part of a complex vector.  <a href="#9a5940fca0abf0d7876eafd923bc78e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#ae38da51fa42e1dba34308f3e27b068b">csptmulvec</a> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply transpose of a sparse matrix with a vector.  <a href="#ae38da51fa42e1dba34308f3e27b068b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#9c9f61dd9e10e0a18545069dd3a493bb">csptmulvec_thread</a> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, const dcomplex alpha, int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Threaded version of sptmulvec.  <a href="#9c9f61dd9e10e0a18545069dd3a493bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#979d62d76e351b60cb8ce8f270a1b866">cspmulmat</a> (<a class="el" href="structcmat.html">cmat</a> **yout, const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcmat.html">cmat</a> *x, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a sparse matrix X(sp) with a dense matrix X(mat).  <a href="#979d62d76e351b60cb8ce8f270a1b866"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#d33258da06cc2612c4c7c66e5af5306b">csptmulmat</a> (<a class="el" href="structcmat.html">cmat</a> **yout, const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcmat.html">cmat</a> *x, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">y=y+alpha*A'*x;  <a href="#d33258da06cc2612c4c7c66e5af5306b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#084a73490868acd8a291793aabbad3a5">cspwdinn</a> (const <a class="el" href="structcmat.html">cmat</a> *y, const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcmat.html">cmat</a> *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two matrices with weighting by sparse matrix.  <a href="#084a73490868acd8a291793aabbad3a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#d52ad07f584725c01825cd2e1fa38724">cspcellwdinn</a> (const <a class="el" href="structccell.html">ccell</a> *y, const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structccell.html">ccell</a> *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two cell arrays with weighting by sparse matrix.  <a href="#d52ad07f584725c01825cd2e1fa38724"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#e0baf2d188be6beae581db14384e88d1">cspcellmulmat</a> (<a class="el" href="structccell.html">ccell</a> **C, const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with a dense cell: C=C+A*B*alpha.  <a href="#e0baf2d188be6beae581db14384e88d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#2ae96154a8e626b25e038fda1af50032">csptcellmulmat</a> (<a class="el" href="structccell.html">ccell</a> **C, const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C=C+A'*B*alpha.  <a href="#2ae96154a8e626b25e038fda1af50032"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#55b1761ed410406c557bf8e650aa5f61">cspcellmulmat_thread</a> (<a class="el" href="structccell.html">ccell</a> **C, const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, const dcomplex alpha, const int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">threaded version of Y(spcellmulmat)  <a href="#55b1761ed410406c557bf8e650aa5f61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#2016cdf467cae24f45f30eb7cd4c236b">csptcellmulmat_thread</a> (<a class="el" href="structccell.html">ccell</a> **C, const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, const dcomplex alpha, const int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">threaded version of Y(sptcellmulmat  <a href="#2016cdf467cae24f45f30eb7cd4c236b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#6644c43d1ac2abf3b7767935a5e2ab46">cspfull</a> (<a class="el" href="structcmat.html">cmat</a> **out0, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert sparse matrix into dense matrix and add to output: out0=out0+full(A)*alpha.  <a href="#6644c43d1ac2abf3b7767935a5e2ab46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#b2e5c232a1e67f54840d0d8da97bfbfc">csptfull</a> (<a class="el" href="structcmat.html">cmat</a> **out0, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the transpose of a sparse matrix into dense matrix and add to output: out0=out0+full(A')*alpha;.  <a href="#b2e5c232a1e67f54840d0d8da97bfbfc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#7b859f635f4fd699e4b703f64bf57890">cspcellfull</a> (<a class="el" href="structccell.html">ccell</a> **out0, const <a class="el" href="structcspcell.html">cspcell</a> *A, const dcomplex f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert sparse cell to dense matrix cell: out0=out0+full(A)*alpha.  <a href="#7b859f635f4fd699e4b703f64bf57890"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#d0ea8b24ff5f244861b568b7687c8f44">csptcellfull</a> (<a class="el" href="structccell.html">ccell</a> **out0, const <a class="el" href="structcspcell.html">cspcell</a> *A, const dcomplex f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert transpose of sparse cell to dense matrix cell: out0=out0+full(A')*alpha.  <a href="#d0ea8b24ff5f244861b568b7687c8f44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#288e4b42b14730697afd467bd73bf589">cspadd2</a> (<a class="el" href="structcsp.html">csp</a> *A, <a class="el" href="structcsp.html">csp</a> *B, dcomplex a, dcomplex b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Added two sparse matrices: return A*a+B*b.  <a href="#288e4b42b14730697afd467bd73bf589"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#2425634b2e026e5beb40d3e32dbf05a2">cspadd</a> (<a class="el" href="structcsp.html">csp</a> **A0, const <a class="el" href="structcsp.html">csp</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a sparse matrix to another: A0=A0+B.  <a href="#2425634b2e026e5beb40d3e32dbf05a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#11639654ba4aaeea701ad44343239714">cspcelladd</a> (<a class="el" href="structcspcell.html">cspcell</a> **A0, const <a class="el" href="structcspcell.html">cspcell</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a sparse cell to another: A0=A0+B.  <a href="#11639654ba4aaeea701ad44343239714"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#7c380d6d6ef6d0965e5a35fd4b7ce680">csptrans</a> (const <a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose a sparse array.  <a href="#7c380d6d6ef6d0965e5a35fd4b7ce680"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#1334089c91c23cfe696e5ebfdce273dd">cspmulsp</a> (const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcsp.html">csp</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two sparse arrays: return A*B.  <a href="#1334089c91c23cfe696e5ebfdce273dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#b7e0a8ab070321e84b17ac255ffd8844">csptmulsp</a> (const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcsp.html">csp</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply the transpose of a sparse with another: return A'*B.  <a href="#b7e0a8ab070321e84b17ac255ffd8844"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#1e65a4b563b95329539de9aa99639321">cspmulsp2</a> (<a class="el" href="structcsp.html">csp</a> **C0, const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcsp.html">csp</a> *B, const dcomplex scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two sparse arrays and add to the third: C0=C0+A*B*scale.  <a href="#1e65a4b563b95329539de9aa99639321"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#49dcac88c7db4779a830c7fada6f3cc0">cspcellmulspcell</a> (const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structcspcell.html">cspcell</a> *B, const dcomplex scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two sparse cell.  <a href="#49dcac88c7db4779a830c7fada6f3cc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#0116948f7f49876ec550f83d52527708">cspcellnew</a> (const long nx, const long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new sparse cell.  <a href="#0116948f7f49876ec550f83d52527708"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#505b38d31765196007662b0cc2aaa796">cspcelltrans</a> (const <a class="el" href="structcspcell.html">cspcell</a> *spc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose a sparse cell.  <a href="#505b38d31765196007662b0cc2aaa796"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#81ac17cb4a76babb27068e2441fef625">cspcellfree_do</a> (<a class="el" href="structcspcell.html">cspcell</a> *spc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a sparse cell data.  <a href="#81ac17cb4a76babb27068e2441fef625"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#8789fe1e884e000a6113f62f0e9d2e63">cspcat</a> (const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcsp.html">csp</a> *B, int type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate two sparse array along dim dimension.  <a href="#8789fe1e884e000a6113f62f0e9d2e63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#3b682ec0e120632c083d6e9f5b40a2b3">cspcell2sp</a> (const <a class="el" href="structcspcell.html">cspcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> to sparse array.  <a href="#3b682ec0e120632c083d6e9f5b40a2b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#a3836f4b5764c618db758467cdd24a62">cspsum</a> (const <a class="el" href="structcsp.html">csp</a> *A, int col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sum elements of sparse array along dimension dim.  <a href="#a3836f4b5764c618db758467cdd24a62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#fb8a40bc13c4f0c04b1a1431e7d1a5b5">cspsumabs</a> (const <a class="el" href="structcsp.html">csp</a> *A, int col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sum abs of elements of sparse array along dimension dim.  <a href="#fb8a40bc13c4f0c04b1a1431e7d1a5b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="15d688b55bb9b7ef506cad3f5ccfb772"></a><!-- doxytag: member="csp.h::cspclean" ref="15d688b55bb9b7ef506cad3f5ccfb772" args="(csp *A)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>cspclean</b> (<a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#d212aea4c404ea3b85aa820a02f2fe78">cspcellmulvec</a> (dcomplex *restrict yc, const <a class="el" href="structcspcell.html">cspcell</a> *Ac, const dcomplex *restrict xc, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with vectors.  <a href="#d212aea4c404ea3b85aa820a02f2fe78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#de98f70161730502163dbc410cb5740a">cspdropeps</a> (<a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop elements that are EPS times the largest value.  <a href="#de98f70161730502163dbc410cb5740a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#0fbab7792a907baf7e26798089f67fda">cspcelldropeps</a> (<a class="el" href="structcspcell.html">cspcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop elements that are EPS times the largest value.  <a href="#0fbab7792a907baf7e26798089f67fda"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#6fc1f2acedbe1173af2194167055a1dd">cspsort</a> (<a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make sure the elements are sorted correctly.  <a href="#6fc1f2acedbe1173af2194167055a1dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#6b8d5e45b17827f0ae65b1ced936b49d">cspcellsort</a> (<a class="el" href="structcspcell.html">cspcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make sure the elements are sorted correctly.  <a href="#6b8d5e45b17827f0ae65b1ced936b49d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#f1f35ec3c6167455751a8b1a74f35b99">cspsym</a> (<a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">symmetricize a X(sp) matrix and drop values below a threshold.  <a href="#f1f35ec3c6167455751a8b1a74f35b99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#63805c61c7ce831fc8255368cdcd4b71">cspcellsym</a> (<a class="el" href="structcspcell.html">cspcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">symmetricize a X(sp) cell and drop values below a threshold.  <a href="#63805c61c7ce831fc8255368cdcd4b71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#293ebbfa0acf47f8783a3493966ad4ba">cspconvolvop</a> (<a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a X(sp) convolution operator C with C(i,j)=A(i-j); A must be very X(sp) with only a view non-zero value otherwise C will be too full.  <a href="#293ebbfa0acf47f8783a3493966ad4ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#f6059c535e9ed5cdff0c4974dd077c6f">cspperm</a> (<a class="el" href="structcsp.html">csp</a> *A, int reverse, long *pcol, long *prow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Permute rows and columns of X(sp) matrix A;.  <a href="#f6059c535e9ed5cdff0c4974dd077c6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#ae348f4ec8480c2f9ad28bf5c7091bd9">cspinvbdiag</a> (const <a class="el" href="structcsp.html">csp</a> *A, long bs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invert a SPD X(sp) matrix that is block diagonal with block sizes of bs.  <a href="#ae348f4ec8480c2f9ad28bf5c7091bd9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#cecaf203a653ac718dd234bf7119e580">cspblockextract</a> (const <a class="el" href="structcsp.html">csp</a> *A, long bs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extrat the diagonal blocks of size bs into cell arrays.  <a href="#cecaf203a653ac718dd234bf7119e580"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Contains functions for complex sparse <a class="el" href="structcsp.html" title="a sparse array of double complex numbers stored in compressed column format">csp</a>. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="c487a2b9ebd0931e631626a37965fd24"></a><!-- doxytag: member="csp.h::cspnew" ref="c487a2b9ebd0931e631626a37965fd24" args="(long nx, long ny, long nzmax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspnew           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nzmax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a nx*ny X(sp) matrix with memory for nmax max elements allocated. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03231"></a>03231                                              {
<a name="l03232"></a>03232 
<a name="l03233"></a>03233     X(sp) *sp;
<a name="l03234"></a>03234     sp = calloc(1, <span class="keyword">sizeof</span>(X(sp)));
<a name="l03235"></a>03235     <span class="keywordflow">if</span>(nzmax&gt;0){
<a name="l03236"></a>03236     sp-&gt;p=malloc((ny+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l03237"></a>03237     sp-&gt;i=malloc(nzmax*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l03238"></a>03238     sp-&gt;x=malloc(nzmax*<span class="keyword">sizeof</span>(T));
<a name="l03239"></a>03239     }
<a name="l03240"></a>03240     sp-&gt;m=nx;
<a name="l03241"></a>03241     sp-&gt;n=ny;
<a name="l03242"></a>03242     sp-&gt;nzmax=nzmax;
<a name="l03243"></a>03243     sp-&gt;nz=-1;
<a name="l03244"></a>03244     sp-&gt;nref=calloc(1,<span class="keyword">sizeof</span>(T));
<a name="l03245"></a>03245     sp-&gt;nref[0]=1;
<a name="l03246"></a>03246     <span class="keywordflow">return</span> sp;
<a name="l03247"></a>03247 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="80f3f0a59125204877db212a85e8c6c7"></a><!-- doxytag: member="csp.h::cspref" ref="80f3f0a59125204877db212a85e8c6c7" args="(csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspref           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reference a sparse object. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03252"></a>03252                          {
<a name="l03253"></a>03253     X(sp) *out = calloc(1, <span class="keyword">sizeof</span>(X(sp)));
<a name="l03254"></a>03254     <span class="keywordflow">if</span>(!A-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>){
<a name="l03255"></a>03255     A-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>=calloc(1, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l03256"></a>03256     A-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>[0]=1;
<a name="l03257"></a>03257     }
<a name="l03258"></a>03258     memcpy(out,A,<span class="keyword">sizeof</span>(X(sp)));
<a name="l03259"></a>03259     out-&gt;nref[0]++;
<a name="l03260"></a>03260     <span class="keywordflow">return</span> out;
<a name="l03261"></a>03261 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6f0c670abe3c96cce9afb0f0e733b350"></a><!-- doxytag: member="csp.h::cspdup" ref="6f0c670abe3c96cce9afb0f0e733b350" args="(const csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspdup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy a X(sp) matrix to another. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03266"></a>03266                                {
<a name="l03267"></a>03267     <span class="keywordtype">long</span> nmax=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>];
<a name="l03268"></a>03268     X(sp) *out;
<a name="l03269"></a>03269     out=Y(spnew)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, nmax);
<a name="l03270"></a>03270     memcpy(out-&gt;p, A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*(A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>+1));
<a name="l03271"></a>03271     memcpy(out-&gt;i, A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*nmax);
<a name="l03272"></a>03272     memcpy(out-&gt;x, A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>, <span class="keyword">sizeof</span>(T)*nmax);
<a name="l03273"></a>03273     <span class="keywordflow">return</span> out;
<a name="l03274"></a>03274 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="978de1ab5d2901e086f61668140f7339"></a><!-- doxytag: member="csp.h::cspmove" ref="978de1ab5d2901e086f61668140f7339" args="(csp *A, csp *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmove           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
move the matrix from res to A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03279"></a>03279                                     {
<a name="l03280"></a>03280     <span class="keywordflow">if</span>(!res || !A) 
<a name="l03281"></a>03281     error(<span class="stringliteral">"Trying to move an NULL matrix\n"</span>);
<a name="l03282"></a>03282     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>){
<a name="l03283"></a>03283     free(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>); 
<a name="l03284"></a>03284     free(A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>); 
<a name="l03285"></a>03285     free(A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>); 
<a name="l03286"></a>03286     free(A-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>);
<a name="l03287"></a>03287     }
<a name="l03288"></a>03288     memcpy(A,res,<span class="keyword">sizeof</span>(X(sp)));
<a name="l03289"></a>03289     free(res);
<a name="l03290"></a>03290 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ba26181f356f45e0c66bb677a6c32698"></a><!-- doxytag: member="csp.h::cspnew2" ref="ba26181f356f45e0c66bb677a6c32698" args="(const csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspnew2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(sp) matrix of the same size as A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03295"></a>03295                                 {
<a name="l03296"></a>03296     <span class="keywordflow">return</span> Y(spnew)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]);
<a name="l03297"></a>03297 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="491f95a564ed7edeb3ed3c2bc8c76575"></a><!-- doxytag: member="csp.h::cspnewrandu" ref="491f95a564ed7edeb3ed3c2bc8c76575" args="(int nx, int ny, const dcomplex mean, double fill, mt_state *rstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspnewrandu           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmt__state.html">mt_state</a> *&nbsp;</td>
          <td class="paramname"> <em>rstat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(sp) matrix and fill in uniform random numbers with filling factor of 'fill'. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03303"></a>03303                                             {
<a name="l03304"></a>03304     <span class="keywordflow">if</span>(fill&gt;1) fill=1.;
<a name="l03305"></a>03305     <span class="keywordflow">if</span>(fill&lt;0) fill=0.;
<a name="l03306"></a>03306     <span class="keyword">const</span> <span class="keywordtype">long</span> nzmax=nx*ny;
<a name="l03307"></a>03307     <span class="keywordtype">long</span> nz1=nx*ny*fill*4;
<a name="l03308"></a>03308     <span class="keywordflow">if</span>(nz1&gt;nzmax) nz1=nzmax;
<a name="l03309"></a>03309     X(sp) *A=Y(spnew)(nx,ny,nz1);
<a name="l03310"></a>03310     <span class="keywordtype">long</span> *pp=A-&gt;p;
<a name="l03311"></a>03311     <span class="keywordtype">long</span> *pi=A-&gt;i;
<a name="l03312"></a>03312     T *px=A-&gt;x;
<a name="l03313"></a>03313     <span class="keywordtype">long</span> count=0;
<a name="l03314"></a>03314     <span class="keywordtype">double</span> thres=1.-fill;
<a name="l03315"></a>03315     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;n; icol++){
<a name="l03316"></a>03316     pp[icol]=count;
<a name="l03317"></a>03317     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=0; irow&lt;A-&gt;m; irow++){
<a name="l03318"></a>03318         <span class="keywordflow">if</span>(randu(rstat)&gt;thres){
<a name="l03319"></a>03319         pi[count]=irow;
<a name="l03320"></a>03320         px[count]=RANDU(rstat)*mean;
<a name="l03321"></a>03321         count++;
<a name="l03322"></a>03322         <span class="keywordflow">if</span>(count&gt;nz1){
<a name="l03323"></a>03323             <span class="comment">//check out of bound;</span>
<a name="l03324"></a>03324             nz1=nz1*2; <span class="keywordflow">if</span>(nz1&gt;nzmax) nz1=nzmax;
<a name="l03325"></a>03325             Y(spsetnzmax)(A,nz1);
<a name="l03326"></a>03326             <span class="comment">//the pointers may change</span>
<a name="l03327"></a>03327             pp=A-&gt;p;
<a name="l03328"></a>03328             pi=A-&gt;i;
<a name="l03329"></a>03329             px=A-&gt;x;
<a name="l03330"></a>03330         }
<a name="l03331"></a>03331         }
<a name="l03332"></a>03332     }
<a name="l03333"></a>03333     }
<a name="l03334"></a>03334     pp[A-&gt;n]=count;
<a name="l03335"></a>03335     Y(spsetnzmax)(A,count);
<a name="l03336"></a>03336     <span class="keywordflow">return</span> A;
<a name="l03337"></a>03337 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0f62850af8a0a48f2cc063bf95df8856"></a><!-- doxytag: member="csp.h::cspsetnzmax" ref="0f62850af8a0a48f2cc063bf95df8856" args="(csp *sp, long nzmax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspsetnzmax           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nzmax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
resize a X(sp) matrix 
<p>
<div class="fragment"><pre class="fragment"><a name="l03342"></a>03342                                          {
<a name="l03343"></a>03343     <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#1ac262485faf97bba7f808626854a480" title="maximum number of entries">nzmax</a>!=nzmax){
<a name="l03344"></a>03344     sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>=realloc(sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*nzmax);
<a name="l03345"></a>03345     sp-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>=realloc(sp-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>, <span class="keyword">sizeof</span>(T)*nzmax);
<a name="l03346"></a>03346     sp-&gt;<a class="code" href="structcsp.html#1ac262485faf97bba7f808626854a480" title="maximum number of entries">nzmax</a>=nzmax;
<a name="l03347"></a>03347     }
<a name="l03348"></a>03348 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4ae0a8c3586b6bc85cc273b3217b2db4"></a><!-- doxytag: member="csp.h::cspfree_do" ref="4ae0a8c3586b6bc85cc273b3217b2db4" args="(csp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(sp) matrix 
<p>
<div class="fragment"><pre class="fragment"><a name="l03351"></a>03351                             {
<a name="l03352"></a>03352     <span class="keywordflow">if</span>(!sp) <span class="keywordflow">return</span>;
<a name="l03353"></a>03353     <span class="keywordflow">if</span>(!sp-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a> || sp-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>[0]&lt;=1){
<a name="l03354"></a>03354     <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>[0]!=1){
<a name="l03355"></a>03355         warning(<span class="stringliteral">"nref should nevre be less than 1\n"</span>);
<a name="l03356"></a>03356     }
<a name="l03357"></a>03357     free(sp-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>);
<a name="l03358"></a>03358     free(sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>);
<a name="l03359"></a>03359     free(sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>);
<a name="l03360"></a>03360     <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>){
<a name="l03361"></a>03361         free(sp-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>);
<a name="l03362"></a>03362     }<span class="keywordflow">else</span>{
<a name="l03363"></a>03363         warning(<span class="stringliteral">"X(sp) was corrected incorrectly\n"</span>);
<a name="l03364"></a>03364     }
<a name="l03365"></a>03365     }<span class="keywordflow">else</span>{
<a name="l03366"></a>03366     sp-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>[0]--;
<a name="l03367"></a>03367     <span class="comment">//warning("data is retained. nref=%ld\n",sp-&gt;nref[0]);</span>
<a name="l03368"></a>03368     }
<a name="l03369"></a>03369     free(sp);
<a name="l03370"></a>03370 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d23c83475ff51aac1ee3fc9aaa58d490"></a><!-- doxytag: member="csp.h::csparrfree" ref="d23c83475ff51aac1ee3fc9aaa58d490" args="(csp **sparr, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csparrfree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> **&nbsp;</td>
          <td class="paramname"> <em>sparr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(sp) array 
<p>
<div class="fragment"><pre class="fragment"><a name="l03373"></a>03373                                        {
<a name="l03374"></a>03374     <span class="keywordtype">int</span> i;
<a name="l03375"></a>03375     <span class="keywordflow">if</span>(sparr){
<a name="l03376"></a>03376     <span class="keywordflow">for</span>(i=0; i&lt;n; i++){
<a name="l03377"></a>03377         Y(spfree)(sparr[i]);
<a name="l03378"></a>03378     }
<a name="l03379"></a>03379     free(sparr); 
<a name="l03380"></a>03380     }
<a name="l03381"></a>03381 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dc5754766a10048b0412d4fd7d6d4f21"></a><!-- doxytag: member="csp.h::cspdisp" ref="dc5754766a10048b0412d4fd7d6d4f21" args="(const csp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspdisp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Display a X(sp) array. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03384"></a>03384                                {
<a name="l03385"></a>03385     <span class="keywordtype">long</span> ic,ir;
<a name="l03386"></a>03386     <span class="keywordtype">long</span> imax;
<a name="l03387"></a>03387     <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#1ac262485faf97bba7f808626854a480" title="maximum number of entries">nzmax</a>==0){
<a name="l03388"></a>03388     info(<span class="stringliteral">"Y(spdisp): All zeros\n"</span>);
<a name="l03389"></a>03389     }<span class="keywordflow">else</span>{
<a name="l03390"></a>03390     info(<span class="stringliteral">"Y(spdisp):\n"</span>);
<a name="l03391"></a>03391     <span class="keywordflow">for</span>(ic=0; ic&lt;sp-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; ic++){
<a name="l03392"></a>03392         imax=-1;
<a name="l03393"></a>03393         <span class="keywordflow">for</span>(ir=sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[ic];ir&lt;sp-&gt;p[ic+1];ir++){ 
<a name="l03394"></a>03394 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l03395"></a>03395 <span class="preprocessor"></span>        printf(<span class="stringliteral">"(%ld,%ld)=(%g,%g)\n"</span>, 
<a name="l03396"></a>03396                sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ir], ic, creal(sp-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ir]),cimag(sp-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ir]));
<a name="l03397"></a>03397 <span class="preprocessor">#else       </span>
<a name="l03398"></a>03398 <span class="preprocessor"></span>        printf(<span class="stringliteral">"(%ld,%ld)=%g\n"</span>, sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ir], ic, sp-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ir]);
<a name="l03399"></a>03399 <span class="preprocessor">#endif</span>
<a name="l03400"></a>03400 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ir]&gt;imax){
<a name="l03401"></a>03401             imax=sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ir];
<a name="l03402"></a>03402         }<span class="keywordflow">else</span>{
<a name="l03403"></a>03403             warning(<span class="stringliteral">"Wrong order"</span>);
<a name="l03404"></a>03404         }
<a name="l03405"></a>03405         }
<a name="l03406"></a>03406     }
<a name="l03407"></a>03407     }
<a name="l03408"></a>03408 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="da6187466a85d6d4471143963d1a0b35"></a><!-- doxytag: member="csp.h::cspcheck" ref="da6187466a85d6d4471143963d1a0b35" args="(const csp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcheck           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check a X(sp) array for wrong orders. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03411"></a>03411                                 {
<a name="l03412"></a>03412     <span class="keywordflow">if</span>(sp){
<a name="l03413"></a>03413     <span class="keywordtype">long</span> ic,ir;
<a name="l03414"></a>03414     <span class="keywordtype">long</span> imax;
<a name="l03415"></a>03415     <span class="keywordflow">for</span>(ic=0; ic&lt;sp-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; ic++){
<a name="l03416"></a>03416         imax=-1;
<a name="l03417"></a>03417         <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[ic+1]&lt;sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[ic]){
<a name="l03418"></a>03418         error(<span class="stringliteral">"p in column %ld is smaller than %ld\n"</span>,ic+1,ic);
<a name="l03419"></a>03419         }
<a name="l03420"></a>03420         <span class="keywordflow">for</span>(ir=sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[ic];ir&lt;sp-&gt;p[ic+1];ir++){ 
<a name="l03421"></a>03421         <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ir]&gt;imax){
<a name="l03422"></a>03422             imax=sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ir];
<a name="l03423"></a>03423         }<span class="keywordflow">else</span>{
<a name="l03424"></a>03424             warning(<span class="stringliteral">"Wrong order at column %ld"</span>,ic);
<a name="l03425"></a>03425         }
<a name="l03426"></a>03426         }
<a name="l03427"></a>03427         <span class="keywordflow">if</span>(imax&gt;=sp-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>){
<a name="l03428"></a>03428         error(<span class="stringliteral">"imax=%ld exceeds column size at column %ld\n"</span>,imax,ic);
<a name="l03429"></a>03429         }
<a name="l03430"></a>03430     }
<a name="l03431"></a>03431     <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[sp-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]!=sp-&gt;<a class="code" href="structcsp.html#1ac262485faf97bba7f808626854a480" title="maximum number of entries">nzmax</a>){
<a name="l03432"></a>03432         warning(<span class="stringliteral">"real nzmax is %ld, allocated is %ld\n"</span>,sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[sp-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>],sp-&gt;<a class="code" href="structcsp.html#1ac262485faf97bba7f808626854a480" title="maximum number of entries">nzmax</a>);
<a name="l03433"></a>03433     }
<a name="l03434"></a>03434     }
<a name="l03435"></a>03435 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dd8d261f3e339da0ae0b34f77c49efe5"></a><!-- doxytag: member="csp.h::cspscale" ref="dd8d261f3e339da0ae0b34f77c49efe5" args="(csp *A, const dcomplex beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace scale X(sp) matrix elements. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03438"></a>03438                                        {
<a name="l03439"></a>03439     <span class="keywordflow">if</span>(A){
<a name="l03440"></a>03440     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]; i++){
<a name="l03441"></a>03441         A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[i]*=beta;
<a name="l03442"></a>03442     }
<a name="l03443"></a>03443     }
<a name="l03444"></a>03444 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="abcc5d0cae60d4f3dc19a6c3465a873e"></a><!-- doxytag: member="csp.h::cspcellscale" ref="abcc5d0cae60d4f3dc19a6c3465a873e" args="(cspcell *A, const dcomplex beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace scale a X(spcell) object 
<p>
<div class="fragment"><pre class="fragment"><a name="l03447"></a>03447                                                {
<a name="l03448"></a>03448     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; i++){
<a name="l03449"></a>03449     Y(spscale)(A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[i],beta);
<a name="l03450"></a>03450     }
<a name="l03451"></a>03451 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1cb1312e34d6d65db22b2277ef34080c"></a><!-- doxytag: member="csp.h::cspnewdiag" ref="1cb1312e34d6d65db22b2277ef34080c" args="(long N, dcomplex *vec, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspnewdiag           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex *&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new sparse matrix with diagonal elements set to vec*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03454"></a>03454                                             {
<a name="l03455"></a>03455     X(sp) *out=Y(spnew)(N,N,N);
<a name="l03456"></a>03456     <span class="keywordtype">long</span> *pp=out-&gt;p;
<a name="l03457"></a>03457     <span class="keywordtype">long</span> *pi=out-&gt;i;
<a name="l03458"></a>03458     T *px=out-&gt;x;
<a name="l03459"></a>03459     <span class="keywordtype">long</span> count=0;
<a name="l03460"></a>03460     <span class="keywordflow">if</span>(vec){
<a name="l03461"></a>03461     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;out-&gt;n; icol++){
<a name="l03462"></a>03462         pp[icol]=count;
<a name="l03463"></a>03463         pi[count]=icol;
<a name="l03464"></a>03464         px[count]=vec[icol]*alpha;
<a name="l03465"></a>03465         count++;
<a name="l03466"></a>03466     }
<a name="l03467"></a>03467     }<span class="keywordflow">else</span>{
<a name="l03468"></a>03468     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;out-&gt;n; icol++){
<a name="l03469"></a>03469         pp[icol]=count;
<a name="l03470"></a>03470         pi[count]=icol;
<a name="l03471"></a>03471         px[count]=alpha;
<a name="l03472"></a>03472         count++;
<a name="l03473"></a>03473     }
<a name="l03474"></a>03474     }
<a name="l03475"></a>03475     pp[out-&gt;n]=count;
<a name="l03476"></a>03476     <span class="keywordflow">return</span> out;
<a name="l03477"></a>03477 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="78a7b8edb5848dbeefb21d3f04eb66e6"></a><!-- doxytag: member="csp.h::cspdiag" ref="78a7b8edb5848dbeefb21d3f04eb66e6" args="(const csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cspdiag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract diagonal element of A and return. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03481"></a>03481                                  {
<a name="l03482"></a>03482     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>!=A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>){
<a name="l03483"></a>03483     error(<span class="stringliteral">"Only work for square matrix\n"</span>);
<a name="l03484"></a>03484     }
<a name="l03485"></a>03485     X(mat) *out=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>,1);
<a name="l03486"></a>03486     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03487"></a>03487     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l03488"></a>03488         <span class="keywordtype">long</span> row=A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[irow];
<a name="l03489"></a>03489         <span class="keywordflow">if</span>(row==icol){
<a name="l03490"></a>03490         out-&gt;p[icol]=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[irow];
<a name="l03491"></a>03491         }
<a name="l03492"></a>03492     }
<a name="l03493"></a>03493     }
<a name="l03494"></a>03494     <span class="keywordflow">return</span> out;
<a name="l03495"></a>03495 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="41e52911fa532cd4d5651e2a9c75e91d"></a><!-- doxytag: member="csp.h::cspmuldiag" ref="41e52911fa532cd4d5651e2a9c75e91d" args="(csp *restrict A, const dcomplex *w, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmuldiag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a X(sp) matrix inplace with a diagonal weighting matrix whose diagonal values are stored in w. 
<p>
W_ii=w_i; W_ij=0 if i!=j A=A*W*alpha; W is a diagonal X(sp) matrix. diag(W) is w multiply w[i] to all numbers in column[i] <div class="fragment"><pre class="fragment"><a name="l03504"></a>03504                                                          {
<a name="l03505"></a>03505     <span class="keywordflow">if</span>(A &amp;&amp; w){
<a name="l03506"></a>03506     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03507"></a>03507         <span class="keyword">const</span> T wi=w[icol]*alpha;
<a name="l03508"></a>03508         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03509"></a>03509         A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*=wi;
<a name="l03510"></a>03510         }
<a name="l03511"></a>03511     }
<a name="l03512"></a>03512     }
<a name="l03513"></a>03513 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8e28cfb4fabbf2ca0080e55d488304a3"></a><!-- doxytag: member="csp.h::cspmulvec_thread" ref="8e28cfb4fabbf2ca0080e55d488304a3" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, dcomplex alpha, int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmulvec_thread           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a sparse with a vector using multithread. 
<p>
Speed up is not signicant because need to allocate new memory. <div class="fragment"><pre class="fragment"><a name="l03563"></a>03563                                                        {
<a name="l03564"></a>03564     <span class="keywordflow">if</span>(!A || !x) <span class="keywordflow">return</span>;    
<a name="l03565"></a>03565     assert(y);
<a name="l03566"></a>03566     <span class="keywordflow">if</span>(nthread&lt;=1){
<a name="l03567"></a>03567     <span class="comment">/* </span>
<a name="l03568"></a>03568 <span class="comment">       When I did the timing, calling spmulvec is twice as slow as calling</span>
<a name="l03569"></a>03569 <span class="comment">       spmulvec directly from the calling routine. I don't understand.</span>
<a name="l03570"></a>03570 <span class="comment">    */</span>
<a name="l03571"></a>03571     <span class="keywordtype">long</span> icol, ix;
<a name="l03572"></a>03572     <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l03573"></a>03573         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03574"></a>03574         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03575"></a>03575             y[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*x[icol];
<a name="l03576"></a>03576         }
<a name="l03577"></a>03577         }
<a name="l03578"></a>03578     }<span class="keywordflow">else</span>{
<a name="l03579"></a>03579         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03580"></a>03580         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03581"></a>03581             y[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=alpha*A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*x[icol];
<a name="l03582"></a>03582         }
<a name="l03583"></a>03583         }
<a name="l03584"></a>03584     }
<a name="l03585"></a>03585     }<span class="keywordflow">else</span>{
<a name="l03586"></a>03586     sp_thread_t data;
<a name="l03587"></a>03587     data.A=A;
<a name="l03588"></a>03588     data.y=y;
<a name="l03589"></a>03589     data.<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>=x;
<a name="l03590"></a>03590     data.alpha=alpha;
<a name="l03591"></a>03591     data.ytmp=calloc(nthread,<span class="keyword">sizeof</span>(T*));
<a name="l03592"></a>03592     data.nthread=nthread;
<a name="l03593"></a>03593     thread_t mul[nthread];
<a name="l03594"></a>03594     thread_t acc[nthread];
<a name="l03595"></a>03595     thread_prep(mul, 0, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, 0, nthread, &amp;data);
<a name="l03596"></a>03596     CALL_EACH(Y(spmulvec_thread_do_mul), mul, nthread);
<a name="l03597"></a>03597     thread_prep(acc, 0, A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, 0, nthread, &amp;data);
<a name="l03598"></a>03598     CALL_EACH(Y(spmulvec_thread_do_acc), acc, nthread);
<a name="l03599"></a>03599     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ithread=0; ithread&lt;nthread; ithread++){
<a name="l03600"></a>03600         free(data.ytmp[ithread]);
<a name="l03601"></a>03601     }
<a name="l03602"></a>03602     free(data.ytmp);
<a name="l03603"></a>03603     }
<a name="l03604"></a>03604 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="54fc8f015cdea3064a1dd4d404e428c1"></a><!-- doxytag: member="csp.h::cspmulvec" ref="54fc8f015cdea3064a1dd4d404e428c1" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmulvec           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
sparse matrix multiply with a vector 
<p>
<div class="fragment"><pre class="fragment"><a name="l03608"></a>03608                                        {
<a name="l03609"></a>03609     <span class="keywordflow">if</span>(A &amp;&amp; x){
<a name="l03610"></a>03610     <span class="keywordtype">long</span> icol, ix;
<a name="l03611"></a>03611     assert(y);
<a name="l03612"></a>03612     <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l03613"></a>03613         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03614"></a>03614         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03615"></a>03615             y[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*x[icol];
<a name="l03616"></a>03616         }
<a name="l03617"></a>03617         }
<a name="l03618"></a>03618     }<span class="keywordflow">else</span>{
<a name="l03619"></a>03619         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03620"></a>03620         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03621"></a>03621             y[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=alpha*A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*x[icol];
<a name="l03622"></a>03622         }
<a name="l03623"></a>03623         }
<a name="l03624"></a>03624     }
<a name="l03625"></a>03625     }
<a name="l03626"></a>03626 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9a5940fca0abf0d7876eafd923bc78e9"></a><!-- doxytag: member="csp.h::cspmulcreal" ref="9a5940fca0abf0d7876eafd923bc78e9" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmulcreal           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a sparse matrix with the real part of a complex vector. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03715"></a>03715                    {
<a name="l03716"></a>03716     <span class="comment">//y=y+alpha*A*creal(x);</span>
<a name="l03717"></a>03717     <span class="keywordflow">if</span>(A &amp;&amp; x){
<a name="l03718"></a>03718     <span class="keywordtype">long</span> icol, ix;
<a name="l03719"></a>03719     <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l03720"></a>03720         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03721"></a>03721         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03722"></a>03722             y[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*creal(x[icol]);
<a name="l03723"></a>03723         }
<a name="l03724"></a>03724         }
<a name="l03725"></a>03725     }<span class="keywordflow">else</span>{
<a name="l03726"></a>03726         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03727"></a>03727         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03728"></a>03728             y[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=alpha*A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*creal(x[icol]);
<a name="l03729"></a>03729         }
<a name="l03730"></a>03730         }
<a name="l03731"></a>03731     }
<a name="l03732"></a>03732     }
<a name="l03733"></a>03733 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ae38da51fa42e1dba34308f3e27b068b"></a><!-- doxytag: member="csp.h::csptmulvec" ref="ae38da51fa42e1dba34308f3e27b068b" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptmulvec           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply transpose of a sparse matrix with a vector. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03691"></a>03691                                              {
<a name="l03692"></a>03692     <span class="keywordflow">if</span>(A &amp;&amp; x){
<a name="l03693"></a>03693     <span class="comment">//y=y+alpha*A'*x;</span>
<a name="l03694"></a>03694     assert(y);
<a name="l03695"></a>03695     <span class="keywordtype">long</span> icol, ix;
<a name="l03696"></a>03696     <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l03697"></a>03697         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03698"></a>03698         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03699"></a>03699             y[icol]+=CONJ(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix])*x[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]];
<a name="l03700"></a>03700         }
<a name="l03701"></a>03701         }
<a name="l03702"></a>03702     }<span class="keywordflow">else</span>{
<a name="l03703"></a>03703         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03704"></a>03704         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03705"></a>03705             y[icol]+=alpha*CONJ(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix])*x[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]];
<a name="l03706"></a>03706         }
<a name="l03707"></a>03707         }
<a name="l03708"></a>03708     }
<a name="l03709"></a>03709     }
<a name="l03710"></a>03710 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9c9f61dd9e10e0a18545069dd3a493bb"></a><!-- doxytag: member="csp.h::csptmulvec_thread" ref="9c9f61dd9e10e0a18545069dd3a493bb" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, const dcomplex alpha, int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptmulvec_thread           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Threaded version of sptmulvec. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03656"></a>03656                                                              {
<a name="l03657"></a>03657     tic;
<a name="l03658"></a>03658     <span class="keywordflow">if</span>(!A || !x) <span class="keywordflow">return</span>;
<a name="l03659"></a>03659     assert(y);
<a name="l03660"></a>03660     <span class="keywordflow">if</span>(nthread&lt;=1){
<a name="l03661"></a>03661     <span class="keywordtype">long</span> icol, ix;
<a name="l03662"></a>03662     <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l03663"></a>03663         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03664"></a>03664         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03665"></a>03665             y[icol]+=CONJ(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix])*x[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]];
<a name="l03666"></a>03666         }
<a name="l03667"></a>03667         }
<a name="l03668"></a>03668     }<span class="keywordflow">else</span>{
<a name="l03669"></a>03669         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03670"></a>03670         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03671"></a>03671             y[icol]+=alpha*CONJ(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix])*x[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]];
<a name="l03672"></a>03672         }
<a name="l03673"></a>03673         }
<a name="l03674"></a>03674     }
<a name="l03675"></a>03675     }<span class="keywordflow">else</span>{
<a name="l03676"></a>03676     sp_thread_t data;
<a name="l03677"></a>03677     data.A=A;
<a name="l03678"></a>03678     data.y=y;
<a name="l03679"></a>03679     data.<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>=x;
<a name="l03680"></a>03680     data.alpha=alpha;
<a name="l03681"></a>03681     data.nthread=nthread;
<a name="l03682"></a>03682     thread_t mul[nthread];
<a name="l03683"></a>03683     thread_prep(mul, 0, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, 0, nthread, &amp;data);<span class="comment">//interlaced is not good.</span>
<a name="l03684"></a>03684     toc(<span class="stringliteral">"prep"</span>);
<a name="l03685"></a>03685     CALL_EACH(Y(sptmulvec_thread_do), mul, nthread);
<a name="l03686"></a>03686     }
<a name="l03687"></a>03687 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="979d62d76e351b60cb8ce8f270a1b866"></a><!-- doxytag: member="csp.h::cspmulmat" ref="979d62d76e351b60cb8ce8f270a1b866" args="(cmat **yout, const csp *A, const cmat *x, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a sparse matrix X(sp) with a dense matrix X(mat). 
<p>
<div class="fragment"><pre class="fragment"><a name="l03738"></a>03738                        {
<a name="l03739"></a>03739     <span class="keywordflow">if</span>(A&amp;&amp;x){
<a name="l03740"></a>03740     <span class="comment">// y=y+alpha*A*x;</span>
<a name="l03741"></a>03741     <span class="keywordtype">long</span> icol, ix;
<a name="l03742"></a>03742     <span class="keywordflow">if</span>(!*yout){
<a name="l03743"></a>03743         *yout=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>); 
<a name="l03744"></a>03744     }
<a name="l03745"></a>03745     X(mat) *y=*yout;
<a name="l03746"></a>03746     assert(x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==y-&gt;ny);
<a name="l03747"></a>03747     assert(A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>==x-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>);
<a name="l03748"></a>03748     <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1){
<a name="l03749"></a>03749         Y(spmulvec)(y-&gt;p, A, x-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>,  alpha);
<a name="l03750"></a>03750     }<span class="keywordflow">else</span>{
<a name="l03751"></a>03751         <span class="keywordtype">int</span> jcol;
<a name="l03752"></a>03752         T (* restrict Y)[y-&gt;nx]=(T(*)[y-&gt;nx])y-&gt;p;
<a name="l03753"></a>03753         T (* restrict X)[x-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>]=(T(*)[x-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>])x-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l03754"></a>03754         <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l03755"></a>03755         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03756"></a>03756             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03757"></a>03757             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;ny; jcol++){
<a name="l03758"></a>03758                 Y[jcol][A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*X[jcol][icol];
<a name="l03759"></a>03759             }
<a name="l03760"></a>03760             }
<a name="l03761"></a>03761         }
<a name="l03762"></a>03762         }<span class="keywordflow">else</span>{
<a name="l03763"></a>03763         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03764"></a>03764             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03765"></a>03765             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;ny; jcol++){
<a name="l03766"></a>03766                 Y[jcol][A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=alpha*A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*X[jcol][icol];
<a name="l03767"></a>03767             }
<a name="l03768"></a>03768             }
<a name="l03769"></a>03769         }
<a name="l03770"></a>03770         }
<a name="l03771"></a>03771     }
<a name="l03772"></a>03772     }
<a name="l03773"></a>03773 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d33258da06cc2612c4c7c66e5af5306b"></a><!-- doxytag: member="csp.h::csptmulmat" ref="d33258da06cc2612c4c7c66e5af5306b" args="(cmat **yout, const csp *A, const cmat *x, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
y=y+alpha*A'*x; 
<p>
<div class="fragment"><pre class="fragment"><a name="l03777"></a>03777                                                                                 {
<a name="l03778"></a>03778     <span class="keywordflow">if</span>(A&amp;&amp;x){
<a name="l03779"></a>03779     <span class="keywordtype">long</span> icol, ix;
<a name="l03780"></a>03780     <span class="keywordflow">if</span>(!*yout){
<a name="l03781"></a>03781         *yout=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l03782"></a>03782     }
<a name="l03783"></a>03783     X(mat) *y=*yout;
<a name="l03784"></a>03784     assert(x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==y-&gt;ny);
<a name="l03785"></a>03785     assert(A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>==y-&gt;nx);
<a name="l03786"></a>03786     <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1){
<a name="l03787"></a>03787         Y(sptmulvec)(y-&gt;p, A, x-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, alpha);
<a name="l03788"></a>03788     }<span class="keywordflow">else</span>{
<a name="l03789"></a>03789         <span class="keywordtype">int</span> jcol;
<a name="l03790"></a>03790         PMAT(x,X);
<a name="l03791"></a>03791         PMAT(y,Y);
<a name="l03792"></a>03792         <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l03793"></a>03793         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03794"></a>03794             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03795"></a>03795             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;ny; jcol++){
<a name="l03796"></a>03796                 Y[jcol][icol]+=CONJ(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix])*X[jcol][A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]];
<a name="l03797"></a>03797             }
<a name="l03798"></a>03798             }
<a name="l03799"></a>03799         }
<a name="l03800"></a>03800         }<span class="keywordflow">else</span>{
<a name="l03801"></a>03801         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03802"></a>03802             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03803"></a>03803             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;ny; jcol++){
<a name="l03804"></a>03804                 Y[jcol][icol]+=alpha*CONJ(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix])*X[jcol][A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]];
<a name="l03805"></a>03805             }
<a name="l03806"></a>03806             }
<a name="l03807"></a>03807         }
<a name="l03808"></a>03808         }
<a name="l03809"></a>03809     }
<a name="l03810"></a>03810     }
<a name="l03811"></a>03811 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="084a73490868acd8a291793aabbad3a5"></a><!-- doxytag: member="csp.h::cspwdinn" ref="084a73490868acd8a291793aabbad3a5" args="(const cmat *y, const csp *A, const cmat *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cspwdinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two matrices with weighting by sparse matrix. 
<p>
return y'*(A*x) <div class="fragment"><pre class="fragment"><a name="l03814"></a>03814                                                               {
<a name="l03815"></a>03815     <span class="comment">//X(sp) weighted ddot.</span>
<a name="l03816"></a>03816     <span class="comment">//computes y'*(A*x). x,y are vectors</span>
<a name="l03817"></a>03817     T res=0;
<a name="l03818"></a>03818     <span class="keywordflow">if</span>(x &amp;&amp; y){
<a name="l03819"></a>03819     <span class="keywordflow">if</span>(A){
<a name="l03820"></a>03820         assert(x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1 &amp;&amp; y-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1 &amp;&amp; A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>==y-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> &amp;&amp; A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>==x-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>);
<a name="l03821"></a>03821         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03822"></a>03822         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03823"></a>03823             res+=y-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]*A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*x-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[icol];
<a name="l03824"></a>03824         }
<a name="l03825"></a>03825         }
<a name="l03826"></a>03826     }<span class="keywordflow">else</span>{
<a name="l03827"></a>03827         res=X(inn)(x,y);
<a name="l03828"></a>03828     }
<a name="l03829"></a>03829     }
<a name="l03830"></a>03830     <span class="keywordflow">return</span> res;
<a name="l03831"></a>03831 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d52ad07f584725c01825cd2e1fa38724"></a><!-- doxytag: member="csp.h::cspcellwdinn" ref="d52ad07f584725c01825cd2e1fa38724" args="(const ccell *y, const cspcell *A, const ccell *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cspcellwdinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two cell arrays with weighting by sparse matrix. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03834"></a>03834                                                                         {
<a name="l03835"></a>03835     <span class="comment">//computes y'*(A*x)</span>
<a name="l03836"></a>03836     T res=0;
<a name="l03837"></a>03837     <span class="keywordflow">if</span>(x &amp;&amp; y){
<a name="l03838"></a>03838     <span class="keywordflow">if</span>(A){
<a name="l03839"></a>03839         assert(x-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>==1 &amp;&amp; y-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>==1 &amp;&amp; A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>==y-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a> &amp;&amp; A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>==x-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>);
<a name="l03840"></a>03840         X(sp) *(*Ap)[A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>]=(X(sp) *(*)[A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>])A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>;
<a name="l03841"></a>03841         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;ny; iy++){
<a name="l03842"></a>03842         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>; ix++){
<a name="l03843"></a>03843             res+=Y(spwdinn)(y-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[ix], Ap[iy][ix], x-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[iy]);
<a name="l03844"></a>03844         }
<a name="l03845"></a>03845         }
<a name="l03846"></a>03846     }<span class="keywordflow">else</span>{
<a name="l03847"></a>03847         res = X(cellinn)(x,y);
<a name="l03848"></a>03848     }
<a name="l03849"></a>03849     }
<a name="l03850"></a>03850     <span class="keywordflow">return</span> res;
<a name="l03851"></a>03851 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e0baf2d188be6beae581db14384e88d1"></a><!-- doxytag: member="csp.h::cspcellmulmat" ref="e0baf2d188be6beae581db14384e88d1" args="(ccell **C, const cspcell *A, const ccell *B, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with a dense cell: C=C+A*B*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03891"></a>03891                                                                                     {
<a name="l03892"></a>03892     <span class="keywordflow">return</span> Y(spcellmulmat2)(C,A,B,alpha,0);
<a name="l03893"></a>03893 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2ae96154a8e626b25e038fda1af50032"></a><!-- doxytag: member="csp.h::csptcellmulmat" ref="2ae96154a8e626b25e038fda1af50032" args="(ccell **C, const cspcell *A, const ccell *B, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptcellmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
C=C+A'*B*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03896"></a>03896                                                                                      {
<a name="l03897"></a>03897     <span class="keywordflow">return</span> Y(spcellmulmat2)(C,A,B,alpha,1);
<a name="l03898"></a>03898 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="55b1761ed410406c557bf8e650aa5f61"></a><!-- doxytag: member="csp.h::cspcellmulmat_thread" ref="55b1761ed410406c557bf8e650aa5f61" args="(ccell **C, const cspcell *A, const ccell *B, const dcomplex alpha, const int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellmulmat_thread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
threaded version of Y(spcellmulmat) 
<p>
<div class="fragment"><pre class="fragment"><a name="l03959"></a>03959                                   {
<a name="l03960"></a>03960     Y(spcellmulmat_thread2)(C,A,B,alpha,0,nthread);
<a name="l03961"></a>03961 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2016cdf467cae24f45f30eb7cd4c236b"></a><!-- doxytag: member="csp.h::csptcellmulmat_thread" ref="2016cdf467cae24f45f30eb7cd4c236b" args="(ccell **C, const cspcell *A, const ccell *B, const dcomplex alpha, const int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptcellmulmat_thread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
threaded version of Y(sptcellmulmat 
<p>
<div class="fragment"><pre class="fragment"><a name="l03966"></a>03966                                    {
<a name="l03967"></a>03967     Y(spcellmulmat_thread2)(C,A,B,alpha,1,nthread);
<a name="l03968"></a>03968 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6644c43d1ac2abf3b7767935a5e2ab46"></a><!-- doxytag: member="csp.h::cspfull" ref="6644c43d1ac2abf3b7767935a5e2ab46" args="(cmat **out0, const csp *A, const dcomplex f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert sparse matrix into dense matrix and add to output: out0=out0+full(A)*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03972"></a>03972                                                             {
<a name="l03973"></a>03973     <span class="keywordflow">if</span>(!A)
<a name="l03974"></a>03974     <span class="keywordflow">return</span>;<span class="comment"></span>
<a name="l03975"></a>03975 <span class="comment">    /**</span>
<a name="l03976"></a>03976 <span class="comment">       add A*f to dense matrix located in p;</span>
<a name="l03977"></a>03977 <span class="comment">    */</span>
<a name="l03978"></a>03978     <span class="keywordtype">long</span> nx=A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>;
<a name="l03979"></a>03979     <span class="keywordtype">long</span> icol,ix,irow;
<a name="l03980"></a>03980     <span class="keywordflow">if</span>(!*out0){
<a name="l03981"></a>03981     *out0=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>);
<a name="l03982"></a>03982     }
<a name="l03983"></a>03983     X(mat) *out=*out0;
<a name="l03984"></a>03984     assert(out-&gt;nx==A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a> &amp;&amp; out-&gt;ny==A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>);
<a name="l03985"></a>03985     PMAT(out,pp);
<a name="l03986"></a>03986     <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03987"></a>03987     <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03988"></a>03988         irow=A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix];
<a name="l03989"></a>03989         <span class="keywordflow">if</span>(irow&gt;=nx)
<a name="l03990"></a>03990         error(<span class="stringliteral">"invalid row:%ld, %ld"</span>,irow,nx);
<a name="l03991"></a>03991         pp[icol][irow]+=alpha*A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix];
<a name="l03992"></a>03992     }
<a name="l03993"></a>03993     }
<a name="l03994"></a>03994 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b2e5c232a1e67f54840d0d8da97bfbfc"></a><!-- doxytag: member="csp.h::csptfull" ref="b2e5c232a1e67f54840d0d8da97bfbfc" args="(cmat **out0, const csp *A, const dcomplex f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the transpose of a sparse matrix into dense matrix and add to output: out0=out0+full(A')*alpha;. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03998"></a>03998                                                              {
<a name="l03999"></a>03999     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;<span class="comment"></span>
<a name="l04000"></a>04000 <span class="comment">    /**</span>
<a name="l04001"></a>04001 <span class="comment">       add A*f to dense matrix located in p;</span>
<a name="l04002"></a>04002 <span class="comment">    */</span>
<a name="l04003"></a>04003     <span class="keywordtype">long</span> nx=A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>;
<a name="l04004"></a>04004     <span class="keywordtype">long</span> icol,ix,irow;
<a name="l04005"></a>04005     <span class="keywordflow">if</span>(!*out0){
<a name="l04006"></a>04006     *out0=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>);
<a name="l04007"></a>04007     }
<a name="l04008"></a>04008     X(mat) *out=*out0;
<a name="l04009"></a>04009     assert(out-&gt;nx==A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a> &amp;&amp; out-&gt;ny==A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>);
<a name="l04010"></a>04010     PMAT(out,pp);
<a name="l04011"></a>04011     <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l04012"></a>04012     <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l04013"></a>04013         irow=A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix];
<a name="l04014"></a>04014         <span class="keywordflow">if</span>(irow&gt;=nx)
<a name="l04015"></a>04015         error(<span class="stringliteral">"invalid row:%ld, %ld"</span>,irow,nx);
<a name="l04016"></a>04016         pp[irow][icol]+=alpha*A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix];
<a name="l04017"></a>04017     }
<a name="l04018"></a>04018     }
<a name="l04019"></a>04019 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7b859f635f4fd699e4b703f64bf57890"></a><!-- doxytag: member="csp.h::cspcellfull" ref="7b859f635f4fd699e4b703f64bf57890" args="(ccell **out0, const cspcell *A, const dcomplex f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert sparse cell to dense matrix cell: out0=out0+full(A)*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04022"></a>04022                                                                      {
<a name="l04023"></a>04023     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l04024"></a>04024     X(cell) *out=*out0;
<a name="l04025"></a>04025     <span class="keywordflow">if</span>(!out){
<a name="l04026"></a>04026     out=*out0=X(cellnew)(A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>, A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>);
<a name="l04027"></a>04027     }<span class="keywordflow">else</span>{
<a name="l04028"></a>04028     assert(out-&gt;nx==A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a> &amp;&amp; out-&gt;ny==A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>);
<a name="l04029"></a>04029     }
<a name="l04030"></a>04030     PSPCELL(A,pA);
<a name="l04031"></a>04031     PXCELL(out,pout);
<a name="l04032"></a>04032     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; iy++){
<a name="l04033"></a>04033     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>; ix++){
<a name="l04034"></a>04034         Y(spfull)(&amp;pout[iy][ix], pA[iy][ix], alpha);
<a name="l04035"></a>04035     }
<a name="l04036"></a>04036     }
<a name="l04037"></a>04037 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d0ea8b24ff5f244861b568b7687c8f44"></a><!-- doxytag: member="csp.h::csptcellfull" ref="d0ea8b24ff5f244861b568b7687c8f44" args="(ccell **out0, const cspcell *A, const dcomplex f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptcellfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert transpose of sparse cell to dense matrix cell: out0=out0+full(A')*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04040"></a>04040                                                                       {
<a name="l04041"></a>04041     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l04042"></a>04042     X(cell) *out=*out0;
<a name="l04043"></a>04043     <span class="keywordflow">if</span>(!out){
<a name="l04044"></a>04044     out=*out0=X(cellnew)(A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>, A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>);
<a name="l04045"></a>04045     }<span class="keywordflow">else</span>{
<a name="l04046"></a>04046     assert(out-&gt;nx==A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a> &amp;&amp; out-&gt;ny==A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>);
<a name="l04047"></a>04047     }
<a name="l04048"></a>04048     PSPCELL(A,pA);
<a name="l04049"></a>04049     PXCELL(out, pout);
<a name="l04050"></a>04050     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; iy++){
<a name="l04051"></a>04051     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>; ix++){
<a name="l04052"></a>04052         Y(spfull)(&amp;pout[ix][iy], pA[iy][ix], alpha);
<a name="l04053"></a>04053     }
<a name="l04054"></a>04054     } 
<a name="l04055"></a>04055 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="288e4b42b14730697afd467bd73bf589"></a><!-- doxytag: member="csp.h::cspadd2" ref="288e4b42b14730697afd467bd73bf589" args="(csp *A, csp *B, dcomplex a, dcomplex b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspadd2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Added two sparse matrices: return A*a+B*b. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04058"></a>04058                                           {
<a name="l04059"></a>04059     X(sp) *C=Y(cs_add)(A,B,a,b);
<a name="l04060"></a>04060     Y(cs_dropzeros)(C);
<a name="l04061"></a>04061     <span class="keywordflow">return</span> C;
<a name="l04062"></a>04062 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2425634b2e026e5beb40d3e32dbf05a2"></a><!-- doxytag: member="csp.h::cspadd" ref="2425634b2e026e5beb40d3e32dbf05a2" args="(csp **A0, const csp *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspadd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a sparse matrix to another: A0=A0+B. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04065"></a>04065                                          {
<a name="l04066"></a>04066     <span class="comment">//add B to A.</span>
<a name="l04067"></a>04067     <span class="keywordflow">if</span>(B){
<a name="l04068"></a>04068     <span class="keywordflow">if</span>(!*A0) 
<a name="l04069"></a>04069         *A0=Y(spdup)(B);
<a name="l04070"></a>04070     <span class="keywordflow">else</span>{
<a name="l04071"></a>04071         <span class="keywordflow">if</span>((*A0)-&gt;m!=B-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a> || (*A0)-&gt;n!=B-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>) {
<a name="l04072"></a>04072         error(<span class="stringliteral">"X(sp) matrix mismatch: (%ldx%ld) vs (%ldx%ld\n"</span>,
<a name="l04073"></a>04073               (*A0)-&gt;m, (*A0)-&gt;n, B-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, B-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>);
<a name="l04074"></a>04074         }
<a name="l04075"></a>04075         X(sp) *res=Y(cs_add)(*A0,B,1.,1.);
<a name="l04076"></a>04076         Y(cs_dropzeros)(res);
<a name="l04077"></a>04077         <span class="comment">//move the data over.</span>
<a name="l04078"></a>04078         Y(spmove)(*A0,res);<span class="comment">//move the data from res to A.</span>
<a name="l04079"></a>04079     }
<a name="l04080"></a>04080     }
<a name="l04081"></a>04081 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="11639654ba4aaeea701ad44343239714"></a><!-- doxytag: member="csp.h::cspcelladd" ref="11639654ba4aaeea701ad44343239714" args="(cspcell **A0, const cspcell *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcelladd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a sparse cell to another: A0=A0+B. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04084"></a>04084                                                      {
<a name="l04085"></a>04085     <span class="keywordflow">if</span>(B){
<a name="l04086"></a>04086     <span class="keywordflow">if</span>(!*A0){
<a name="l04087"></a>04087         *A0=Y(spcellnew)(B-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>, B-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>);
<a name="l04088"></a>04088     }
<a name="l04089"></a>04089     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;B-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>*B-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; i++){
<a name="l04090"></a>04090         Y(spadd)(&amp;((*A0)-&gt;p[i]), B-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[i]);
<a name="l04091"></a>04091     }
<a name="l04092"></a>04092     }
<a name="l04093"></a>04093 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7c380d6d6ef6d0965e5a35fd4b7ce680"></a><!-- doxytag: member="csp.h::csptrans" ref="7c380d6d6ef6d0965e5a35fd4b7ce680" args="(const csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* csptrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transpose a sparse array. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04096"></a>04096                                  {
<a name="l04097"></a>04097     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l04098"></a>04098     X(sp) *res=Y(cs_transpose)(A,1);
<a name="l04099"></a>04099     Y(cs_dropzeros)(res);
<a name="l04100"></a>04100     <span class="keywordflow">return</span> res;
<a name="l04101"></a>04101 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1334089c91c23cfe696e5ebfdce273dd"></a><!-- doxytag: member="csp.h::cspmulsp" ref="1334089c91c23cfe696e5ebfdce273dd" args="(const csp *A, const csp *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspmulsp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two sparse arrays: return A*B. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04104"></a>04104                                                  {      
<a name="l04105"></a>04105     <span class="comment">//return C=(A*B)</span>
<a name="l04106"></a>04106     <span class="keywordflow">if</span>(!A || !B) <span class="keywordflow">return</span> NULL;
<a name="l04107"></a>04107     X(sp) *C=Y(cs_multiply)(A, B);
<a name="l04108"></a>04108     Y(cs_dropzeros)(C);
<a name="l04109"></a>04109     <span class="keywordflow">return</span> C;
<a name="l04110"></a>04110 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b7e0a8ab070321e84b17ac255ffd8844"></a><!-- doxytag: member="csp.h::csptmulsp" ref="b7e0a8ab070321e84b17ac255ffd8844" args="(const csp *A, const csp *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* csptmulsp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply the transpose of a sparse with another: return A'*B. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04113"></a>04113                                                   {
<a name="l04114"></a>04114     <span class="comment">//return A'*B;</span>
<a name="l04115"></a>04115     <span class="comment">//fixme : may need to improve this so that tranpose of A is not necessary.</span>
<a name="l04116"></a>04116     X(sp) *At=Y(sptrans)(A);
<a name="l04117"></a>04117     X(sp) *C=Y(spmulsp)(At, B);
<a name="l04118"></a>04118     Y(spfree)(At);
<a name="l04119"></a>04119     Y(cs_dropzeros)(C);
<a name="l04120"></a>04120     <span class="keywordflow">return</span> C;
<a name="l04121"></a>04121 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1e65a4b563b95329539de9aa99639321"></a><!-- doxytag: member="csp.h::cspmulsp2" ref="1e65a4b563b95329539de9aa99639321" args="(csp **C0, const csp *A, const csp *B, const dcomplex scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmulsp2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> **&nbsp;</td>
          <td class="paramname"> <em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two sparse arrays and add to the third: C0=C0+A*B*scale. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04125"></a>04125                        {
<a name="l04126"></a>04126     <span class="comment">//return C=C+ alpha*(A*B)</span>
<a name="l04127"></a>04127     <span class="keywordflow">if</span>(!A || !B) <span class="keywordflow">return</span>;
<a name="l04128"></a>04128     X(sp) *res=Y(cs_multiply)(A, B);
<a name="l04129"></a>04129     <span class="keywordflow">if</span>(ABS(scale-1.)&gt;EPS){
<a name="l04130"></a>04130     Y(spscale)(res, scale);
<a name="l04131"></a>04131     }
<a name="l04132"></a>04132     <span class="keywordflow">if</span>(!*C0) 
<a name="l04133"></a>04133     *C0=res;
<a name="l04134"></a>04134     <span class="keywordflow">else</span>{
<a name="l04135"></a>04135     Y(spadd)(C0, res);
<a name="l04136"></a>04136     Y(spfree)(res);
<a name="l04137"></a>04137     }
<a name="l04138"></a>04138     Y(cs_dropzeros)(*C0);
<a name="l04139"></a>04139 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="49dcac88c7db4779a830c7fada6f3cc0"></a><!-- doxytag: member="csp.h::cspcellmulspcell" ref="49dcac88c7db4779a830c7fada6f3cc0" args="(const cspcell *A, const cspcell *B, const dcomplex scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcspcell.html">cspcell</a>* cspcellmulspcell           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two sparse cell. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04144"></a>04144                                 {
<a name="l04145"></a>04145     <span class="comment">//return C=A*B;</span>
<a name="l04146"></a>04146     <span class="keywordflow">if</span>(!A || !B) <span class="keywordflow">return</span> NULL;
<a name="l04147"></a>04147     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>!=B-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>) error(<span class="stringliteral">"mismatch\n"</span>);
<a name="l04148"></a>04148     Y(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>) *C=Y(spcellnew)(A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>, B-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>);
<a name="l04149"></a>04149     X(sp) *(*Ap)[A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>] = (X(sp) *(*)[A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>]) A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>;
<a name="l04150"></a>04150     X(sp) *(*Bp)[B-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>] = (X(sp) *(*)[B-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>]) B-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>;
<a name="l04151"></a>04151     X(sp) *(*Cp)[C-&gt;nx] = (X(sp) *(*)[C-&gt;nx]) C-&gt;p;
<a name="l04152"></a>04152     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;B-&gt;ny; iy++){
<a name="l04153"></a>04153     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>; ix++){
<a name="l04154"></a>04154         Cp[iy][ix]=NULL;
<a name="l04155"></a>04155         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz=0; iz&lt;A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; iz++){
<a name="l04156"></a>04156         Y(spmulsp2)(&amp;Cp[iy][ix],Ap[iz][ix],Bp[iy][iz],scale);
<a name="l04157"></a>04157         }
<a name="l04158"></a>04158     }
<a name="l04159"></a>04159     }
<a name="l04160"></a>04160     <span class="keywordflow">return</span> C;
<a name="l04161"></a>04161 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0116948f7f49876ec550f83d52527708"></a><!-- doxytag: member="csp.h::cspcellnew" ref="0116948f7f49876ec550f83d52527708" args="(const long nx, const long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcspcell.html">cspcell</a>* cspcellnew           </td>
          <td>(</td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new sparse cell. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04164"></a>04164                                                      {
<a name="l04165"></a>04165     Y(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>) *spc;
<a name="l04166"></a>04166     spc=calloc(1, <span class="keyword">sizeof</span>(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>));
<a name="l04167"></a>04167     spc-&gt;nx=nx;
<a name="l04168"></a>04168     spc-&gt;ny=ny;
<a name="l04169"></a>04169     spc-&gt;p=calloc(nx*ny, <span class="keyword">sizeof</span>(X(sp) *));
<a name="l04170"></a>04170     <span class="keywordflow">return</span> spc;
<a name="l04171"></a>04171 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="505b38d31765196007662b0cc2aaa796"></a><!-- doxytag: member="csp.h::cspcelltrans" ref="505b38d31765196007662b0cc2aaa796" args="(const cspcell *spc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcspcell.html">cspcell</a>* cspcelltrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>spc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transpose a sparse cell. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04174"></a>04174                                                {
<a name="l04175"></a>04175     <span class="keywordflow">if</span>(!spc) <span class="keywordflow">return</span> NULL;
<a name="l04176"></a>04176     <span class="keywordtype">long</span> nx,ny;
<a name="l04177"></a>04177     nx=spc-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>;
<a name="l04178"></a>04178     ny=spc-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>;
<a name="l04179"></a>04179     Y(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>) *spct=Y(spcellnew)(ny,nx);
<a name="l04180"></a>04180     
<a name="l04181"></a>04181     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;ny; iy++){
<a name="l04182"></a>04182     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;nx; ix++){
<a name="l04183"></a>04183         spct-&gt;p[iy+ix*ny]=Y(sptrans)(spc-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[ix+iy*nx]);
<a name="l04184"></a>04184     }
<a name="l04185"></a>04185     }
<a name="l04186"></a>04186     <span class="keywordflow">return</span> spct;
<a name="l04187"></a>04187 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="81ac17cb4a76babb27068e2441fef625"></a><!-- doxytag: member="csp.h::cspcellfree_do" ref="81ac17cb4a76babb27068e2441fef625" args="(cspcell *spc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>spc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a sparse cell data. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04190"></a>04190                                      {
<a name="l04191"></a>04191     <span class="keywordflow">if</span>(!spc || !spc-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>) <span class="keywordflow">return</span>;
<a name="l04192"></a>04192     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;spc-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>*spc-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; ix++){
<a name="l04193"></a>04193     Y(spfree)(spc-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[ix]);
<a name="l04194"></a>04194     }
<a name="l04195"></a>04195     free(spc-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>);
<a name="l04196"></a>04196     free(spc);
<a name="l04197"></a>04197 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8789fe1e884e000a6113f62f0e9d2e63"></a><!-- doxytag: member="csp.h::cspcat" ref="8789fe1e884e000a6113f62f0e9d2e63" args="(const csp *A, const csp *B, int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspcat           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenate two sparse array along dim dimension. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04200"></a>04200                                                         {
<a name="l04201"></a>04201     X(sp) *C=NULL;
<a name="l04202"></a>04202     <span class="keywordflow">if</span>(dim==0){
<a name="l04203"></a>04203     error(<span class="stringliteral">"Not implemented\n"</span>);
<a name="l04204"></a>04204     <span class="comment">/*</span>
<a name="l04205"></a>04205 <span class="comment">      |A|</span>
<a name="l04206"></a>04206 <span class="comment">      |B|</span>
<a name="l04207"></a>04207 <span class="comment">    */</span>
<a name="l04208"></a>04208     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim==1){
<a name="l04209"></a>04209     <span class="comment">/*|AB|*/</span>
<a name="l04210"></a>04210     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a> != B-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>){
<a name="l04211"></a>04211         error(<span class="stringliteral">"X(sp) matrix doesn't match\n"</span>);
<a name="l04212"></a>04212     }
<a name="l04213"></a>04213     <span class="keyword">const</span> <span class="keywordtype">long</span> nzmax=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]+B-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[B-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>];
<a name="l04214"></a>04214     C=Y(spnew)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>+B-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, nzmax);
<a name="l04215"></a>04215     memcpy(C-&gt;p, A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l04216"></a>04216     memcpy(C-&gt;i, A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>, A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l04217"></a>04217     memcpy(C-&gt;x, A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>, A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]*<span class="keyword">sizeof</span>(T));
<a name="l04218"></a>04218     memcpy(C-&gt;i+A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>], B-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>, B-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[B-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l04219"></a>04219     memcpy(C-&gt;x+A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>], B-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>, B-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[B-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]*<span class="keyword">sizeof</span>(T));
<a name="l04220"></a>04220     <span class="keyword">const</span> <span class="keywordtype">long</span> Anzmax=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>];
<a name="l04221"></a>04221     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;B-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>+1; i++){
<a name="l04222"></a>04222         C-&gt;p[i+A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]=Anzmax+B-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[i];
<a name="l04223"></a>04223     }
<a name="l04224"></a>04224     }<span class="keywordflow">else</span>{
<a name="l04225"></a>04225     error(<span class="stringliteral">"Wrong dimension\n"</span>);
<a name="l04226"></a>04226     }
<a name="l04227"></a>04227     <span class="keywordflow">return</span> C;
<a name="l04228"></a>04228 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3b682ec0e120632c083d6e9f5b40a2b3"></a><!-- doxytag: member="csp.h::cspcell2sp" ref="3b682ec0e120632c083d6e9f5b40a2b3" args="(const cspcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspcell2sp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenate a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> to sparse array. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04231"></a>04231                                        {
<a name="l04232"></a>04232     <span class="comment">//convert Y(spcell) to sparse.</span>
<a name="l04233"></a>04233     X(sp) *(*Ap)[A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>] = (X(sp) *(*)[A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>])A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>;
<a name="l04234"></a>04234     <span class="keywordtype">long</span> nx=0,ny=0,nzmax=0;
<a name="l04235"></a>04235     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;nx; ix++){
<a name="l04236"></a>04236     nx+=Ap[0][ix]-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>;
<a name="l04237"></a>04237     }
<a name="l04238"></a>04238     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; iy++){
<a name="l04239"></a>04239     ny+=Ap[iy][0]-&gt;n;
<a name="l04240"></a>04240     }
<a name="l04241"></a>04241     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; i++){
<a name="l04242"></a>04242     nzmax+=A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[i]-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[i]-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>];
<a name="l04243"></a>04243     <span class="comment">//nzmax+=A-&gt;p[i]-&gt;nzmax;</span>
<a name="l04244"></a>04244     }
<a name="l04245"></a>04245     X(sp) *out=Y(spnew)(nx,ny,nzmax);
<a name="l04246"></a>04246     <span class="keywordtype">long</span> count=0;
<a name="l04247"></a>04247     <span class="keywordtype">long</span> jcol=0;
<a name="l04248"></a>04248     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; iy++){
<a name="l04249"></a>04249     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;Ap[iy][0]-&gt;n; icol++){
<a name="l04250"></a>04250         out-&gt;p[jcol+icol]=count;
<a name="l04251"></a>04251         <span class="keywordtype">long</span> kr=0;
<a name="l04252"></a>04252         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>; ix++){
<a name="l04253"></a>04253         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ir=Ap[iy][ix]-&gt;p[icol]; 
<a name="l04254"></a>04254             ir&lt;Ap[iy][ix]-&gt;p[icol+1]; ir++){
<a name="l04255"></a>04255             out-&gt;x[count]=Ap[iy][ix]-&gt;x[ir];
<a name="l04256"></a>04256             out-&gt;i[count]=Ap[iy][ix]-&gt;i[ir]+kr;
<a name="l04257"></a>04257             count++;
<a name="l04258"></a>04258         }
<a name="l04259"></a>04259         kr+=Ap[iy][ix]-&gt;m;
<a name="l04260"></a>04260         }
<a name="l04261"></a>04261     }
<a name="l04262"></a>04262     jcol+=Ap[iy][0]-&gt;n;
<a name="l04263"></a>04263     }
<a name="l04264"></a>04264     out-&gt;p[ny]=count;
<a name="l04265"></a>04265     <span class="keywordflow">if</span>(count&gt;nzmax){
<a name="l04266"></a>04266     error(<span class="stringliteral">"Y(spcell2sp) gets Wrong results. count=%ld, nzmax=%ld\n"</span>,count,nzmax);
<a name="l04267"></a>04267     }
<a name="l04268"></a>04268     <span class="comment">//nzmax maybe smaller than A-&gt;p[A-&gt;n] </span>
<a name="l04269"></a>04269     <span class="comment">//because nzmax simply show the slots available.</span>
<a name="l04270"></a>04270     <span class="keywordflow">return</span> out;
<a name="l04271"></a>04271 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a3836f4b5764c618db758467cdd24a62"></a><!-- doxytag: member="csp.h::cspsum" ref="a3836f4b5764c618db758467cdd24a62" args="(const csp *A, int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cspsum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sum elements of sparse array along dimension dim. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04276"></a>04276                                          {
<a name="l04277"></a>04277     <span class="comment">//Sum X(sp) matrix along col or row to form a vector</span>
<a name="l04278"></a>04278     X(mat) *v=NULL;
<a name="l04279"></a>04279     T *p;
<a name="l04280"></a>04280     <span class="keywordflow">switch</span>(dim){
<a name="l04281"></a>04281     <span class="keywordflow">case</span> 1:<span class="comment">//sum along col</span>
<a name="l04282"></a>04282     v=X(<span class="keyword">new</span>)(1,A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>);
<a name="l04283"></a>04283     p=v-&gt;p;
<a name="l04284"></a>04284     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l04285"></a>04285         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l04286"></a>04286         p[icol]+=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[irow];
<a name="l04287"></a>04287         }
<a name="l04288"></a>04288     }
<a name="l04289"></a>04289     <span class="keywordflow">break</span>;
<a name="l04290"></a>04290     <span class="keywordflow">case</span> 2:<span class="comment">//sum along row</span>
<a name="l04291"></a>04291     v=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>,1);
<a name="l04292"></a>04292     p=v-&gt;p;
<a name="l04293"></a>04293     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l04294"></a>04294         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l04295"></a>04295         p[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[irow]]+=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[irow];
<a name="l04296"></a>04296         }
<a name="l04297"></a>04297     }
<a name="l04298"></a>04298     <span class="keywordflow">break</span>;
<a name="l04299"></a>04299     <span class="keywordflow">default</span>:
<a name="l04300"></a>04300     error(<span class="stringliteral">"Invalid\n"</span>);
<a name="l04301"></a>04301     }
<a name="l04302"></a>04302     <span class="keywordflow">return</span> v;
<a name="l04303"></a>04303 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="fb8a40bc13c4f0c04b1a1431e7d1a5b5"></a><!-- doxytag: member="csp.h::cspsumabs" ref="fb8a40bc13c4f0c04b1a1431e7d1a5b5" args="(const csp *A, int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cspsumabs           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sum abs of elements of sparse array along dimension dim. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04306"></a>04306                                             {
<a name="l04307"></a>04307     X(mat) *v=NULL;
<a name="l04308"></a>04308     T *p;
<a name="l04309"></a>04309     <span class="keywordflow">switch</span>(col){
<a name="l04310"></a>04310     <span class="keywordflow">case</span> 1:<span class="comment">//sum along col</span>
<a name="l04311"></a>04311     v=X(<span class="keyword">new</span>)(1,A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>);
<a name="l04312"></a>04312     p=v-&gt;p;
<a name="l04313"></a>04313     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l04314"></a>04314         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l04315"></a>04315         p[icol]+=ABS(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[irow]);
<a name="l04316"></a>04316         }
<a name="l04317"></a>04317     }
<a name="l04318"></a>04318     <span class="keywordflow">break</span>;
<a name="l04319"></a>04319     <span class="keywordflow">case</span> 2:<span class="comment">//sum along row</span>
<a name="l04320"></a>04320     v=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>,1);
<a name="l04321"></a>04321     p=v-&gt;p;
<a name="l04322"></a>04322     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l04323"></a>04323         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l04324"></a>04324         p[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[irow]]+=ABS(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[irow]);
<a name="l04325"></a>04325         }
<a name="l04326"></a>04326     }
<a name="l04327"></a>04327     <span class="keywordflow">break</span>;
<a name="l04328"></a>04328     <span class="keywordflow">default</span>:
<a name="l04329"></a>04329     error(<span class="stringliteral">"Invalid\n"</span>);
<a name="l04330"></a>04330     }
<a name="l04331"></a>04331     <span class="keywordflow">return</span> v;
<a name="l04332"></a>04332 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d212aea4c404ea3b85aa820a02f2fe78"></a><!-- doxytag: member="csp.h::cspcellmulvec" ref="d212aea4c404ea3b85aa820a02f2fe78" args="(dcomplex *restrict yc, const cspcell *Ac, const dcomplex *restrict xc, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellmulvec           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>yc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>Ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>xc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with vectors. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04341"></a>04341                                             {
<a name="l04342"></a>04342     <span class="comment">//y=y+alpha*A*creal(x); Ac X(sp) cell. xc is vector.</span>
<a name="l04343"></a>04343     <span class="keywordflow">if</span>(Ac &amp;&amp; xc){
<a name="l04344"></a>04344     <span class="keyword">const</span> T *restrict x=xc;
<a name="l04345"></a>04345     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icy=0; icy&lt;Ac-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; icy++){
<a name="l04346"></a>04346         T *restrict y=yc;
<a name="l04347"></a>04347         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icx=0; icx&lt;Ac-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>; icx++){
<a name="l04348"></a>04348         <span class="keyword">const</span> X(sp) *A=Ac-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[icx+icy*Ac-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>];
<a name="l04349"></a>04349         Y(spmulvec)(y,A,x,alpha);
<a name="l04350"></a>04350         y+=A-&gt;m;
<a name="l04351"></a>04351         }
<a name="l04352"></a>04352         x+=Ac-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[icy*Ac-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>]-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>;
<a name="l04353"></a>04353     }
<a name="l04354"></a>04354     }
<a name="l04355"></a>04355 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="de98f70161730502163dbc410cb5740a"></a><!-- doxytag: member="csp.h::cspdropeps" ref="de98f70161730502163dbc410cb5740a" args="(csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspdropeps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drop elements that are EPS times the largest value. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04359"></a>04359                            {
<a name="l04360"></a>04360     <span class="keywordtype">double</span> max;
<a name="l04361"></a>04361 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l04362"></a>04362 <span class="preprocessor"></span>    maxmincmp(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>,A-&gt;<a class="code" href="structcsp.html#1ac262485faf97bba7f808626854a480" title="maximum number of entries">nzmax</a>,&amp;max,NULL,NULL);
<a name="l04363"></a>04363 <span class="preprocessor">#else</span>
<a name="l04364"></a>04364 <span class="preprocessor"></span>    max=<a class="code" href="mathmisc_8c.html#ac7d23a6f61a359934d93f1fbdc570ea" title="compute the maximum of the abs of double vector">maxabs</a>(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>, A-&gt;<a class="code" href="structcsp.html#1ac262485faf97bba7f808626854a480" title="maximum number of entries">nzmax</a>);
<a name="l04365"></a>04365 <span class="preprocessor">#endif</span>
<a name="l04366"></a>04366 <span class="preprocessor"></span>    Y(cs_droptol)(A, max*EPS);
<a name="l04367"></a>04367 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0fbab7792a907baf7e26798089f67fda"></a><!-- doxytag: member="csp.h::cspcelldropeps" ref="0fbab7792a907baf7e26798089f67fda" args="(cspcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcelldropeps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drop elements that are EPS times the largest value. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04371"></a>04371                                    {
<a name="l04372"></a>04372     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; i++){
<a name="l04373"></a>04373     Y(spdropeps)(A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[i]);
<a name="l04374"></a>04374     }
<a name="l04375"></a>04375 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6fc1f2acedbe1173af2194167055a1dd"></a><!-- doxytag: member="csp.h::cspsort" ref="6fc1f2acedbe1173af2194167055a1dd" args="(csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspsort           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make sure the elements are sorted correctly. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04387"></a>04387                         {
<a name="l04388"></a>04388     spelem *col=NULL;
<a name="l04389"></a>04389     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; i++){
<a name="l04390"></a>04390     <span class="keywordtype">long</span> nelem=(A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[i+1]-A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[i]);
<a name="l04391"></a>04391     <span class="keywordflow">if</span>(nelem==0) <span class="keywordflow">continue</span>;
<a name="l04392"></a>04392     col=realloc(col, nelem*<span class="keyword">sizeof</span>(spelem));
<a name="l04393"></a>04393     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;nelem; j++){
<a name="l04394"></a>04394         col[j].i=A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[i]+j];
<a name="l04395"></a>04395         col[j].x=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[i]+j];
<a name="l04396"></a>04396     }
<a name="l04397"></a>04397     qsort(col, nelem, <span class="keyword">sizeof</span>(spelem), (<span class="keywordtype">int</span>(*)(<span class="keyword">const</span> <span class="keywordtype">void</span>*,<span class="keyword">const</span> <span class="keywordtype">void</span>*))spelemcmp);
<a name="l04398"></a>04398     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;nelem; j++){
<a name="l04399"></a>04399         A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[i]+j]=col[j].i;
<a name="l04400"></a>04400         A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[i]+j]=col[j].x;
<a name="l04401"></a>04401     }
<a name="l04402"></a>04402     }
<a name="l04403"></a>04403     free(col);
<a name="l04404"></a>04404 
<a name="l04405"></a>04405 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6b8d5e45b17827f0ae65b1ced936b49d"></a><!-- doxytag: member="csp.h::cspcellsort" ref="6b8d5e45b17827f0ae65b1ced936b49d" args="(cspcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellsort           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make sure the elements are sorted correctly. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04409"></a>04409                                 {
<a name="l04410"></a>04410     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; i++){
<a name="l04411"></a>04411     Y(spsort)(A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[i]);
<a name="l04412"></a>04412     }
<a name="l04413"></a>04413 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f1f35ec3c6167455751a8b1a74f35b99"></a><!-- doxytag: member="csp.h::cspsym" ref="f1f35ec3c6167455751a8b1a74f35b99" args="(csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspsym           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
symmetricize a X(sp) matrix and drop values below a threshold. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04418"></a>04418                        {
<a name="l04419"></a>04419     X(sp) *B=Y(sptrans)(A);
<a name="l04420"></a>04420     Y(spadd)(&amp;A,B);
<a name="l04421"></a>04421     Y(spscale)(A,0.5);
<a name="l04422"></a>04422     Y(spfree)(B);
<a name="l04423"></a>04423     Y(spdropeps)(A);
<a name="l04424"></a>04424     Y(spsort)(A);<span class="comment">//This is important to make chol work.</span>
<a name="l04425"></a>04425 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="63805c61c7ce831fc8255368cdcd4b71"></a><!-- doxytag: member="csp.h::cspcellsym" ref="63805c61c7ce831fc8255368cdcd4b71" args="(cspcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellsym           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
symmetricize a X(sp) cell and drop values below a threshold. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04430"></a>04430                                {
<a name="l04431"></a>04431     Y(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>) *B=Y(spcelltrans)(A);
<a name="l04432"></a>04432     Y(spcelladd)(&amp;A,B);
<a name="l04433"></a>04433     Y(spcellfree)(B);
<a name="l04434"></a>04434     Y(spcellscale)(A,0.5);
<a name="l04435"></a>04435     Y(spcelldropeps)(A);
<a name="l04436"></a>04436     Y(spcellsort)(A);
<a name="l04437"></a>04437 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="293ebbfa0acf47f8783a3493966ad4ba"></a><!-- doxytag: member="csp.h::cspconvolvop" ref="293ebbfa0acf47f8783a3493966ad4ba" args="(cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspconvolvop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a X(sp) convolution operator C with C(i,j)=A(i-j); A must be very X(sp) with only a view non-zero value otherwise C will be too full. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04444"></a>04444                                 {
<a name="l04445"></a>04445     <span class="comment">//First collect statistics on A.</span>
<a name="l04446"></a>04446     <span class="keywordtype">long</span> nini=10;
<a name="l04447"></a>04447     T *vals=calloc(nini, <span class="keyword">sizeof</span>(T));
<a name="l04448"></a>04448     <span class="keywordtype">long</span> *sepx=calloc(nini, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l04449"></a>04449     <span class="keywordtype">long</span> *sepy=calloc(nini, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l04450"></a>04450     <span class="keywordtype">long</span> count=0;
<a name="l04451"></a>04451     <span class="keyword">const</span> <span class="keywordtype">long</span> nx=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l04452"></a>04452     <span class="keyword">const</span> <span class="keywordtype">long</span> ny=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l04453"></a>04453     <span class="keyword">const</span> <span class="keywordtype">long</span> nn=nx*ny;
<a name="l04454"></a>04454     PMAT(A,PA);
<a name="l04455"></a>04455     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iy++){
<a name="l04456"></a>04456     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l04457"></a>04457         <span class="keywordflow">if</span>(ABS(PA[iy][ix])&gt;0){
<a name="l04458"></a>04458         vals[count]=PA[iy][ix];
<a name="l04459"></a>04459         sepx[count]=ix;
<a name="l04460"></a>04460         sepy[count]=iy;
<a name="l04461"></a>04461         count++;
<a name="l04462"></a>04462         }
<a name="l04463"></a>04463         <span class="keywordflow">if</span>(count&gt;=nini){
<a name="l04464"></a>04464         nini*=2;
<a name="l04465"></a>04465         vals=realloc(vals, <span class="keyword">sizeof</span>(T)*nini);
<a name="l04466"></a>04466         sepx=realloc(sepx, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*nini);
<a name="l04467"></a>04467         sepy=realloc(sepy, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*nini);
<a name="l04468"></a>04468         }
<a name="l04469"></a>04469     }
<a name="l04470"></a>04470     }
<a name="l04471"></a>04471     <span class="keywordflow">if</span>(count&gt;10){
<a name="l04472"></a>04472     warning(<span class="stringliteral">"Number of coupled points %ld is too large\n"</span>,count);
<a name="l04473"></a>04473     }
<a name="l04474"></a>04474     <span class="keywordtype">long</span> nsep=count;
<a name="l04475"></a>04475     X(sp) *out=Y(spnew)(nn,nn,nn*count);
<a name="l04476"></a>04476     <span class="keywordtype">long</span> *pp=out-&gt;p;
<a name="l04477"></a>04477     <span class="keywordtype">long</span> *pi=out-&gt;i;
<a name="l04478"></a>04478     T *px=out-&gt;x;
<a name="l04479"></a>04479     count=0;
<a name="l04480"></a>04480     <span class="keywordtype">long</span> icol=0;
<a name="l04481"></a>04481     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iiy=0; iiy&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iiy++){
<a name="l04482"></a>04482     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iix=0; iix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; iix++){
<a name="l04483"></a>04483         pp[icol]=count;
<a name="l04484"></a>04484         icol++;
<a name="l04485"></a>04485         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=0; irow&lt;nsep; irow++){
<a name="l04486"></a>04486         <span class="keywordtype">long</span> jix=(iix+sepx[irow])%nx;
<a name="l04487"></a>04487         <span class="keywordtype">long</span> jiy=(iiy+sepy[irow])%ny;
<a name="l04488"></a>04488         pi[count]=jix+jiy*nx;
<a name="l04489"></a>04489         px[count]=vals[irow];
<a name="l04490"></a>04490         count++;
<a name="l04491"></a>04491         }
<a name="l04492"></a>04492     }
<a name="l04493"></a>04493     }
<a name="l04494"></a>04494     pp[nn]=count;
<a name="l04495"></a>04495     free(vals);
<a name="l04496"></a>04496     free(sepx);
<a name="l04497"></a>04497     free(sepy);
<a name="l04498"></a>04498     Y(spsort)(out);
<a name="l04499"></a>04499     <span class="keywordflow">return</span> out;
<a name="l04500"></a>04500 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f6059c535e9ed5cdff0c4974dd077c6f"></a><!-- doxytag: member="csp.h::cspperm" ref="f6059c535e9ed5cdff0c4974dd077c6f" args="(csp *A, int reverse, long *pcol, long *prow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspperm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>pcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>prow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Permute rows and columns of X(sp) matrix A;. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04536"></a>04536                                                                {
<a name="l04537"></a>04537     X(sp) *out;
<a name="l04538"></a>04538     <span class="keywordflow">if</span>(pcol){
<a name="l04539"></a>04539     out=Y(sppermcol)(A,reverse,pcol);
<a name="l04540"></a>04540     }<span class="keywordflow">else</span>{
<a name="l04541"></a>04541     out=Y(spref)(A);
<a name="l04542"></a>04542     }
<a name="l04543"></a>04543     <span class="keywordflow">if</span>(prow){
<a name="l04544"></a>04544     X(sp) *Ap=Y(sptrans)(out);
<a name="l04545"></a>04545     X(sp) *App=Y(sppermcol)(Ap,reverse,prow);
<a name="l04546"></a>04546     Y(spfree)(Ap);
<a name="l04547"></a>04547     Y(spfree)(out);
<a name="l04548"></a>04548     out=Y(sptrans)(App);
<a name="l04549"></a>04549     Y(spfree)(App);
<a name="l04550"></a>04550     }
<a name="l04551"></a>04551     <span class="keywordflow">return</span> out;
<a name="l04552"></a>04552 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ae348f4ec8480c2f9ad28bf5c7091bd9"></a><!-- doxytag: member="csp.h::cspinvbdiag" ref="ae348f4ec8480c2f9ad28bf5c7091bd9" args="(const csp *A, long bs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspinvbdiag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>bs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invert a SPD X(sp) matrix that is block diagonal with block sizes of bs. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04558"></a>04558                                              {
<a name="l04559"></a>04559     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>!=A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>){
<a name="l04560"></a>04560     error(<span class="stringliteral">"Must be a square matrix\n"</span>);
<a name="l04561"></a>04561     }
<a name="l04562"></a>04562     <span class="keywordtype">long</span> nb=A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>/bs;
<a name="l04563"></a>04563     X(sp) *B=Y(spnew)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, nb*bs*bs);
<a name="l04564"></a>04564     X(mat) *bk=X(<span class="keyword">new</span>)(bs,bs);
<a name="l04565"></a>04565     PMAT(bk,pbk);
<a name="l04566"></a>04566     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ib=0;ib&lt;nb; ib++){
<a name="l04567"></a>04567     <span class="keywordtype">long</span> is=ib*bs;<span class="comment">//starting col</span>
<a name="l04568"></a>04568     X(zero)(bk);
<a name="l04569"></a>04569 
<a name="l04570"></a>04570     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=is; icol&lt;is+bs; icol++){
<a name="l04571"></a>04571         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l04572"></a>04572         <span class="keywordtype">long</span> row=A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[irow];
<a name="l04573"></a>04573         <span class="keywordtype">long</span> ind=row-is;
<a name="l04574"></a>04574         <span class="keywordflow">if</span>(ind&lt;0 || ind&gt;=bs){
<a name="l04575"></a>04575             info(<span class="stringliteral">"solving block %ld\n"</span>,ib);
<a name="l04576"></a>04576             error(<span class="stringliteral">"The array is not block diagonal matrix or not calculated property\n"</span>);
<a name="l04577"></a>04577         }
<a name="l04578"></a>04578         pbk[icol-is][ind]=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[irow];
<a name="l04579"></a>04579         }
<a name="l04580"></a>04580     }
<a name="l04581"></a>04581     X(inv_inplace)(bk);
<a name="l04582"></a>04582     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=is; icol&lt;is+bs; icol++){
<a name="l04583"></a>04583         B-&gt;p[icol]=icol*bs;
<a name="l04584"></a>04584         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=0; irow&lt;bs; irow++){
<a name="l04585"></a>04585         B-&gt;i[B-&gt;p[icol]+irow]=irow+is;
<a name="l04586"></a>04586         B-&gt;x[B-&gt;p[icol]+irow]=pbk[icol-is][irow];
<a name="l04587"></a>04587         }
<a name="l04588"></a>04588     }
<a name="l04589"></a>04589     }
<a name="l04590"></a>04590     B-&gt;p[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]=nb*bs*bs;
<a name="l04591"></a>04591     <span class="keywordflow">return</span> B;
<a name="l04592"></a>04592 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cecaf203a653ac718dd234bf7119e580"></a><!-- doxytag: member="csp.h::cspblockextract" ref="cecaf203a653ac718dd234bf7119e580" args="(const csp *A, long bs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* cspblockextract           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>bs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extrat the diagonal blocks of size bs into cell arrays. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04596"></a>04596                                                    {
<a name="l04597"></a>04597     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>!=A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>){
<a name="l04598"></a>04598     error(<span class="stringliteral">"Must be a square matrix\n"</span>);
<a name="l04599"></a>04599     }
<a name="l04600"></a>04600     <span class="keywordtype">long</span> nb=A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>/bs;
<a name="l04601"></a>04601     X(cell) *out=X(cellnew)(nb,1);
<a name="l04602"></a>04602     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ib=0;ib&lt;nb; ib++){
<a name="l04603"></a>04603     <span class="keywordtype">long</span> is=ib*bs;<span class="comment">//starting col</span>
<a name="l04604"></a>04604     out-&gt;p[ib]=X(<span class="keyword">new</span>)(bs,bs);
<a name="l04605"></a>04605     PMAT(out-&gt;p[ib],pbk);
<a name="l04606"></a>04606     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=is; icol&lt;is+bs; icol++){
<a name="l04607"></a>04607         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l04608"></a>04608         <span class="keywordtype">long</span> row=A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[irow];
<a name="l04609"></a>04609         <span class="keywordtype">long</span> ind=row-is;
<a name="l04610"></a>04610         <span class="keywordflow">if</span>(ind&lt;0 || ind&gt;=bs){
<a name="l04611"></a>04611             info(<span class="stringliteral">"solving block %ld\n"</span>,ib);
<a name="l04612"></a>04612             error(<span class="stringliteral">"The array is not block diagonal matrix or not calculated property\n"</span>);
<a name="l04613"></a>04613         }
<a name="l04614"></a>04614         pbk[icol-is][ind]=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[irow];
<a name="l04615"></a>04615         }
<a name="l04616"></a>04616     }
<a name="l04617"></a>04617     }
<a name="l04618"></a>04618     <span class="keywordflow">return</span> out;
<a name="l04619"></a>04619 }
</pre></div>
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 29 14:31:02 2010 for maos-0.6.4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
