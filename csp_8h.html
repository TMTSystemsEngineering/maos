<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>maos-0.6.1: lib/csp.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lib/csp.h File Reference</h1>Contains functions for complex sparse <a class="el" href="structcsp.html" title="a sparse array of double complex numbers stored in compressed column format">csp</a>.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#c487a2b9ebd0931e631626a37965fd24">cspnew</a> (long nx, long ny, long nzmax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a nx*ny X(sp) matrix with memory for nmax max elements allocated.  <a href="#c487a2b9ebd0931e631626a37965fd24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#80f3f0a59125204877db212a85e8c6c7">cspref</a> (<a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reference a sparse object.  <a href="#80f3f0a59125204877db212a85e8c6c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#6f0c670abe3c96cce9afb0f0e733b350">cspdup</a> (const <a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy a X(sp) matrix to another.  <a href="#6f0c670abe3c96cce9afb0f0e733b350"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#978de1ab5d2901e086f61668140f7339">cspmove</a> (<a class="el" href="structcsp.html">csp</a> *A, <a class="el" href="structcsp.html">csp</a> *res)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">move the matrix from res to A.  <a href="#978de1ab5d2901e086f61668140f7339"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#ba26181f356f45e0c66bb677a6c32698">cspnew2</a> (const <a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(sp) matrix of the same size as A.  <a href="#ba26181f356f45e0c66bb677a6c32698"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#491f95a564ed7edeb3ed3c2bc8c76575">cspnewrandu</a> (int nx, int ny, const dcomplex mean, double fill, <a class="el" href="structmt__state.html">mt_state</a> *rstat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(sp) matrix and fill in uniform random numbers with filling factor of 'fill'.  <a href="#491f95a564ed7edeb3ed3c2bc8c76575"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2f7c267c519900762bb734e996a65897"></a><!-- doxytag: member="csp.h::cspshm_ro" ref="2f7c267c519900762bb734e996a65897" args="(key_t shmkey)" -->
<a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>cspshm_ro</b> (key_t shmkey)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fab70d28b81cb44ff0b1fdf92aa47740"></a><!-- doxytag: member="csp.h::cspshm_rw" ref="fab70d28b81cb44ff0b1fdf92aa47740" args="(key_t shmkey, int m, int n, int nzmax, int type)" -->
<a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>cspshm_rw</b> (key_t shmkey, int m, int n, int nzmax, int type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#0f62850af8a0a48f2cc063bf95df8856">cspsetnzmax</a> (<a class="el" href="structcsp.html">csp</a> *sp, long nzmax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">resize a X(sp) matrix  <a href="#0f62850af8a0a48f2cc063bf95df8856"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#4ae0a8c3586b6bc85cc273b3217b2db4">cspfree_do</a> (<a class="el" href="structcsp.html">csp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(sp) matrix  <a href="#4ae0a8c3586b6bc85cc273b3217b2db4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#d23c83475ff51aac1ee3fc9aaa58d490">csparrfree</a> (<a class="el" href="structcsp.html">csp</a> **sparr, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(sp) array  <a href="#d23c83475ff51aac1ee3fc9aaa58d490"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#dc5754766a10048b0412d4fd7d6d4f21">cspdisp</a> (const <a class="el" href="structcsp.html">csp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display a X(sp) array.  <a href="#dc5754766a10048b0412d4fd7d6d4f21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#da6187466a85d6d4471143963d1a0b35">cspcheck</a> (const <a class="el" href="structcsp.html">csp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check a X(sp) array for wrong orders.  <a href="#da6187466a85d6d4471143963d1a0b35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#dd8d261f3e339da0ae0b34f77c49efe5">cspscale</a> (<a class="el" href="structcsp.html">csp</a> *A, const dcomplex beta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace scale X(sp) matrix elements.  <a href="#dd8d261f3e339da0ae0b34f77c49efe5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#abcc5d0cae60d4f3dc19a6c3465a873e">cspcellscale</a> (<a class="el" href="structcspcell.html">cspcell</a> *A, const dcomplex beta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace scale a X(spcell) object  <a href="#abcc5d0cae60d4f3dc19a6c3465a873e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#1cb1312e34d6d65db22b2277ef34080c">cspnewdiag</a> (long N, dcomplex *vec, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new sparse matrix with diagonal elements set to vec*alpha.  <a href="#1cb1312e34d6d65db22b2277ef34080c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#78a7b8edb5848dbeefb21d3f04eb66e6">cspdiag</a> (const <a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract diagonal element of A and return.  <a href="#78a7b8edb5848dbeefb21d3f04eb66e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#41e52911fa532cd4d5651e2a9c75e91d">cspmuldiag</a> (<a class="el" href="structcsp.html">csp</a> *restrict A, const dcomplex *w, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a X(sp) matrix inplace with a diagonal weighting matrix whose diagonal values are stored in w.  <a href="#41e52911fa532cd4d5651e2a9c75e91d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#8e28cfb4fabbf2ca0080e55d488304a3">cspmulvec_thread</a> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, dcomplex alpha, int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a sparse with a vector using multithread.  <a href="#8e28cfb4fabbf2ca0080e55d488304a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#54fc8f015cdea3064a1dd4d404e428c1">cspmulvec</a> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sparse matrix multiply with a vector  <a href="#54fc8f015cdea3064a1dd4d404e428c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d85c0b07b56612cbbbcea5fc0f34fa7c"></a><!-- doxytag: member="csp.h::cspmulvec_mkl" ref="d85c0b07b56612cbbbcea5fc0f34fa7c" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, dcomplex alpha)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>cspmulvec_mkl</b> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, dcomplex alpha)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#9a5940fca0abf0d7876eafd923bc78e9">cspmulcreal</a> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a sparse matrix with the real part of a complex vector.  <a href="#9a5940fca0abf0d7876eafd923bc78e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#ae38da51fa42e1dba34308f3e27b068b">csptmulvec</a> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply transpose of a sparse matrix with a vector.  <a href="#ae38da51fa42e1dba34308f3e27b068b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#9c9f61dd9e10e0a18545069dd3a493bb">csptmulvec_thread</a> (dcomplex *restrict y, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex *restrict x, const dcomplex alpha, int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Threaded version of sptmulvec.  <a href="#9c9f61dd9e10e0a18545069dd3a493bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#979d62d76e351b60cb8ce8f270a1b866">cspmulmat</a> (<a class="el" href="structcmat.html">cmat</a> **yout, const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcmat.html">cmat</a> *x, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a sparse matrix X(sp) with a dense matrix X(mat).  <a href="#979d62d76e351b60cb8ce8f270a1b866"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#d33258da06cc2612c4c7c66e5af5306b">csptmulmat</a> (<a class="el" href="structcmat.html">cmat</a> **yout, const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcmat.html">cmat</a> *x, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">y=y+alpha*A'*x;  <a href="#d33258da06cc2612c4c7c66e5af5306b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#084a73490868acd8a291793aabbad3a5">cspwdinn</a> (const <a class="el" href="structcmat.html">cmat</a> *y, const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcmat.html">cmat</a> *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two matrices with weighting by sparse matrix.  <a href="#084a73490868acd8a291793aabbad3a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#d52ad07f584725c01825cd2e1fa38724">cspcellwdinn</a> (const <a class="el" href="structccell.html">ccell</a> *y, const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structccell.html">ccell</a> *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two cell arrays with weighting by sparse matrix.  <a href="#d52ad07f584725c01825cd2e1fa38724"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#e0baf2d188be6beae581db14384e88d1">cspcellmulmat</a> (<a class="el" href="structccell.html">ccell</a> **C, const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with a dense cell: C=C+A*B*alpha.  <a href="#e0baf2d188be6beae581db14384e88d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#2ae96154a8e626b25e038fda1af50032">csptcellmulmat</a> (<a class="el" href="structccell.html">ccell</a> **C, const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C=C+A'*B*alpha.  <a href="#2ae96154a8e626b25e038fda1af50032"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#55b1761ed410406c557bf8e650aa5f61">cspcellmulmat_thread</a> (<a class="el" href="structccell.html">ccell</a> **C, const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, const dcomplex alpha, const int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">threaded version of Y(spcellmulmat)  <a href="#55b1761ed410406c557bf8e650aa5f61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#2016cdf467cae24f45f30eb7cd4c236b">csptcellmulmat_thread</a> (<a class="el" href="structccell.html">ccell</a> **C, const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, const dcomplex alpha, const int nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">threaded version of Y(sptcellmulmat  <a href="#2016cdf467cae24f45f30eb7cd4c236b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#6644c43d1ac2abf3b7767935a5e2ab46">cspfull</a> (<a class="el" href="structcmat.html">cmat</a> **out0, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert sparse matrix into dense matrix and add to output: out0=out0+full(A)*alpha.  <a href="#6644c43d1ac2abf3b7767935a5e2ab46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#b2e5c232a1e67f54840d0d8da97bfbfc">csptfull</a> (<a class="el" href="structcmat.html">cmat</a> **out0, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the transpose of a sparse matrix into dense matrix and add to output: out0=out0+full(A')*alpha;.  <a href="#b2e5c232a1e67f54840d0d8da97bfbfc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#7b859f635f4fd699e4b703f64bf57890">cspcellfull</a> (<a class="el" href="structccell.html">ccell</a> **out0, const <a class="el" href="structcspcell.html">cspcell</a> *A, const dcomplex f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert sparse cell to dense matrix cell: out0=out0+full(A)*alpha.  <a href="#7b859f635f4fd699e4b703f64bf57890"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#d0ea8b24ff5f244861b568b7687c8f44">csptcellfull</a> (<a class="el" href="structccell.html">ccell</a> **out0, const <a class="el" href="structcspcell.html">cspcell</a> *A, const dcomplex f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert transpose of sparse cell to dense matrix cell: out0=out0+full(A')*alpha.  <a href="#d0ea8b24ff5f244861b568b7687c8f44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#288e4b42b14730697afd467bd73bf589">cspadd2</a> (<a class="el" href="structcsp.html">csp</a> *A, <a class="el" href="structcsp.html">csp</a> *B, dcomplex a, dcomplex b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Added two sparse matrices: return A*a+B*b.  <a href="#288e4b42b14730697afd467bd73bf589"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#2425634b2e026e5beb40d3e32dbf05a2">cspadd</a> (<a class="el" href="structcsp.html">csp</a> **A0, const <a class="el" href="structcsp.html">csp</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a sparse matrix to another: A0=A0+B.  <a href="#2425634b2e026e5beb40d3e32dbf05a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#11639654ba4aaeea701ad44343239714">cspcelladd</a> (<a class="el" href="structcspcell.html">cspcell</a> **A0, const <a class="el" href="structcspcell.html">cspcell</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a sparse cell to another: A0=A0+B.  <a href="#11639654ba4aaeea701ad44343239714"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#7c380d6d6ef6d0965e5a35fd4b7ce680">csptrans</a> (const <a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose a sparse array.  <a href="#7c380d6d6ef6d0965e5a35fd4b7ce680"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#1334089c91c23cfe696e5ebfdce273dd">cspmulsp</a> (const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcsp.html">csp</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two sparse arrays: return A*B.  <a href="#1334089c91c23cfe696e5ebfdce273dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#b7e0a8ab070321e84b17ac255ffd8844">csptmulsp</a> (const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcsp.html">csp</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply the transpose of a sparse with another: return A'*B.  <a href="#b7e0a8ab070321e84b17ac255ffd8844"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#1e65a4b563b95329539de9aa99639321">cspmulsp2</a> (<a class="el" href="structcsp.html">csp</a> **C0, const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcsp.html">csp</a> *B, const dcomplex scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two sparse arrays and add to the third: C0=C0+A*B*scale.  <a href="#1e65a4b563b95329539de9aa99639321"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#49dcac88c7db4779a830c7fada6f3cc0">cspcellmulspcell</a> (const <a class="el" href="structcspcell.html">cspcell</a> *A, const <a class="el" href="structcspcell.html">cspcell</a> *B, const dcomplex scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two sparse cell.  <a href="#49dcac88c7db4779a830c7fada6f3cc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#0116948f7f49876ec550f83d52527708">cspcellnew</a> (const long nx, const long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new sparse cell.  <a href="#0116948f7f49876ec550f83d52527708"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#505b38d31765196007662b0cc2aaa796">cspcelltrans</a> (const <a class="el" href="structcspcell.html">cspcell</a> *spc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose a sparse cell.  <a href="#505b38d31765196007662b0cc2aaa796"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#81ac17cb4a76babb27068e2441fef625">cspcellfree_do</a> (<a class="el" href="structcspcell.html">cspcell</a> *spc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a sparse cell data.  <a href="#81ac17cb4a76babb27068e2441fef625"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#8789fe1e884e000a6113f62f0e9d2e63">cspcat</a> (const <a class="el" href="structcsp.html">csp</a> *A, const <a class="el" href="structcsp.html">csp</a> *B, int type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate two sparse array along dim dimension.  <a href="#8789fe1e884e000a6113f62f0e9d2e63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#3b682ec0e120632c083d6e9f5b40a2b3">cspcell2sp</a> (const <a class="el" href="structcspcell.html">cspcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> to sparse array.  <a href="#3b682ec0e120632c083d6e9f5b40a2b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#a3836f4b5764c618db758467cdd24a62">cspsum</a> (const <a class="el" href="structcsp.html">csp</a> *A, int col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sum elements of sparse array along dimension dim.  <a href="#a3836f4b5764c618db758467cdd24a62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#fb8a40bc13c4f0c04b1a1431e7d1a5b5">cspsumabs</a> (const <a class="el" href="structcsp.html">csp</a> *A, int col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sum abs of elements of sparse array along dimension dim.  <a href="#fb8a40bc13c4f0c04b1a1431e7d1a5b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="15d688b55bb9b7ef506cad3f5ccfb772"></a><!-- doxytag: member="csp.h::cspclean" ref="15d688b55bb9b7ef506cad3f5ccfb772" args="(csp *A)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>cspclean</b> (<a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#d212aea4c404ea3b85aa820a02f2fe78">cspcellmulvec</a> (dcomplex *restrict yc, const <a class="el" href="structcspcell.html">cspcell</a> *Ac, const dcomplex *restrict xc, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with vectors.  <a href="#d212aea4c404ea3b85aa820a02f2fe78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#de98f70161730502163dbc410cb5740a">cspdropeps</a> (<a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop elements that are EPS times the largest value.  <a href="#de98f70161730502163dbc410cb5740a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#0fbab7792a907baf7e26798089f67fda">cspcelldropeps</a> (<a class="el" href="structcspcell.html">cspcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop elements that are EPS times the largest value.  <a href="#0fbab7792a907baf7e26798089f67fda"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#6fc1f2acedbe1173af2194167055a1dd">cspsort</a> (<a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make sure the elements are sorted correctly.  <a href="#6fc1f2acedbe1173af2194167055a1dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#6b8d5e45b17827f0ae65b1ced936b49d">cspcellsort</a> (<a class="el" href="structcspcell.html">cspcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make sure the elements are sorted correctly.  <a href="#6b8d5e45b17827f0ae65b1ced936b49d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#f1f35ec3c6167455751a8b1a74f35b99">cspsym</a> (<a class="el" href="structcsp.html">csp</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">symmetricize a X(sp) matrix and drop values below a threshold.  <a href="#f1f35ec3c6167455751a8b1a74f35b99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#63805c61c7ce831fc8255368cdcd4b71">cspcellsym</a> (<a class="el" href="structcspcell.html">cspcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">symmetricize a X(sp) cell and drop values below a threshold.  <a href="#63805c61c7ce831fc8255368cdcd4b71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#293ebbfa0acf47f8783a3493966ad4ba">cspconvolvop</a> (<a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a X(sp) convolution operator C with C(i,j)=A(i-j); A must be very X(sp) with only a view non-zero value otherwise C will be too full.  <a href="#293ebbfa0acf47f8783a3493966ad4ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#f6059c535e9ed5cdff0c4974dd077c6f">cspperm</a> (<a class="el" href="structcsp.html">csp</a> *A, int reverse, long *pcol, long *prow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Permute rows and columns of X(sp) matrix A;.  <a href="#f6059c535e9ed5cdff0c4974dd077c6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#ae348f4ec8480c2f9ad28bf5c7091bd9">cspinvbdiag</a> (const <a class="el" href="structcsp.html">csp</a> *A, long bs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invert a SPD X(sp) matrix that is block diagonal with block sizes of bs.  <a href="#ae348f4ec8480c2f9ad28bf5c7091bd9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csp_8h.html#cecaf203a653ac718dd234bf7119e580">cspblockextract</a> (const <a class="el" href="structcsp.html">csp</a> *A, long bs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extrat the diagonal blocks of size bs into cell arrays.  <a href="#cecaf203a653ac718dd234bf7119e580"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Contains functions for complex sparse <a class="el" href="structcsp.html" title="a sparse array of double complex numbers stored in compressed column format">csp</a>. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="c487a2b9ebd0931e631626a37965fd24"></a><!-- doxytag: member="csp.h::cspnew" ref="c487a2b9ebd0931e631626a37965fd24" args="(long nx, long ny, long nzmax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspnew           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nzmax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a nx*ny X(sp) matrix with memory for nmax max elements allocated. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03217"></a>03217                                              {
<a name="l03218"></a>03218 
<a name="l03219"></a>03219     X(sp) *sp;
<a name="l03220"></a>03220     sp = calloc(1, <span class="keyword">sizeof</span>(X(sp)));
<a name="l03221"></a>03221     <span class="keywordflow">if</span>(nzmax&gt;0){
<a name="l03222"></a>03222     sp-&gt;p=malloc((ny+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l03223"></a>03223     sp-&gt;i=malloc(nzmax*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l03224"></a>03224     sp-&gt;x=malloc(nzmax*<span class="keyword">sizeof</span>(T));
<a name="l03225"></a>03225     }
<a name="l03226"></a>03226     sp-&gt;m=nx;
<a name="l03227"></a>03227     sp-&gt;n=ny;
<a name="l03228"></a>03228     sp-&gt;nzmax=nzmax;
<a name="l03229"></a>03229     sp-&gt;nz=-1;
<a name="l03230"></a>03230     sp-&gt;nref=calloc(1,<span class="keyword">sizeof</span>(T));
<a name="l03231"></a>03231     sp-&gt;nref[0]=1;
<a name="l03232"></a>03232     <span class="keywordflow">return</span> sp;
<a name="l03233"></a>03233 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="80f3f0a59125204877db212a85e8c6c7"></a><!-- doxytag: member="csp.h::cspref" ref="80f3f0a59125204877db212a85e8c6c7" args="(csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspref           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reference a sparse object. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03238"></a>03238                          {
<a name="l03239"></a>03239     X(sp) *out = calloc(1, <span class="keyword">sizeof</span>(X(sp)));
<a name="l03240"></a>03240     <span class="keywordflow">if</span>(!A-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>){
<a name="l03241"></a>03241     A-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>=calloc(1, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l03242"></a>03242     A-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>[0]=1;
<a name="l03243"></a>03243     }
<a name="l03244"></a>03244     memcpy(out,A,<span class="keyword">sizeof</span>(X(sp)));
<a name="l03245"></a>03245     out-&gt;nref[0]++;
<a name="l03246"></a>03246     <span class="keywordflow">return</span> out;
<a name="l03247"></a>03247 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6f0c670abe3c96cce9afb0f0e733b350"></a><!-- doxytag: member="csp.h::cspdup" ref="6f0c670abe3c96cce9afb0f0e733b350" args="(const csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspdup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy a X(sp) matrix to another. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03252"></a>03252                                {
<a name="l03253"></a>03253     <span class="keywordtype">long</span> nmax=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>];
<a name="l03254"></a>03254     X(sp) *out;
<a name="l03255"></a>03255     out=Y(spnew)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, nmax);
<a name="l03256"></a>03256     memcpy(out-&gt;p, A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*(A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>+1));
<a name="l03257"></a>03257     memcpy(out-&gt;i, A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*nmax);
<a name="l03258"></a>03258     memcpy(out-&gt;x, A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>, <span class="keyword">sizeof</span>(T)*nmax);
<a name="l03259"></a>03259     <span class="keywordflow">return</span> out;
<a name="l03260"></a>03260 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="978de1ab5d2901e086f61668140f7339"></a><!-- doxytag: member="csp.h::cspmove" ref="978de1ab5d2901e086f61668140f7339" args="(csp *A, csp *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmove           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
move the matrix from res to A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03265"></a>03265                                     {
<a name="l03266"></a>03266     <span class="keywordflow">if</span>(!res || !A) 
<a name="l03267"></a>03267     error(<span class="stringliteral">"Trying to move an NULL matrix\n"</span>);
<a name="l03268"></a>03268     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>){
<a name="l03269"></a>03269     free(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>); 
<a name="l03270"></a>03270     free(A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>); 
<a name="l03271"></a>03271     free(A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>); 
<a name="l03272"></a>03272     free(A-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>);
<a name="l03273"></a>03273     }
<a name="l03274"></a>03274     memcpy(A,res,<span class="keyword">sizeof</span>(X(sp)));
<a name="l03275"></a>03275     free(res);
<a name="l03276"></a>03276 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ba26181f356f45e0c66bb677a6c32698"></a><!-- doxytag: member="csp.h::cspnew2" ref="ba26181f356f45e0c66bb677a6c32698" args="(const csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspnew2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(sp) matrix of the same size as A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03281"></a>03281                                 {
<a name="l03282"></a>03282     <span class="keywordflow">return</span> Y(spnew)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]);
<a name="l03283"></a>03283 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="491f95a564ed7edeb3ed3c2bc8c76575"></a><!-- doxytag: member="csp.h::cspnewrandu" ref="491f95a564ed7edeb3ed3c2bc8c76575" args="(int nx, int ny, const dcomplex mean, double fill, mt_state *rstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspnewrandu           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmt__state.html">mt_state</a> *&nbsp;</td>
          <td class="paramname"> <em>rstat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(sp) matrix and fill in uniform random numbers with filling factor of 'fill'. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03303"></a>03303                                             {
<a name="l03304"></a>03304     <span class="keywordflow">if</span>(fill&gt;1) fill=1.;
<a name="l03305"></a>03305     <span class="keywordflow">if</span>(fill&lt;0) fill=0.;
<a name="l03306"></a>03306     <span class="keyword">const</span> <span class="keywordtype">long</span> nzmax=nx*ny;
<a name="l03307"></a>03307     <span class="keywordtype">long</span> nz1=nx*ny*fill*4;
<a name="l03308"></a>03308     <span class="keywordflow">if</span>(nz1&gt;nzmax) nz1=nzmax;
<a name="l03309"></a>03309     X(sp) *A=Y(spnew)(nx,ny,nz1);
<a name="l03310"></a>03310     <span class="keywordtype">long</span> *pp=A-&gt;p;
<a name="l03311"></a>03311     <span class="keywordtype">long</span> *pi=A-&gt;i;
<a name="l03312"></a>03312     T *px=A-&gt;x;
<a name="l03313"></a>03313     <span class="keywordtype">long</span> count=0;
<a name="l03314"></a>03314     <span class="keywordtype">double</span> thres=1.-fill;
<a name="l03315"></a>03315     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;n; icol++){
<a name="l03316"></a>03316     pp[icol]=count;
<a name="l03317"></a>03317     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=0; irow&lt;A-&gt;m; irow++){
<a name="l03318"></a>03318         <span class="keywordflow">if</span>(randu(rstat)&gt;thres){
<a name="l03319"></a>03319         pi[count]=irow;
<a name="l03320"></a>03320         px[count]=RANDU(rstat)*mean;
<a name="l03321"></a>03321         count++;
<a name="l03322"></a>03322         <span class="keywordflow">if</span>(count&gt;nz1){
<a name="l03323"></a>03323             <span class="comment">//check out of bound;</span>
<a name="l03324"></a>03324             nz1=nz1*2; <span class="keywordflow">if</span>(nz1&gt;nzmax) nz1=nzmax;
<a name="l03325"></a>03325             Y(spsetnzmax)(A,nz1);
<a name="l03326"></a>03326             <span class="comment">//the pointers may change</span>
<a name="l03327"></a>03327             pp=A-&gt;p;
<a name="l03328"></a>03328             pi=A-&gt;i;
<a name="l03329"></a>03329             px=A-&gt;x;
<a name="l03330"></a>03330         }
<a name="l03331"></a>03331         }
<a name="l03332"></a>03332     }
<a name="l03333"></a>03333     }
<a name="l03334"></a>03334     pp[A-&gt;n]=count;
<a name="l03335"></a>03335     Y(spsetnzmax)(A,count);
<a name="l03336"></a>03336     <span class="keywordflow">return</span> A;
<a name="l03337"></a>03337 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0f62850af8a0a48f2cc063bf95df8856"></a><!-- doxytag: member="csp.h::cspsetnzmax" ref="0f62850af8a0a48f2cc063bf95df8856" args="(csp *sp, long nzmax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspsetnzmax           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nzmax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
resize a X(sp) matrix 
<p>
<div class="fragment"><pre class="fragment"><a name="l03328"></a>03328                                          {
<a name="l03329"></a>03329     <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#1ac262485faf97bba7f808626854a480" title="maximum number of entries">nzmax</a>!=nzmax){
<a name="l03330"></a>03330     sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>=realloc(sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*nzmax);
<a name="l03331"></a>03331     sp-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>=realloc(sp-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>, <span class="keyword">sizeof</span>(T)*nzmax);
<a name="l03332"></a>03332     sp-&gt;<a class="code" href="structcsp.html#1ac262485faf97bba7f808626854a480" title="maximum number of entries">nzmax</a>=nzmax;
<a name="l03333"></a>03333     }
<a name="l03334"></a>03334 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4ae0a8c3586b6bc85cc273b3217b2db4"></a><!-- doxytag: member="csp.h::cspfree_do" ref="4ae0a8c3586b6bc85cc273b3217b2db4" args="(csp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(sp) matrix 
<p>
<div class="fragment"><pre class="fragment"><a name="l03337"></a>03337                             {
<a name="l03338"></a>03338     <span class="keywordflow">if</span>(!sp) <span class="keywordflow">return</span>;
<a name="l03339"></a>03339     <span class="keywordflow">if</span>(!sp-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a> || sp-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>[0]&lt;=1){
<a name="l03340"></a>03340     <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>[0]!=1){
<a name="l03341"></a>03341         warning(<span class="stringliteral">"nref should nevre be less than 1\n"</span>);
<a name="l03342"></a>03342     }
<a name="l03343"></a>03343     free(sp-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>);
<a name="l03344"></a>03344     free(sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>);
<a name="l03345"></a>03345     free(sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>);
<a name="l03346"></a>03346     <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>){
<a name="l03347"></a>03347         free(sp-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>);
<a name="l03348"></a>03348     }<span class="keywordflow">else</span>{
<a name="l03349"></a>03349         warning(<span class="stringliteral">"X(sp) was corrected incorrectly\n"</span>);
<a name="l03350"></a>03350     }
<a name="l03351"></a>03351     }<span class="keywordflow">else</span>{
<a name="l03352"></a>03352     sp-&gt;<a class="code" href="structcsp.html#958127f0cf4c4f832662333c548bb127" title="reference counting like cmat">nref</a>[0]--;
<a name="l03353"></a>03353     <span class="comment">//warning("data is retained. nref=%ld\n",sp-&gt;nref[0]);</span>
<a name="l03354"></a>03354     }
<a name="l03355"></a>03355     free(sp);
<a name="l03356"></a>03356 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d23c83475ff51aac1ee3fc9aaa58d490"></a><!-- doxytag: member="csp.h::csparrfree" ref="d23c83475ff51aac1ee3fc9aaa58d490" args="(csp **sparr, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csparrfree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> **&nbsp;</td>
          <td class="paramname"> <em>sparr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(sp) array 
<p>
<div class="fragment"><pre class="fragment"><a name="l03359"></a>03359                                        {
<a name="l03360"></a>03360     <span class="keywordtype">int</span> i;
<a name="l03361"></a>03361     <span class="keywordflow">if</span>(sparr){
<a name="l03362"></a>03362     <span class="keywordflow">for</span>(i=0; i&lt;n; i++){
<a name="l03363"></a>03363         Y(spfree)(sparr[i]);
<a name="l03364"></a>03364     }
<a name="l03365"></a>03365     free(sparr); 
<a name="l03366"></a>03366     }
<a name="l03367"></a>03367 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dc5754766a10048b0412d4fd7d6d4f21"></a><!-- doxytag: member="csp.h::cspdisp" ref="dc5754766a10048b0412d4fd7d6d4f21" args="(const csp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspdisp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Display a X(sp) array. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03370"></a>03370                                {
<a name="l03371"></a>03371     <span class="keywordtype">long</span> ic,ir;
<a name="l03372"></a>03372     <span class="keywordtype">long</span> imax;
<a name="l03373"></a>03373     <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#1ac262485faf97bba7f808626854a480" title="maximum number of entries">nzmax</a>==0){
<a name="l03374"></a>03374     info(<span class="stringliteral">"Y(spdisp): All zeros\n"</span>);
<a name="l03375"></a>03375     }<span class="keywordflow">else</span>{
<a name="l03376"></a>03376     info(<span class="stringliteral">"Y(spdisp):\n"</span>);
<a name="l03377"></a>03377     <span class="keywordflow">for</span>(ic=0; ic&lt;sp-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; ic++){
<a name="l03378"></a>03378         imax=-1;
<a name="l03379"></a>03379         <span class="keywordflow">for</span>(ir=sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[ic];ir&lt;sp-&gt;p[ic+1];ir++){ 
<a name="l03380"></a>03380 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l03381"></a>03381 <span class="preprocessor"></span>        printf(<span class="stringliteral">"(%ld,%ld)=(%g,%g)\n"</span>, 
<a name="l03382"></a>03382                sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ir], ic, creal(sp-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ir]),cimag(sp-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ir]));
<a name="l03383"></a>03383 <span class="preprocessor">#else       </span>
<a name="l03384"></a>03384 <span class="preprocessor"></span>        printf(<span class="stringliteral">"(%ld,%ld)=%g\n"</span>, sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ir], ic, sp-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ir]);
<a name="l03385"></a>03385 <span class="preprocessor">#endif</span>
<a name="l03386"></a>03386 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ir]&gt;imax){
<a name="l03387"></a>03387             imax=sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ir];
<a name="l03388"></a>03388         }<span class="keywordflow">else</span>{
<a name="l03389"></a>03389             warning(<span class="stringliteral">"Wrong order"</span>);
<a name="l03390"></a>03390         }
<a name="l03391"></a>03391         }
<a name="l03392"></a>03392     }
<a name="l03393"></a>03393     }
<a name="l03394"></a>03394 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="da6187466a85d6d4471143963d1a0b35"></a><!-- doxytag: member="csp.h::cspcheck" ref="da6187466a85d6d4471143963d1a0b35" args="(const csp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcheck           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check a X(sp) array for wrong orders. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03397"></a>03397                                 {
<a name="l03398"></a>03398     <span class="keywordflow">if</span>(sp){
<a name="l03399"></a>03399     <span class="keywordtype">long</span> ic,ir;
<a name="l03400"></a>03400     <span class="keywordtype">long</span> imax;
<a name="l03401"></a>03401     <span class="keywordflow">for</span>(ic=0; ic&lt;sp-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; ic++){
<a name="l03402"></a>03402         imax=-1;
<a name="l03403"></a>03403         <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[ic+1]&lt;sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[ic]){
<a name="l03404"></a>03404         error(<span class="stringliteral">"p in column %ld is smaller than %ld\n"</span>,ic+1,ic);
<a name="l03405"></a>03405         }
<a name="l03406"></a>03406         <span class="keywordflow">for</span>(ir=sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[ic];ir&lt;sp-&gt;p[ic+1];ir++){ 
<a name="l03407"></a>03407         <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ir]&gt;imax){
<a name="l03408"></a>03408             imax=sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ir];
<a name="l03409"></a>03409         }<span class="keywordflow">else</span>{
<a name="l03410"></a>03410             warning(<span class="stringliteral">"Wrong order at column %ld"</span>,ic);
<a name="l03411"></a>03411         }
<a name="l03412"></a>03412         }
<a name="l03413"></a>03413         <span class="keywordflow">if</span>(imax&gt;=sp-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>){
<a name="l03414"></a>03414         error(<span class="stringliteral">"imax=%ld exceeds column size at column %ld\n"</span>,imax,ic);
<a name="l03415"></a>03415         }
<a name="l03416"></a>03416     }
<a name="l03417"></a>03417     <span class="keywordflow">if</span>(sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[sp-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]!=sp-&gt;<a class="code" href="structcsp.html#1ac262485faf97bba7f808626854a480" title="maximum number of entries">nzmax</a>){
<a name="l03418"></a>03418         warning(<span class="stringliteral">"real nzmax is %ld, allocated is %ld\n"</span>,sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[sp-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>],sp-&gt;<a class="code" href="structcsp.html#1ac262485faf97bba7f808626854a480" title="maximum number of entries">nzmax</a>);
<a name="l03419"></a>03419     }
<a name="l03420"></a>03420     }
<a name="l03421"></a>03421 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dd8d261f3e339da0ae0b34f77c49efe5"></a><!-- doxytag: member="csp.h::cspscale" ref="dd8d261f3e339da0ae0b34f77c49efe5" args="(csp *A, const dcomplex beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace scale X(sp) matrix elements. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03424"></a>03424                                        {
<a name="l03425"></a>03425     <span class="keywordflow">if</span>(A){
<a name="l03426"></a>03426     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]; i++){
<a name="l03427"></a>03427         A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[i]*=beta;
<a name="l03428"></a>03428     }
<a name="l03429"></a>03429     }
<a name="l03430"></a>03430 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="abcc5d0cae60d4f3dc19a6c3465a873e"></a><!-- doxytag: member="csp.h::cspcellscale" ref="abcc5d0cae60d4f3dc19a6c3465a873e" args="(cspcell *A, const dcomplex beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace scale a X(spcell) object 
<p>
<div class="fragment"><pre class="fragment"><a name="l03433"></a>03433                                                {
<a name="l03434"></a>03434     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; i++){
<a name="l03435"></a>03435     Y(spscale)(A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[i],beta);
<a name="l03436"></a>03436     }
<a name="l03437"></a>03437 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1cb1312e34d6d65db22b2277ef34080c"></a><!-- doxytag: member="csp.h::cspnewdiag" ref="1cb1312e34d6d65db22b2277ef34080c" args="(long N, dcomplex *vec, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspnewdiag           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex *&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new sparse matrix with diagonal elements set to vec*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03440"></a>03440                                             {
<a name="l03441"></a>03441     X(sp) *out=Y(spnew)(N,N,N);
<a name="l03442"></a>03442     <span class="keywordtype">long</span> *pp=out-&gt;p;
<a name="l03443"></a>03443     <span class="keywordtype">long</span> *pi=out-&gt;i;
<a name="l03444"></a>03444     T *px=out-&gt;x;
<a name="l03445"></a>03445     <span class="keywordtype">long</span> count=0;
<a name="l03446"></a>03446     <span class="keywordflow">if</span>(vec){
<a name="l03447"></a>03447     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;out-&gt;n; icol++){
<a name="l03448"></a>03448         pp[icol]=count;
<a name="l03449"></a>03449         pi[count]=icol;
<a name="l03450"></a>03450         px[count]=vec[icol]*alpha;
<a name="l03451"></a>03451         count++;
<a name="l03452"></a>03452     }
<a name="l03453"></a>03453     }<span class="keywordflow">else</span>{
<a name="l03454"></a>03454     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;out-&gt;n; icol++){
<a name="l03455"></a>03455         pp[icol]=count;
<a name="l03456"></a>03456         pi[count]=icol;
<a name="l03457"></a>03457         px[count]=alpha;
<a name="l03458"></a>03458         count++;
<a name="l03459"></a>03459     }
<a name="l03460"></a>03460     }
<a name="l03461"></a>03461     pp[out-&gt;n]=count;
<a name="l03462"></a>03462     <span class="keywordflow">return</span> out;
<a name="l03463"></a>03463 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="78a7b8edb5848dbeefb21d3f04eb66e6"></a><!-- doxytag: member="csp.h::cspdiag" ref="78a7b8edb5848dbeefb21d3f04eb66e6" args="(const csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cspdiag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract diagonal element of A and return. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03467"></a>03467                                  {
<a name="l03468"></a>03468     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>!=A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>){
<a name="l03469"></a>03469     error(<span class="stringliteral">"Only work for square matrix\n"</span>);
<a name="l03470"></a>03470     }
<a name="l03471"></a>03471     X(mat) *out=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>,1);
<a name="l03472"></a>03472     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03473"></a>03473     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l03474"></a>03474         <span class="keywordtype">long</span> row=A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[irow];
<a name="l03475"></a>03475         <span class="keywordflow">if</span>(row==icol){
<a name="l03476"></a>03476         out-&gt;p[icol]=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[irow];
<a name="l03477"></a>03477         }
<a name="l03478"></a>03478     }
<a name="l03479"></a>03479     }
<a name="l03480"></a>03480     <span class="keywordflow">return</span> out;
<a name="l03481"></a>03481 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="41e52911fa532cd4d5651e2a9c75e91d"></a><!-- doxytag: member="csp.h::cspmuldiag" ref="41e52911fa532cd4d5651e2a9c75e91d" args="(csp *restrict A, const dcomplex *w, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmuldiag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a X(sp) matrix inplace with a diagonal weighting matrix whose diagonal values are stored in w. 
<p>
W_ii=w_i; W_ij=0 if i!=j A=A*W*alpha; W is a diagonal X(sp) matrix. diag(W) is w multiply w[i] to all numbers in column[i] <div class="fragment"><pre class="fragment"><a name="l03490"></a>03490                                                          {
<a name="l03491"></a>03491     <span class="keywordflow">if</span>(A &amp;&amp; w){
<a name="l03492"></a>03492     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03493"></a>03493         <span class="keyword">const</span> T wi=w[icol]*alpha;
<a name="l03494"></a>03494         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03495"></a>03495         A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*=wi;
<a name="l03496"></a>03496         }
<a name="l03497"></a>03497     }
<a name="l03498"></a>03498     }
<a name="l03499"></a>03499 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8e28cfb4fabbf2ca0080e55d488304a3"></a><!-- doxytag: member="csp.h::cspmulvec_thread" ref="8e28cfb4fabbf2ca0080e55d488304a3" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, dcomplex alpha, int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmulvec_thread           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a sparse with a vector using multithread. 
<p>
Speed up is not signicant because need to allocate new memory. <div class="fragment"><pre class="fragment"><a name="l03549"></a>03549                                                        {
<a name="l03550"></a>03550     <span class="keywordflow">if</span>(!A || !x) <span class="keywordflow">return</span>;    
<a name="l03551"></a>03551     assert(y);
<a name="l03552"></a>03552     <span class="keywordflow">if</span>(nthread&lt;=1){
<a name="l03553"></a>03553     <span class="comment">/* </span>
<a name="l03554"></a>03554 <span class="comment">       When I did the timing, calling spmulvec is twice as slow as calling</span>
<a name="l03555"></a>03555 <span class="comment">       spmulvec directly from the calling routine. I don't understand.</span>
<a name="l03556"></a>03556 <span class="comment">    */</span>
<a name="l03557"></a>03557     <span class="keywordtype">long</span> icol, ix;
<a name="l03558"></a>03558     <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l03559"></a>03559         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03560"></a>03560         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03561"></a>03561             y[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*x[icol];
<a name="l03562"></a>03562         }
<a name="l03563"></a>03563         }
<a name="l03564"></a>03564     }<span class="keywordflow">else</span>{
<a name="l03565"></a>03565         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03566"></a>03566         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03567"></a>03567             y[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=alpha*A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*x[icol];
<a name="l03568"></a>03568         }
<a name="l03569"></a>03569         }
<a name="l03570"></a>03570     }
<a name="l03571"></a>03571     }<span class="keywordflow">else</span>{
<a name="l03572"></a>03572     sp_thread_t data;
<a name="l03573"></a>03573     data.A=A;
<a name="l03574"></a>03574     data.y=y;
<a name="l03575"></a>03575     data.<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>=x;
<a name="l03576"></a>03576     data.alpha=alpha;
<a name="l03577"></a>03577     data.ytmp=calloc(nthread,<span class="keyword">sizeof</span>(T*));
<a name="l03578"></a>03578     data.nthread=nthread;
<a name="l03579"></a>03579     thread_t mul[nthread];
<a name="l03580"></a>03580     thread_t acc[nthread];
<a name="l03581"></a>03581     thread_prep(mul, 0, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, 0, nthread, &amp;data);
<a name="l03582"></a>03582     CALL_EACH(Y(spmulvec_thread_do_mul), mul, nthread);
<a name="l03583"></a>03583     thread_prep(acc, 0, A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, 0, nthread, &amp;data);
<a name="l03584"></a>03584     CALL_EACH(Y(spmulvec_thread_do_acc), acc, nthread);
<a name="l03585"></a>03585     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ithread=0; ithread&lt;nthread; ithread++){
<a name="l03586"></a>03586         free(data.ytmp[ithread]);
<a name="l03587"></a>03587     }
<a name="l03588"></a>03588     free(data.ytmp);
<a name="l03589"></a>03589     }
<a name="l03590"></a>03590 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="54fc8f015cdea3064a1dd4d404e428c1"></a><!-- doxytag: member="csp.h::cspmulvec" ref="54fc8f015cdea3064a1dd4d404e428c1" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmulvec           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
sparse matrix multiply with a vector 
<p>
<div class="fragment"><pre class="fragment"><a name="l03594"></a>03594                                        {
<a name="l03595"></a>03595     <span class="keywordflow">if</span>(A &amp;&amp; x){
<a name="l03596"></a>03596     <span class="keywordtype">long</span> icol, ix;
<a name="l03597"></a>03597     assert(y);
<a name="l03598"></a>03598     <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l03599"></a>03599         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03600"></a>03600         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03601"></a>03601             y[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*x[icol];
<a name="l03602"></a>03602         }
<a name="l03603"></a>03603         }
<a name="l03604"></a>03604     }<span class="keywordflow">else</span>{
<a name="l03605"></a>03605         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03606"></a>03606         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03607"></a>03607             y[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=alpha*A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*x[icol];
<a name="l03608"></a>03608         }
<a name="l03609"></a>03609         }
<a name="l03610"></a>03610     }
<a name="l03611"></a>03611     }
<a name="l03612"></a>03612 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9a5940fca0abf0d7876eafd923bc78e9"></a><!-- doxytag: member="csp.h::cspmulcreal" ref="9a5940fca0abf0d7876eafd923bc78e9" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmulcreal           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a sparse matrix with the real part of a complex vector. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03701"></a>03701                    {
<a name="l03702"></a>03702     <span class="comment">//y=y+alpha*A*creal(x);</span>
<a name="l03703"></a>03703     <span class="keywordflow">if</span>(A &amp;&amp; x){
<a name="l03704"></a>03704     <span class="keywordtype">long</span> icol, ix;
<a name="l03705"></a>03705     <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l03706"></a>03706         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03707"></a>03707         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03708"></a>03708             y[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*creal(x[icol]);
<a name="l03709"></a>03709         }
<a name="l03710"></a>03710         }
<a name="l03711"></a>03711     }<span class="keywordflow">else</span>{
<a name="l03712"></a>03712         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03713"></a>03713         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03714"></a>03714             y[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=alpha*A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*creal(x[icol]);
<a name="l03715"></a>03715         }
<a name="l03716"></a>03716         }
<a name="l03717"></a>03717     }
<a name="l03718"></a>03718     }
<a name="l03719"></a>03719 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ae38da51fa42e1dba34308f3e27b068b"></a><!-- doxytag: member="csp.h::csptmulvec" ref="ae38da51fa42e1dba34308f3e27b068b" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptmulvec           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply transpose of a sparse matrix with a vector. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03677"></a>03677                                              {
<a name="l03678"></a>03678     <span class="keywordflow">if</span>(A &amp;&amp; x){
<a name="l03679"></a>03679     <span class="comment">//y=y+alpha*A'*x;</span>
<a name="l03680"></a>03680     assert(y);
<a name="l03681"></a>03681     <span class="keywordtype">long</span> icol, ix;
<a name="l03682"></a>03682     <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l03683"></a>03683         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03684"></a>03684         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03685"></a>03685             y[icol]+=CONJ(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix])*x[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]];
<a name="l03686"></a>03686         }
<a name="l03687"></a>03687         }
<a name="l03688"></a>03688     }<span class="keywordflow">else</span>{
<a name="l03689"></a>03689         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03690"></a>03690         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03691"></a>03691             y[icol]+=alpha*CONJ(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix])*x[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]];
<a name="l03692"></a>03692         }
<a name="l03693"></a>03693         }
<a name="l03694"></a>03694     }
<a name="l03695"></a>03695     }
<a name="l03696"></a>03696 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9c9f61dd9e10e0a18545069dd3a493bb"></a><!-- doxytag: member="csp.h::csptmulvec_thread" ref="9c9f61dd9e10e0a18545069dd3a493bb" args="(dcomplex *restrict y, const csp *A, const dcomplex *restrict x, const dcomplex alpha, int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptmulvec_thread           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Threaded version of sptmulvec. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03642"></a>03642                                                              {
<a name="l03643"></a>03643     tic;
<a name="l03644"></a>03644     <span class="keywordflow">if</span>(!A || !x) <span class="keywordflow">return</span>;
<a name="l03645"></a>03645     assert(y);
<a name="l03646"></a>03646     <span class="keywordflow">if</span>(nthread&lt;=1){
<a name="l03647"></a>03647     <span class="keywordtype">long</span> icol, ix;
<a name="l03648"></a>03648     <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l03649"></a>03649         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03650"></a>03650         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03651"></a>03651             y[icol]+=CONJ(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix])*x[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]];
<a name="l03652"></a>03652         }
<a name="l03653"></a>03653         }
<a name="l03654"></a>03654     }<span class="keywordflow">else</span>{
<a name="l03655"></a>03655         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03656"></a>03656         <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03657"></a>03657             y[icol]+=alpha*CONJ(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix])*x[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]];
<a name="l03658"></a>03658         }
<a name="l03659"></a>03659         }
<a name="l03660"></a>03660     }
<a name="l03661"></a>03661     }<span class="keywordflow">else</span>{
<a name="l03662"></a>03662     sp_thread_t data;
<a name="l03663"></a>03663     data.A=A;
<a name="l03664"></a>03664     data.y=y;
<a name="l03665"></a>03665     data.<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>=x;
<a name="l03666"></a>03666     data.alpha=alpha;
<a name="l03667"></a>03667     data.nthread=nthread;
<a name="l03668"></a>03668     thread_t mul[nthread];
<a name="l03669"></a>03669     thread_prep(mul, 0, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, 0, nthread, &amp;data);<span class="comment">//interlaced is not good.</span>
<a name="l03670"></a>03670     toc(<span class="stringliteral">"prep"</span>);
<a name="l03671"></a>03671     CALL_EACH(Y(sptmulvec_thread_do), mul, nthread);
<a name="l03672"></a>03672     }
<a name="l03673"></a>03673 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="979d62d76e351b60cb8ce8f270a1b866"></a><!-- doxytag: member="csp.h::cspmulmat" ref="979d62d76e351b60cb8ce8f270a1b866" args="(cmat **yout, const csp *A, const cmat *x, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a sparse matrix X(sp) with a dense matrix X(mat). 
<p>
<div class="fragment"><pre class="fragment"><a name="l03724"></a>03724                        {
<a name="l03725"></a>03725     <span class="keywordflow">if</span>(A&amp;&amp;x){
<a name="l03726"></a>03726     <span class="comment">// y=y+alpha*A*x;</span>
<a name="l03727"></a>03727     <span class="keywordtype">long</span> icol, ix;
<a name="l03728"></a>03728     <span class="keywordflow">if</span>(!*yout){
<a name="l03729"></a>03729         *yout=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>); 
<a name="l03730"></a>03730     }
<a name="l03731"></a>03731     X(mat) *y=*yout;
<a name="l03732"></a>03732     assert(x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==y-&gt;ny);
<a name="l03733"></a>03733     assert(A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>==x-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>);
<a name="l03734"></a>03734     <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1){
<a name="l03735"></a>03735         Y(spmulvec)(y-&gt;p, A, x-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>,  alpha);
<a name="l03736"></a>03736     }<span class="keywordflow">else</span>{
<a name="l03737"></a>03737         <span class="keywordtype">int</span> jcol;
<a name="l03738"></a>03738         T (* restrict Y)[y-&gt;nx]=(T(*)[y-&gt;nx])y-&gt;p;
<a name="l03739"></a>03739         T (* restrict X)[x-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>]=(T(*)[x-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>])x-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l03740"></a>03740         <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l03741"></a>03741         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03742"></a>03742             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03743"></a>03743             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;ny; jcol++){
<a name="l03744"></a>03744                 Y[jcol][A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*X[jcol][icol];
<a name="l03745"></a>03745             }
<a name="l03746"></a>03746             }
<a name="l03747"></a>03747         }
<a name="l03748"></a>03748         }<span class="keywordflow">else</span>{
<a name="l03749"></a>03749         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03750"></a>03750             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03751"></a>03751             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;ny; jcol++){
<a name="l03752"></a>03752                 Y[jcol][A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]+=alpha*A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*X[jcol][icol];
<a name="l03753"></a>03753             }
<a name="l03754"></a>03754             }
<a name="l03755"></a>03755         }
<a name="l03756"></a>03756         }
<a name="l03757"></a>03757     }
<a name="l03758"></a>03758     }
<a name="l03759"></a>03759 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d33258da06cc2612c4c7c66e5af5306b"></a><!-- doxytag: member="csp.h::csptmulmat" ref="d33258da06cc2612c4c7c66e5af5306b" args="(cmat **yout, const csp *A, const cmat *x, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
y=y+alpha*A'*x; 
<p>
<div class="fragment"><pre class="fragment"><a name="l03763"></a>03763                                                                                 {
<a name="l03764"></a>03764     <span class="keywordflow">if</span>(A&amp;&amp;x){
<a name="l03765"></a>03765     <span class="keywordtype">long</span> icol, ix;
<a name="l03766"></a>03766     <span class="keywordflow">if</span>(!*yout){
<a name="l03767"></a>03767         *yout=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l03768"></a>03768     }
<a name="l03769"></a>03769     X(mat) *y=*yout;
<a name="l03770"></a>03770     assert(x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==y-&gt;ny);
<a name="l03771"></a>03771     <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1){
<a name="l03772"></a>03772         Y(sptmulvec)(y-&gt;p, A, x-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, alpha);
<a name="l03773"></a>03773     }<span class="keywordflow">else</span>{
<a name="l03774"></a>03774         <span class="keywordtype">int</span> jcol;
<a name="l03775"></a>03775         PMAT(x,X);PMAT(y,Y);
<a name="l03776"></a>03776         <span class="comment">//T (* restrict Y)[y-&gt;nx]=(T(*)[y-&gt;nx])y-&gt;p;</span>
<a name="l03777"></a>03777         <span class="comment">//T (* restrict X)[x-&gt;nx]=(T(*)[x-&gt;nx])x-&gt;p;</span>
<a name="l03778"></a>03778         <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;EPS){
<a name="l03779"></a>03779         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03780"></a>03780             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03781"></a>03781             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;ny; jcol++){
<a name="l03782"></a>03782                 Y[jcol][icol]+=CONJ(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix])*X[jcol][A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]];
<a name="l03783"></a>03783             }
<a name="l03784"></a>03784             }
<a name="l03785"></a>03785         }
<a name="l03786"></a>03786         }<span class="keywordflow">else</span>{
<a name="l03787"></a>03787         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03788"></a>03788             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03789"></a>03789             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;ny; jcol++){
<a name="l03790"></a>03790                 Y[jcol][icol]+=alpha*CONJ(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix])*X[jcol][A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]];
<a name="l03791"></a>03791             }
<a name="l03792"></a>03792             }
<a name="l03793"></a>03793         }
<a name="l03794"></a>03794         }
<a name="l03795"></a>03795     }
<a name="l03796"></a>03796     }
<a name="l03797"></a>03797 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="084a73490868acd8a291793aabbad3a5"></a><!-- doxytag: member="csp.h::cspwdinn" ref="084a73490868acd8a291793aabbad3a5" args="(const cmat *y, const csp *A, const cmat *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cspwdinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two matrices with weighting by sparse matrix. 
<p>
return y'*(A*x) <div class="fragment"><pre class="fragment"><a name="l03800"></a>03800                                                               {
<a name="l03801"></a>03801     <span class="comment">//X(sp) weighted ddot.</span>
<a name="l03802"></a>03802     <span class="comment">//computes y'*(A*x). x,y are vectors</span>
<a name="l03803"></a>03803     T res=0;
<a name="l03804"></a>03804     <span class="keywordflow">if</span>(x &amp;&amp; y){
<a name="l03805"></a>03805     <span class="keywordflow">if</span>(A){
<a name="l03806"></a>03806         assert(x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1 &amp;&amp; y-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1 &amp;&amp; A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>==y-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> &amp;&amp; A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>==x-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>);
<a name="l03807"></a>03807         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03808"></a>03808         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03809"></a>03809             res+=y-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]]*A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*x-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[icol];
<a name="l03810"></a>03810         }
<a name="l03811"></a>03811         }
<a name="l03812"></a>03812     }<span class="keywordflow">else</span>{
<a name="l03813"></a>03813         res=X(inn)(x,y);
<a name="l03814"></a>03814     }
<a name="l03815"></a>03815     }
<a name="l03816"></a>03816     <span class="keywordflow">return</span> res;
<a name="l03817"></a>03817 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d52ad07f584725c01825cd2e1fa38724"></a><!-- doxytag: member="csp.h::cspcellwdinn" ref="d52ad07f584725c01825cd2e1fa38724" args="(const ccell *y, const cspcell *A, const ccell *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cspcellwdinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two cell arrays with weighting by sparse matrix. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03820"></a>03820                                                                         {
<a name="l03821"></a>03821     <span class="comment">//computes y'*(A*x)</span>
<a name="l03822"></a>03822     T res=0;
<a name="l03823"></a>03823     <span class="keywordflow">if</span>(x &amp;&amp; y){
<a name="l03824"></a>03824     <span class="keywordflow">if</span>(A){
<a name="l03825"></a>03825         assert(x-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>==1 &amp;&amp; y-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>==1 &amp;&amp; A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>==y-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a> &amp;&amp; A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>==x-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>);
<a name="l03826"></a>03826         X(sp) *(*Ap)[A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>]=(X(sp) *(*)[A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>])A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>;
<a name="l03827"></a>03827         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;ny; iy++){
<a name="l03828"></a>03828         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>; ix++){
<a name="l03829"></a>03829             res+=Y(spwdinn)(y-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[ix], Ap[iy][ix], x-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[iy]);
<a name="l03830"></a>03830         }
<a name="l03831"></a>03831         }
<a name="l03832"></a>03832     }<span class="keywordflow">else</span>{
<a name="l03833"></a>03833         res = X(cellinn)(x,y);
<a name="l03834"></a>03834     }
<a name="l03835"></a>03835     }
<a name="l03836"></a>03836     <span class="keywordflow">return</span> res;
<a name="l03837"></a>03837 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e0baf2d188be6beae581db14384e88d1"></a><!-- doxytag: member="csp.h::cspcellmulmat" ref="e0baf2d188be6beae581db14384e88d1" args="(ccell **C, const cspcell *A, const ccell *B, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with a dense cell: C=C+A*B*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03877"></a>03877                                                                                     {
<a name="l03878"></a>03878     <span class="keywordflow">return</span> Y(spcellmulmat2)(C,A,B,alpha,0);
<a name="l03879"></a>03879 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2ae96154a8e626b25e038fda1af50032"></a><!-- doxytag: member="csp.h::csptcellmulmat" ref="2ae96154a8e626b25e038fda1af50032" args="(ccell **C, const cspcell *A, const ccell *B, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptcellmulmat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
C=C+A'*B*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03882"></a>03882                                                                                      {
<a name="l03883"></a>03883     <span class="keywordflow">return</span> Y(spcellmulmat2)(C,A,B,alpha,1);
<a name="l03884"></a>03884 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="55b1761ed410406c557bf8e650aa5f61"></a><!-- doxytag: member="csp.h::cspcellmulmat_thread" ref="55b1761ed410406c557bf8e650aa5f61" args="(ccell **C, const cspcell *A, const ccell *B, const dcomplex alpha, const int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellmulmat_thread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
threaded version of Y(spcellmulmat) 
<p>
<div class="fragment"><pre class="fragment"><a name="l03945"></a>03945                                   {
<a name="l03946"></a>03946     Y(spcellmulmat_thread2)(C,A,B,alpha,0,nthread);
<a name="l03947"></a>03947 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2016cdf467cae24f45f30eb7cd4c236b"></a><!-- doxytag: member="csp.h::csptcellmulmat_thread" ref="2016cdf467cae24f45f30eb7cd4c236b" args="(ccell **C, const cspcell *A, const ccell *B, const dcomplex alpha, const int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptcellmulmat_thread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
threaded version of Y(sptcellmulmat 
<p>
<div class="fragment"><pre class="fragment"><a name="l03952"></a>03952                                    {
<a name="l03953"></a>03953     Y(spcellmulmat_thread2)(C,A,B,alpha,1,nthread);
<a name="l03954"></a>03954 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6644c43d1ac2abf3b7767935a5e2ab46"></a><!-- doxytag: member="csp.h::cspfull" ref="6644c43d1ac2abf3b7767935a5e2ab46" args="(cmat **out0, const csp *A, const dcomplex f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert sparse matrix into dense matrix and add to output: out0=out0+full(A)*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03958"></a>03958                                                             {
<a name="l03959"></a>03959     <span class="keywordflow">if</span>(!A)
<a name="l03960"></a>03960     <span class="keywordflow">return</span>;<span class="comment"></span>
<a name="l03961"></a>03961 <span class="comment">    /**</span>
<a name="l03962"></a>03962 <span class="comment">       add A*f to dense matrix located in p;</span>
<a name="l03963"></a>03963 <span class="comment">    */</span>
<a name="l03964"></a>03964     <span class="keywordtype">long</span> nx=A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>;
<a name="l03965"></a>03965     <span class="keywordtype">long</span> icol,ix,irow;
<a name="l03966"></a>03966     <span class="keywordflow">if</span>(!*out0){
<a name="l03967"></a>03967     *out0=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>);
<a name="l03968"></a>03968     }
<a name="l03969"></a>03969     X(mat) *out=*out0;
<a name="l03970"></a>03970     assert(out-&gt;nx==A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a> &amp;&amp; out-&gt;ny==A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>);
<a name="l03971"></a>03971     PMAT(out,pp);
<a name="l03972"></a>03972     <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03973"></a>03973     <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03974"></a>03974         irow=A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix];
<a name="l03975"></a>03975         <span class="keywordflow">if</span>(irow&gt;=nx)
<a name="l03976"></a>03976         error(<span class="stringliteral">"invalid row:%ld, %ld"</span>,irow,nx);
<a name="l03977"></a>03977         pp[icol][irow]+=alpha*A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix];
<a name="l03978"></a>03978     }
<a name="l03979"></a>03979     }
<a name="l03980"></a>03980 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b2e5c232a1e67f54840d0d8da97bfbfc"></a><!-- doxytag: member="csp.h::csptfull" ref="b2e5c232a1e67f54840d0d8da97bfbfc" args="(cmat **out0, const csp *A, const dcomplex f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the transpose of a sparse matrix into dense matrix and add to output: out0=out0+full(A')*alpha;. 
<p>
<div class="fragment"><pre class="fragment"><a name="l03984"></a>03984                                                              {
<a name="l03985"></a>03985     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;<span class="comment"></span>
<a name="l03986"></a>03986 <span class="comment">    /**</span>
<a name="l03987"></a>03987 <span class="comment">       add A*f to dense matrix located in p;</span>
<a name="l03988"></a>03988 <span class="comment">    */</span>
<a name="l03989"></a>03989     <span class="keywordtype">long</span> nx=A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>;
<a name="l03990"></a>03990     <span class="keywordtype">long</span> icol,ix,irow;
<a name="l03991"></a>03991     <span class="keywordflow">if</span>(!*out0){
<a name="l03992"></a>03992     *out0=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>);
<a name="l03993"></a>03993     }
<a name="l03994"></a>03994     X(mat) *out=*out0;
<a name="l03995"></a>03995     assert(out-&gt;nx==A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a> &amp;&amp; out-&gt;ny==A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>);
<a name="l03996"></a>03996     PMAT(out,pp);
<a name="l03997"></a>03997     <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l03998"></a>03998     <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l03999"></a>03999         irow=A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix];
<a name="l04000"></a>04000         <span class="keywordflow">if</span>(irow&gt;=nx)
<a name="l04001"></a>04001         error(<span class="stringliteral">"invalid row:%ld, %ld"</span>,irow,nx);
<a name="l04002"></a>04002         pp[irow][icol]+=alpha*A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix];
<a name="l04003"></a>04003     }
<a name="l04004"></a>04004     }
<a name="l04005"></a>04005 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7b859f635f4fd699e4b703f64bf57890"></a><!-- doxytag: member="csp.h::cspcellfull" ref="7b859f635f4fd699e4b703f64bf57890" args="(ccell **out0, const cspcell *A, const dcomplex f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert sparse cell to dense matrix cell: out0=out0+full(A)*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04008"></a>04008                                                                      {
<a name="l04009"></a>04009     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l04010"></a>04010     X(cell) *out=*out0;
<a name="l04011"></a>04011     <span class="keywordflow">if</span>(!out){
<a name="l04012"></a>04012     out=*out0=X(cellnew)(A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>, A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>);
<a name="l04013"></a>04013     }<span class="keywordflow">else</span>{
<a name="l04014"></a>04014     assert(out-&gt;nx==A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a> &amp;&amp; out-&gt;ny==A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>);
<a name="l04015"></a>04015     }
<a name="l04016"></a>04016     PSPCELL(A,pA);
<a name="l04017"></a>04017     PXCELL(out,pout);
<a name="l04018"></a>04018     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; iy++){
<a name="l04019"></a>04019     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>; ix++){
<a name="l04020"></a>04020         Y(spfull)(&amp;pout[iy][ix], pA[iy][ix], alpha);
<a name="l04021"></a>04021     }
<a name="l04022"></a>04022     }
<a name="l04023"></a>04023 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d0ea8b24ff5f244861b568b7687c8f44"></a><!-- doxytag: member="csp.h::csptcellfull" ref="d0ea8b24ff5f244861b568b7687c8f44" args="(ccell **out0, const cspcell *A, const dcomplex f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csptcellfull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert transpose of sparse cell to dense matrix cell: out0=out0+full(A')*alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04026"></a>04026                                                                       {
<a name="l04027"></a>04027     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l04028"></a>04028     X(cell) *out=*out0;
<a name="l04029"></a>04029     <span class="keywordflow">if</span>(!out){
<a name="l04030"></a>04030     out=*out0=X(cellnew)(A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>, A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>);
<a name="l04031"></a>04031     }<span class="keywordflow">else</span>{
<a name="l04032"></a>04032     assert(out-&gt;nx==A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a> &amp;&amp; out-&gt;ny==A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>);
<a name="l04033"></a>04033     }
<a name="l04034"></a>04034     PSPCELL(A,pA);
<a name="l04035"></a>04035     PXCELL(out, pout);
<a name="l04036"></a>04036     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; iy++){
<a name="l04037"></a>04037     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>; ix++){
<a name="l04038"></a>04038         Y(spfull)(&amp;pout[ix][iy], pA[iy][ix], alpha);
<a name="l04039"></a>04039     }
<a name="l04040"></a>04040     } 
<a name="l04041"></a>04041 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="288e4b42b14730697afd467bd73bf589"></a><!-- doxytag: member="csp.h::cspadd2" ref="288e4b42b14730697afd467bd73bf589" args="(csp *A, csp *B, dcomplex a, dcomplex b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspadd2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Added two sparse matrices: return A*a+B*b. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04044"></a>04044                                           {
<a name="l04045"></a>04045     X(sp) *C=Y(cs_add)(A,B,a,b);
<a name="l04046"></a>04046     Y(cs_dropzeros)(C);
<a name="l04047"></a>04047     <span class="keywordflow">return</span> C;
<a name="l04048"></a>04048 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2425634b2e026e5beb40d3e32dbf05a2"></a><!-- doxytag: member="csp.h::cspadd" ref="2425634b2e026e5beb40d3e32dbf05a2" args="(csp **A0, const csp *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspadd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a sparse matrix to another: A0=A0+B. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04051"></a>04051                                          {
<a name="l04052"></a>04052     <span class="comment">//add B to A.</span>
<a name="l04053"></a>04053     <span class="keywordflow">if</span>(B){
<a name="l04054"></a>04054     <span class="keywordflow">if</span>(!*A0) 
<a name="l04055"></a>04055         *A0=Y(spdup)(B);
<a name="l04056"></a>04056     <span class="keywordflow">else</span>{
<a name="l04057"></a>04057         <span class="keywordflow">if</span>((*A0)-&gt;m!=B-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a> || (*A0)-&gt;n!=B-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>) {
<a name="l04058"></a>04058         error(<span class="stringliteral">"X(sp) matrix mismatch: (%ldx%ld) vs (%ldx%ld\n"</span>,
<a name="l04059"></a>04059               (*A0)-&gt;m, (*A0)-&gt;n, B-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, B-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>);
<a name="l04060"></a>04060         }
<a name="l04061"></a>04061         X(sp) *res=Y(cs_add)(*A0,B,1.,1.);
<a name="l04062"></a>04062         Y(cs_dropzeros)(res);
<a name="l04063"></a>04063         <span class="comment">//move the data over.</span>
<a name="l04064"></a>04064         Y(spmove)(*A0,res);<span class="comment">//move the data from res to A.</span>
<a name="l04065"></a>04065     }
<a name="l04066"></a>04066     }
<a name="l04067"></a>04067 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="11639654ba4aaeea701ad44343239714"></a><!-- doxytag: member="csp.h::cspcelladd" ref="11639654ba4aaeea701ad44343239714" args="(cspcell **A0, const cspcell *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcelladd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a sparse cell to another: A0=A0+B. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04070"></a>04070                                                      {
<a name="l04071"></a>04071     <span class="keywordflow">if</span>(B){
<a name="l04072"></a>04072     <span class="keywordflow">if</span>(!*A0){
<a name="l04073"></a>04073         *A0=Y(spcellnew)(B-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>, B-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>);
<a name="l04074"></a>04074     }
<a name="l04075"></a>04075     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;B-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>*B-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; i++){
<a name="l04076"></a>04076         Y(spadd)(&amp;((*A0)-&gt;p[i]), B-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[i]);
<a name="l04077"></a>04077     }
<a name="l04078"></a>04078     }
<a name="l04079"></a>04079 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7c380d6d6ef6d0965e5a35fd4b7ce680"></a><!-- doxytag: member="csp.h::csptrans" ref="7c380d6d6ef6d0965e5a35fd4b7ce680" args="(const csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* csptrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transpose a sparse array. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04082"></a>04082                                  {
<a name="l04083"></a>04083     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l04084"></a>04084     X(sp) *res=Y(cs_transpose)(A,1);
<a name="l04085"></a>04085     Y(cs_dropzeros)(res);
<a name="l04086"></a>04086     <span class="keywordflow">return</span> res;
<a name="l04087"></a>04087 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1334089c91c23cfe696e5ebfdce273dd"></a><!-- doxytag: member="csp.h::cspmulsp" ref="1334089c91c23cfe696e5ebfdce273dd" args="(const csp *A, const csp *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspmulsp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two sparse arrays: return A*B. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04090"></a>04090                                                  {      
<a name="l04091"></a>04091     <span class="comment">//return C=(A*B)</span>
<a name="l04092"></a>04092     <span class="keywordflow">if</span>(!A || !B) <span class="keywordflow">return</span> NULL;
<a name="l04093"></a>04093     X(sp) *C=Y(cs_multiply)(A, B);
<a name="l04094"></a>04094     Y(cs_dropzeros)(C);
<a name="l04095"></a>04095     <span class="keywordflow">return</span> C;
<a name="l04096"></a>04096 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b7e0a8ab070321e84b17ac255ffd8844"></a><!-- doxytag: member="csp.h::csptmulsp" ref="b7e0a8ab070321e84b17ac255ffd8844" args="(const csp *A, const csp *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* csptmulsp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply the transpose of a sparse with another: return A'*B. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04099"></a>04099                                                   {
<a name="l04100"></a>04100     <span class="comment">//return A'*B;</span>
<a name="l04101"></a>04101     <span class="comment">//fixme : may need to improve this so that tranpose of A is not necessary.</span>
<a name="l04102"></a>04102     X(sp) *At=Y(sptrans)(A);
<a name="l04103"></a>04103     X(sp) *C=Y(spmulsp)(At, B);
<a name="l04104"></a>04104     Y(spfree)(At);
<a name="l04105"></a>04105     Y(cs_dropzeros)(C);
<a name="l04106"></a>04106     <span class="keywordflow">return</span> C;
<a name="l04107"></a>04107 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1e65a4b563b95329539de9aa99639321"></a><!-- doxytag: member="csp.h::cspmulsp2" ref="1e65a4b563b95329539de9aa99639321" args="(csp **C0, const csp *A, const csp *B, const dcomplex scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspmulsp2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> **&nbsp;</td>
          <td class="paramname"> <em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two sparse arrays and add to the third: C0=C0+A*B*scale. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04111"></a>04111                        {
<a name="l04112"></a>04112     <span class="comment">//return C=C+ alpha*(A*B)</span>
<a name="l04113"></a>04113     <span class="keywordflow">if</span>(!A || !B) <span class="keywordflow">return</span>;
<a name="l04114"></a>04114     X(sp) *res=Y(cs_multiply)(A, B);
<a name="l04115"></a>04115     <span class="keywordflow">if</span>(ABS(scale-1.)&gt;EPS){
<a name="l04116"></a>04116     Y(spscale)(res, scale);
<a name="l04117"></a>04117     }
<a name="l04118"></a>04118     <span class="keywordflow">if</span>(!*C0) 
<a name="l04119"></a>04119     *C0=res;
<a name="l04120"></a>04120     <span class="keywordflow">else</span>{
<a name="l04121"></a>04121     Y(spadd)(C0, res);
<a name="l04122"></a>04122     Y(spfree)(res);
<a name="l04123"></a>04123     }
<a name="l04124"></a>04124     Y(cs_dropzeros)(*C0);
<a name="l04125"></a>04125 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="49dcac88c7db4779a830c7fada6f3cc0"></a><!-- doxytag: member="csp.h::cspcellmulspcell" ref="49dcac88c7db4779a830c7fada6f3cc0" args="(const cspcell *A, const cspcell *B, const dcomplex scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcspcell.html">cspcell</a>* cspcellmulspcell           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply two sparse cell. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04130"></a>04130                                 {
<a name="l04131"></a>04131     <span class="comment">//return C=A*B;</span>
<a name="l04132"></a>04132     <span class="keywordflow">if</span>(!A || !B) <span class="keywordflow">return</span> NULL;
<a name="l04133"></a>04133     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>!=B-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>) error(<span class="stringliteral">"mismatch\n"</span>);
<a name="l04134"></a>04134     Y(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>) *C=Y(spcellnew)(A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>, B-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>);
<a name="l04135"></a>04135     X(sp) *(*Ap)[A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>] = (X(sp) *(*)[A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>]) A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>;
<a name="l04136"></a>04136     X(sp) *(*Bp)[B-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>] = (X(sp) *(*)[B-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>]) B-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>;
<a name="l04137"></a>04137     X(sp) *(*Cp)[C-&gt;nx] = (X(sp) *(*)[C-&gt;nx]) C-&gt;p;
<a name="l04138"></a>04138     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;B-&gt;ny; iy++){
<a name="l04139"></a>04139     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>; ix++){
<a name="l04140"></a>04140         Cp[iy][ix]=NULL;
<a name="l04141"></a>04141         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz=0; iz&lt;A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; iz++){
<a name="l04142"></a>04142         Y(spmulsp2)(&amp;Cp[iy][ix],Ap[iz][ix],Bp[iy][iz],scale);
<a name="l04143"></a>04143         }
<a name="l04144"></a>04144     }
<a name="l04145"></a>04145     }
<a name="l04146"></a>04146     <span class="keywordflow">return</span> C;
<a name="l04147"></a>04147 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0116948f7f49876ec550f83d52527708"></a><!-- doxytag: member="csp.h::cspcellnew" ref="0116948f7f49876ec550f83d52527708" args="(const long nx, const long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcspcell.html">cspcell</a>* cspcellnew           </td>
          <td>(</td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new sparse cell. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04150"></a>04150                                                      {
<a name="l04151"></a>04151     Y(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>) *spc;
<a name="l04152"></a>04152     spc=calloc(1, <span class="keyword">sizeof</span>(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>));
<a name="l04153"></a>04153     spc-&gt;nx=nx;
<a name="l04154"></a>04154     spc-&gt;ny=ny;
<a name="l04155"></a>04155     spc-&gt;p=calloc(nx*ny, <span class="keyword">sizeof</span>(X(sp) *));
<a name="l04156"></a>04156     <span class="keywordflow">return</span> spc;
<a name="l04157"></a>04157 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="505b38d31765196007662b0cc2aaa796"></a><!-- doxytag: member="csp.h::cspcelltrans" ref="505b38d31765196007662b0cc2aaa796" args="(const cspcell *spc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcspcell.html">cspcell</a>* cspcelltrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>spc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transpose a sparse cell. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04160"></a>04160                                                {
<a name="l04161"></a>04161     <span class="keywordflow">if</span>(!spc) <span class="keywordflow">return</span> NULL;
<a name="l04162"></a>04162     <span class="keywordtype">long</span> nx,ny;
<a name="l04163"></a>04163     nx=spc-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>;
<a name="l04164"></a>04164     ny=spc-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>;
<a name="l04165"></a>04165     Y(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>) *spct=Y(spcellnew)(ny,nx);
<a name="l04166"></a>04166     
<a name="l04167"></a>04167     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;ny; iy++){
<a name="l04168"></a>04168     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;nx; ix++){
<a name="l04169"></a>04169         spct-&gt;p[iy+ix*ny]=Y(sptrans)(spc-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[ix+iy*nx]);
<a name="l04170"></a>04170     }
<a name="l04171"></a>04171     }
<a name="l04172"></a>04172     <span class="keywordflow">return</span> spct;
<a name="l04173"></a>04173 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="81ac17cb4a76babb27068e2441fef625"></a><!-- doxytag: member="csp.h::cspcellfree_do" ref="81ac17cb4a76babb27068e2441fef625" args="(cspcell *spc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>spc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a sparse cell data. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04176"></a>04176                                      {
<a name="l04177"></a>04177     <span class="keywordflow">if</span>(!spc || !spc-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>) <span class="keywordflow">return</span>;
<a name="l04178"></a>04178     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;spc-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>*spc-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; ix++){
<a name="l04179"></a>04179     Y(spfree)(spc-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[ix]);
<a name="l04180"></a>04180     }
<a name="l04181"></a>04181     free(spc-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>);
<a name="l04182"></a>04182     free(spc);
<a name="l04183"></a>04183 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8789fe1e884e000a6113f62f0e9d2e63"></a><!-- doxytag: member="csp.h::cspcat" ref="8789fe1e884e000a6113f62f0e9d2e63" args="(const csp *A, const csp *B, int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspcat           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenate two sparse array along dim dimension. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04186"></a>04186                                                         {
<a name="l04187"></a>04187     X(sp) *C=NULL;
<a name="l04188"></a>04188     <span class="keywordflow">if</span>(dim==0){
<a name="l04189"></a>04189     error(<span class="stringliteral">"Not implemented\n"</span>);
<a name="l04190"></a>04190     <span class="comment">/*</span>
<a name="l04191"></a>04191 <span class="comment">      |A|</span>
<a name="l04192"></a>04192 <span class="comment">      |B|</span>
<a name="l04193"></a>04193 <span class="comment">    */</span>
<a name="l04194"></a>04194     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim==1){
<a name="l04195"></a>04195     <span class="comment">/*|AB|*/</span>
<a name="l04196"></a>04196     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a> != B-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>){
<a name="l04197"></a>04197         error(<span class="stringliteral">"X(sp) matrix doesn't match\n"</span>);
<a name="l04198"></a>04198     }
<a name="l04199"></a>04199     <span class="keyword">const</span> <span class="keywordtype">long</span> nzmax=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]+B-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[B-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>];
<a name="l04200"></a>04200     C=Y(spnew)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>+B-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, nzmax);
<a name="l04201"></a>04201     memcpy(C-&gt;p, A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l04202"></a>04202     memcpy(C-&gt;i, A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>, A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l04203"></a>04203     memcpy(C-&gt;x, A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>, A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]*<span class="keyword">sizeof</span>(T));
<a name="l04204"></a>04204     memcpy(C-&gt;i+A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>], B-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>, B-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[B-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l04205"></a>04205     memcpy(C-&gt;x+A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>], B-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>, B-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[B-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l04206"></a>04206     <span class="keyword">const</span> <span class="keywordtype">long</span> Anzmax=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>];
<a name="l04207"></a>04207     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;B-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>+1; i++){
<a name="l04208"></a>04208         C-&gt;p[i+A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]=Anzmax+B-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[i];
<a name="l04209"></a>04209     }
<a name="l04210"></a>04210     }<span class="keywordflow">else</span>{
<a name="l04211"></a>04211     error(<span class="stringliteral">"Wrong dimension\n"</span>);
<a name="l04212"></a>04212     }
<a name="l04213"></a>04213     <span class="keywordflow">return</span> C;
<a name="l04214"></a>04214 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3b682ec0e120632c083d6e9f5b40a2b3"></a><!-- doxytag: member="csp.h::cspcell2sp" ref="3b682ec0e120632c083d6e9f5b40a2b3" args="(const cspcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspcell2sp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenate a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> to sparse array. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04217"></a>04217                                        {
<a name="l04218"></a>04218     <span class="comment">//convert Y(spcell) to sparse.</span>
<a name="l04219"></a>04219     X(sp) *(*Ap)[A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>] = (X(sp) *(*)[A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>])A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>;
<a name="l04220"></a>04220     <span class="keywordtype">long</span> nx=0,ny=0,nzmax=0;
<a name="l04221"></a>04221     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;nx; ix++){
<a name="l04222"></a>04222     nx+=Ap[0][ix]-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>;
<a name="l04223"></a>04223     }
<a name="l04224"></a>04224     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; iy++){
<a name="l04225"></a>04225     ny+=Ap[iy][0]-&gt;n;
<a name="l04226"></a>04226     }
<a name="l04227"></a>04227     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; i++){
<a name="l04228"></a>04228     nzmax+=A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[i]-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[i]-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>];
<a name="l04229"></a>04229     <span class="comment">//nzmax+=A-&gt;p[i]-&gt;nzmax;</span>
<a name="l04230"></a>04230     }
<a name="l04231"></a>04231     X(sp) *out=Y(spnew)(nx,ny,nzmax);
<a name="l04232"></a>04232     <span class="keywordtype">long</span> count=0;
<a name="l04233"></a>04233     <span class="keywordtype">long</span> jcol=0;
<a name="l04234"></a>04234     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; iy++){
<a name="l04235"></a>04235     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;Ap[iy][0]-&gt;n; icol++){
<a name="l04236"></a>04236         out-&gt;p[jcol+icol]=count;
<a name="l04237"></a>04237         <span class="keywordtype">long</span> kr=0;
<a name="l04238"></a>04238         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>; ix++){
<a name="l04239"></a>04239         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ir=Ap[iy][ix]-&gt;p[icol]; 
<a name="l04240"></a>04240             ir&lt;Ap[iy][ix]-&gt;p[icol+1]; ir++){
<a name="l04241"></a>04241             out-&gt;x[count]=Ap[iy][ix]-&gt;x[ir];
<a name="l04242"></a>04242             out-&gt;i[count]=Ap[iy][ix]-&gt;i[ir]+kr;
<a name="l04243"></a>04243             count++;
<a name="l04244"></a>04244         }
<a name="l04245"></a>04245         kr+=Ap[iy][ix]-&gt;m;
<a name="l04246"></a>04246         }
<a name="l04247"></a>04247     }
<a name="l04248"></a>04248     jcol+=Ap[iy][0]-&gt;n;
<a name="l04249"></a>04249     }
<a name="l04250"></a>04250     out-&gt;p[ny]=count;
<a name="l04251"></a>04251     <span class="keywordflow">if</span>(count&gt;nzmax){
<a name="l04252"></a>04252     error(<span class="stringliteral">"Y(spcell2sp) gets Wrong results. count=%ld, nzmax=%ld\n"</span>,count,nzmax);
<a name="l04253"></a>04253     }
<a name="l04254"></a>04254     <span class="comment">//nzmax maybe smaller than A-&gt;p[A-&gt;n] </span>
<a name="l04255"></a>04255     <span class="comment">//because nzmax simply show the slots available.</span>
<a name="l04256"></a>04256     <span class="keywordflow">return</span> out;
<a name="l04257"></a>04257 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a3836f4b5764c618db758467cdd24a62"></a><!-- doxytag: member="csp.h::cspsum" ref="a3836f4b5764c618db758467cdd24a62" args="(const csp *A, int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cspsum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sum elements of sparse array along dimension dim. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04262"></a>04262                                          {
<a name="l04263"></a>04263     <span class="comment">//Sum X(sp) matrix along col or row to form a vector</span>
<a name="l04264"></a>04264     X(mat) *v=NULL;
<a name="l04265"></a>04265     T *p;
<a name="l04266"></a>04266     <span class="keywordflow">switch</span>(dim){
<a name="l04267"></a>04267     <span class="keywordflow">case</span> 1:<span class="comment">//sum along col</span>
<a name="l04268"></a>04268     v=X(<span class="keyword">new</span>)(1,A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>);
<a name="l04269"></a>04269     p=v-&gt;p;
<a name="l04270"></a>04270     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l04271"></a>04271         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l04272"></a>04272         p[icol]+=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[irow];
<a name="l04273"></a>04273         }
<a name="l04274"></a>04274     }
<a name="l04275"></a>04275     <span class="keywordflow">break</span>;
<a name="l04276"></a>04276     <span class="keywordflow">case</span> 2:<span class="comment">//sum along row</span>
<a name="l04277"></a>04277     v=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>,1);
<a name="l04278"></a>04278     p=v-&gt;p;
<a name="l04279"></a>04279     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l04280"></a>04280         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l04281"></a>04281         p[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[irow]]+=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[irow];
<a name="l04282"></a>04282         }
<a name="l04283"></a>04283     }
<a name="l04284"></a>04284     <span class="keywordflow">break</span>;
<a name="l04285"></a>04285     <span class="keywordflow">default</span>:
<a name="l04286"></a>04286     error(<span class="stringliteral">"Invalid\n"</span>);
<a name="l04287"></a>04287     }
<a name="l04288"></a>04288     <span class="keywordflow">return</span> v;
<a name="l04289"></a>04289 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="fb8a40bc13c4f0c04b1a1431e7d1a5b5"></a><!-- doxytag: member="csp.h::cspsumabs" ref="fb8a40bc13c4f0c04b1a1431e7d1a5b5" args="(const csp *A, int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cspsumabs           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sum abs of elements of sparse array along dimension dim. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04292"></a>04292                                             {
<a name="l04293"></a>04293     X(mat) *v=NULL;
<a name="l04294"></a>04294     T *p;
<a name="l04295"></a>04295     <span class="keywordflow">switch</span>(col){
<a name="l04296"></a>04296     <span class="keywordflow">case</span> 1:<span class="comment">//sum along col</span>
<a name="l04297"></a>04297     v=X(<span class="keyword">new</span>)(1,A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>);
<a name="l04298"></a>04298     p=v-&gt;p;
<a name="l04299"></a>04299     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l04300"></a>04300         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l04301"></a>04301         p[icol]+=ABS(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[irow]);
<a name="l04302"></a>04302         }
<a name="l04303"></a>04303     }
<a name="l04304"></a>04304     <span class="keywordflow">break</span>;
<a name="l04305"></a>04305     <span class="keywordflow">case</span> 2:<span class="comment">//sum along row</span>
<a name="l04306"></a>04306     v=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>,1);
<a name="l04307"></a>04307     p=v-&gt;p;
<a name="l04308"></a>04308     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l04309"></a>04309         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l04310"></a>04310         p[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[irow]]+=ABS(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[irow]);
<a name="l04311"></a>04311         }
<a name="l04312"></a>04312     }
<a name="l04313"></a>04313     <span class="keywordflow">break</span>;
<a name="l04314"></a>04314     <span class="keywordflow">default</span>:
<a name="l04315"></a>04315     error(<span class="stringliteral">"Invalid\n"</span>);
<a name="l04316"></a>04316     }
<a name="l04317"></a>04317     <span class="keywordflow">return</span> v;
<a name="l04318"></a>04318 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d212aea4c404ea3b85aa820a02f2fe78"></a><!-- doxytag: member="csp.h::cspcellmulvec" ref="d212aea4c404ea3b85aa820a02f2fe78" args="(dcomplex *restrict yc, const cspcell *Ac, const dcomplex *restrict xc, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellmulvec           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>yc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>Ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>xc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a <a class="el" href="structspcell.html" title="an 2-d array of sparse.">spcell</a> with vectors. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04327"></a>04327                                             {
<a name="l04328"></a>04328     <span class="comment">//y=y+alpha*A*creal(x); Ac X(sp) cell. xc is vector.</span>
<a name="l04329"></a>04329     <span class="keywordflow">if</span>(Ac &amp;&amp; xc){
<a name="l04330"></a>04330     <span class="keyword">const</span> T *restrict x=xc;
<a name="l04331"></a>04331     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icy=0; icy&lt;Ac-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; icy++){
<a name="l04332"></a>04332         T *restrict y=yc;
<a name="l04333"></a>04333         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icx=0; icx&lt;Ac-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>; icx++){
<a name="l04334"></a>04334         <span class="keyword">const</span> X(sp) *A=Ac-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[icx+icy*Ac-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>];
<a name="l04335"></a>04335         Y(spmulvec)(y,A,x,alpha);
<a name="l04336"></a>04336         y+=A-&gt;m;
<a name="l04337"></a>04337         }
<a name="l04338"></a>04338         x+=Ac-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[icy*Ac-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>]-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>;
<a name="l04339"></a>04339     }
<a name="l04340"></a>04340     }
<a name="l04341"></a>04341 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="de98f70161730502163dbc410cb5740a"></a><!-- doxytag: member="csp.h::cspdropeps" ref="de98f70161730502163dbc410cb5740a" args="(csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspdropeps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drop elements that are EPS times the largest value. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04345"></a>04345                            {
<a name="l04346"></a>04346     <span class="keywordtype">double</span> max;
<a name="l04347"></a>04347 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l04348"></a>04348 <span class="preprocessor"></span>    maxmincmp(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>,A-&gt;<a class="code" href="structcsp.html#1ac262485faf97bba7f808626854a480" title="maximum number of entries">nzmax</a>,&amp;max,NULL,NULL);
<a name="l04349"></a>04349 <span class="preprocessor">#else</span>
<a name="l04350"></a>04350 <span class="preprocessor"></span>    max=<a class="code" href="mathmisc_8c.html#ac7d23a6f61a359934d93f1fbdc570ea" title="compute the maximum of the abs of double vector">maxabs</a>(A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>, A-&gt;<a class="code" href="structcsp.html#1ac262485faf97bba7f808626854a480" title="maximum number of entries">nzmax</a>);
<a name="l04351"></a>04351 <span class="preprocessor">#endif</span>
<a name="l04352"></a>04352 <span class="preprocessor"></span>    Y(cs_droptol)(A, max*EPS);
<a name="l04353"></a>04353 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0fbab7792a907baf7e26798089f67fda"></a><!-- doxytag: member="csp.h::cspcelldropeps" ref="0fbab7792a907baf7e26798089f67fda" args="(cspcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcelldropeps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drop elements that are EPS times the largest value. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04357"></a>04357                                    {
<a name="l04358"></a>04358     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; i++){
<a name="l04359"></a>04359     Y(spdropeps)(A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[i]);
<a name="l04360"></a>04360     }
<a name="l04361"></a>04361 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6fc1f2acedbe1173af2194167055a1dd"></a><!-- doxytag: member="csp.h::cspsort" ref="6fc1f2acedbe1173af2194167055a1dd" args="(csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspsort           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make sure the elements are sorted correctly. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04373"></a>04373                         {
<a name="l04374"></a>04374     spelem *col=NULL;
<a name="l04375"></a>04375     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; i++){
<a name="l04376"></a>04376     <span class="keywordtype">long</span> nelem=(A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[i+1]-A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[i]);
<a name="l04377"></a>04377     <span class="keywordflow">if</span>(nelem==0) <span class="keywordflow">continue</span>;
<a name="l04378"></a>04378     col=realloc(col, nelem*<span class="keyword">sizeof</span>(spelem));
<a name="l04379"></a>04379     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;nelem; j++){
<a name="l04380"></a>04380         col[j].i=A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[i]+j];
<a name="l04381"></a>04381         col[j].x=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[i]+j];
<a name="l04382"></a>04382     }
<a name="l04383"></a>04383     qsort(col, nelem, <span class="keyword">sizeof</span>(spelem), (<span class="keywordtype">int</span>(*)(<span class="keyword">const</span> <span class="keywordtype">void</span>*,<span class="keyword">const</span> <span class="keywordtype">void</span>*))spelemcmp);
<a name="l04384"></a>04384     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;nelem; j++){
<a name="l04385"></a>04385         A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[i]+j]=col[j].i;
<a name="l04386"></a>04386         A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[i]+j]=col[j].x;
<a name="l04387"></a>04387     }
<a name="l04388"></a>04388     }
<a name="l04389"></a>04389     free(col);
<a name="l04390"></a>04390 
<a name="l04391"></a>04391 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6b8d5e45b17827f0ae65b1ced936b49d"></a><!-- doxytag: member="csp.h::cspcellsort" ref="6b8d5e45b17827f0ae65b1ced936b49d" args="(cspcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellsort           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make sure the elements are sorted correctly. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04395"></a>04395                                 {
<a name="l04396"></a>04396     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; i++){
<a name="l04397"></a>04397     Y(spsort)(A-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[i]);
<a name="l04398"></a>04398     }
<a name="l04399"></a>04399 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f1f35ec3c6167455751a8b1a74f35b99"></a><!-- doxytag: member="csp.h::cspsym" ref="f1f35ec3c6167455751a8b1a74f35b99" args="(csp *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspsym           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
symmetricize a X(sp) matrix and drop values below a threshold. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04404"></a>04404                        {
<a name="l04405"></a>04405     X(sp) *B=Y(sptrans)(A);
<a name="l04406"></a>04406     Y(spadd)(&amp;A,B);
<a name="l04407"></a>04407     Y(spscale)(A,0.5);
<a name="l04408"></a>04408     Y(spfree)(B);
<a name="l04409"></a>04409     Y(spdropeps)(A);
<a name="l04410"></a>04410     Y(spsort)(A);<span class="comment">//This is important to make chol work.</span>
<a name="l04411"></a>04411 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="63805c61c7ce831fc8255368cdcd4b71"></a><!-- doxytag: member="csp.h::cspcellsym" ref="63805c61c7ce831fc8255368cdcd4b71" args="(cspcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellsym           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
symmetricize a X(sp) cell and drop values below a threshold. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04416"></a>04416                                {
<a name="l04417"></a>04417     Y(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>) *B=Y(spcelltrans)(A);
<a name="l04418"></a>04418     Y(spcelladd)(&amp;A,B);
<a name="l04419"></a>04419     Y(spcellfree)(B);
<a name="l04420"></a>04420     Y(spcellscale)(A,0.5);
<a name="l04421"></a>04421     Y(spcelldropeps)(A);
<a name="l04422"></a>04422     Y(spcellsort)(A);
<a name="l04423"></a>04423 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="293ebbfa0acf47f8783a3493966ad4ba"></a><!-- doxytag: member="csp.h::cspconvolvop" ref="293ebbfa0acf47f8783a3493966ad4ba" args="(cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspconvolvop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a X(sp) convolution operator C with C(i,j)=A(i-j); A must be very X(sp) with only a view non-zero value otherwise C will be too full. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04430"></a>04430                                 {
<a name="l04431"></a>04431     <span class="comment">//First collect statistics on A.</span>
<a name="l04432"></a>04432     <span class="keywordtype">long</span> nini=10;
<a name="l04433"></a>04433     T *vals=calloc(nini, <span class="keyword">sizeof</span>(T));
<a name="l04434"></a>04434     <span class="keywordtype">long</span> *sepx=calloc(nini, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l04435"></a>04435     <span class="keywordtype">long</span> *sepy=calloc(nini, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l04436"></a>04436     <span class="keywordtype">long</span> count=0;
<a name="l04437"></a>04437     <span class="keyword">const</span> <span class="keywordtype">long</span> nx=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l04438"></a>04438     <span class="keyword">const</span> <span class="keywordtype">long</span> ny=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l04439"></a>04439     <span class="keyword">const</span> <span class="keywordtype">long</span> nn=nx*ny;
<a name="l04440"></a>04440     PMAT(A,PA);
<a name="l04441"></a>04441     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iy++){
<a name="l04442"></a>04442     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l04443"></a>04443         <span class="keywordflow">if</span>(ABS(PA[iy][ix])&gt;0){
<a name="l04444"></a>04444         vals[count]=PA[iy][ix];
<a name="l04445"></a>04445         sepx[count]=ix;
<a name="l04446"></a>04446         sepy[count]=iy;
<a name="l04447"></a>04447         count++;
<a name="l04448"></a>04448         }
<a name="l04449"></a>04449         <span class="keywordflow">if</span>(count&gt;=nini){
<a name="l04450"></a>04450         nini*=2;
<a name="l04451"></a>04451         vals=realloc(vals, <span class="keyword">sizeof</span>(T)*nini);
<a name="l04452"></a>04452         sepx=realloc(sepx, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*nini);
<a name="l04453"></a>04453         sepy=realloc(sepy, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*nini);
<a name="l04454"></a>04454         }
<a name="l04455"></a>04455     }
<a name="l04456"></a>04456     }
<a name="l04457"></a>04457     <span class="keywordflow">if</span>(count&gt;10){
<a name="l04458"></a>04458     warning(<span class="stringliteral">"Number of coupled points %ld is too large\n"</span>,count);
<a name="l04459"></a>04459     }
<a name="l04460"></a>04460     <span class="keywordtype">long</span> nsep=count;
<a name="l04461"></a>04461     X(sp) *out=Y(spnew)(nn,nn,nn*count);
<a name="l04462"></a>04462     <span class="keywordtype">long</span> *pp=out-&gt;p;
<a name="l04463"></a>04463     <span class="keywordtype">long</span> *pi=out-&gt;i;
<a name="l04464"></a>04464     T *px=out-&gt;x;
<a name="l04465"></a>04465     count=0;
<a name="l04466"></a>04466     <span class="keywordtype">long</span> icol=0;
<a name="l04467"></a>04467     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iiy=0; iiy&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iiy++){
<a name="l04468"></a>04468     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iix=0; iix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; iix++){
<a name="l04469"></a>04469         pp[icol]=count;
<a name="l04470"></a>04470         icol++;
<a name="l04471"></a>04471         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> irow=0; irow&lt;nsep; irow++){
<a name="l04472"></a>04472         <span class="keywordtype">long</span> jix=(iix+sepx[irow])%nx;
<a name="l04473"></a>04473         <span class="keywordtype">long</span> jiy=(iiy+sepy[irow])%ny;
<a name="l04474"></a>04474         pi[count]=jix+jiy*nx;
<a name="l04475"></a>04475         px[count]=vals[irow];
<a name="l04476"></a>04476         count++;
<a name="l04477"></a>04477         }
<a name="l04478"></a>04478     }
<a name="l04479"></a>04479     }
<a name="l04480"></a>04480     pp[nn]=count;
<a name="l04481"></a>04481     free(vals);
<a name="l04482"></a>04482     free(sepx);
<a name="l04483"></a>04483     free(sepy);
<a name="l04484"></a>04484     Y(spsort)(out);
<a name="l04485"></a>04485     <span class="keywordflow">return</span> out;
<a name="l04486"></a>04486 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f6059c535e9ed5cdff0c4974dd077c6f"></a><!-- doxytag: member="csp.h::cspperm" ref="f6059c535e9ed5cdff0c4974dd077c6f" args="(csp *A, int reverse, long *pcol, long *prow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspperm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>pcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>prow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Permute rows and columns of X(sp) matrix A;. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04522"></a>04522                                                                {
<a name="l04523"></a>04523     X(sp) *out;
<a name="l04524"></a>04524     <span class="keywordflow">if</span>(pcol){
<a name="l04525"></a>04525     out=Y(sppermcol)(A,reverse,pcol);
<a name="l04526"></a>04526     }<span class="keywordflow">else</span>{
<a name="l04527"></a>04527     out=Y(spref)(A);
<a name="l04528"></a>04528     }
<a name="l04529"></a>04529     <span class="keywordflow">if</span>(prow){
<a name="l04530"></a>04530     X(sp) *Ap=Y(sptrans)(out);
<a name="l04531"></a>04531     X(sp) *App=Y(sppermcol)(Ap,reverse,prow);
<a name="l04532"></a>04532     Y(spfree)(Ap);
<a name="l04533"></a>04533     Y(spfree)(out);
<a name="l04534"></a>04534     out=Y(sptrans)(App);
<a name="l04535"></a>04535     Y(spfree)(App);
<a name="l04536"></a>04536     }
<a name="l04537"></a>04537     <span class="keywordflow">return</span> out;
<a name="l04538"></a>04538 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ae348f4ec8480c2f9ad28bf5c7091bd9"></a><!-- doxytag: member="csp.h::cspinvbdiag" ref="ae348f4ec8480c2f9ad28bf5c7091bd9" args="(const csp *A, long bs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspinvbdiag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>bs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invert a SPD X(sp) matrix that is block diagonal with block sizes of bs. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04544"></a>04544                                              {
<a name="l04545"></a>04545     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>!=A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>){
<a name="l04546"></a>04546     error(<span class="stringliteral">"Must be a square matrix\n"</span>);
<a name="l04547"></a>04547     }
<a name="l04548"></a>04548     <span class="keywordtype">long</span> nb=A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>/bs;
<a name="l04549"></a>04549     X(sp) *B=Y(spnew)(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>, nb*bs*bs);
<a name="l04550"></a>04550     X(mat) *bk=X(<span class="keyword">new</span>)(bs,bs);
<a name="l04551"></a>04551     PMAT(bk,pbk);
<a name="l04552"></a>04552     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ib=0;ib&lt;nb; ib++){
<a name="l04553"></a>04553     <span class="keywordtype">long</span> is=ib*bs;<span class="comment">//starting col</span>
<a name="l04554"></a>04554     X(zero)(bk);
<a name="l04555"></a>04555 
<a name="l04556"></a>04556     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=is; icol&lt;is+bs; icol++){
<a name="l04557"></a>04557         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l04558"></a>04558         <span class="keywordtype">long</span> row=A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[irow];
<a name="l04559"></a>04559         <span class="keywordtype">long</span> ind=row-is;
<a name="l04560"></a>04560         <span class="keywordflow">if</span>(ind&lt;0 || ind&gt;=bs){
<a name="l04561"></a>04561             info(<span class="stringliteral">"solving block %ld\n"</span>,ib);
<a name="l04562"></a>04562             error(<span class="stringliteral">"The array is not block diagonal matrix or not calculated property\n"</span>);
<a name="l04563"></a>04563         }
<a name="l04564"></a>04564         pbk[icol-is][ind]=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[irow];
<a name="l04565"></a>04565         }
<a name="l04566"></a>04566     }
<a name="l04567"></a>04567     X(inv_inplace)(bk);
<a name="l04568"></a>04568     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=is; icol&lt;is+bs; icol++){
<a name="l04569"></a>04569         B-&gt;p[icol]=icol*bs;
<a name="l04570"></a>04570         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=0; irow&lt;bs; irow++){
<a name="l04571"></a>04571         B-&gt;i[B-&gt;p[icol]+irow]=irow+is;
<a name="l04572"></a>04572         B-&gt;x[B-&gt;p[icol]+irow]=pbk[icol-is][irow];
<a name="l04573"></a>04573         }
<a name="l04574"></a>04574     }
<a name="l04575"></a>04575     }
<a name="l04576"></a>04576     B-&gt;p[A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>]=nb*bs*bs;
<a name="l04577"></a>04577     <span class="keywordflow">return</span> B;
<a name="l04578"></a>04578 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cecaf203a653ac718dd234bf7119e580"></a><!-- doxytag: member="csp.h::cspblockextract" ref="cecaf203a653ac718dd234bf7119e580" args="(const csp *A, long bs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* cspblockextract           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>bs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extrat the diagonal blocks of size bs into cell arrays. 
<p>
<div class="fragment"><pre class="fragment"><a name="l04582"></a>04582                                                    {
<a name="l04583"></a>04583     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>!=A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>){
<a name="l04584"></a>04584     error(<span class="stringliteral">"Must be a square matrix\n"</span>);
<a name="l04585"></a>04585     }
<a name="l04586"></a>04586     <span class="keywordtype">long</span> nb=A-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>/bs;
<a name="l04587"></a>04587     X(cell) *out=X(cellnew)(nb,1);
<a name="l04588"></a>04588     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ib=0;ib&lt;nb; ib++){
<a name="l04589"></a>04589     <span class="keywordtype">long</span> is=ib*bs;<span class="comment">//starting col</span>
<a name="l04590"></a>04590     out-&gt;p[ib]=X(<span class="keyword">new</span>)(bs,bs);
<a name="l04591"></a>04591     PMAT(out-&gt;p[ib],pbk);
<a name="l04592"></a>04592     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=is; icol&lt;is+bs; icol++){
<a name="l04593"></a>04593         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> irow=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; irow&lt;A-&gt;p[icol+1]; irow++){
<a name="l04594"></a>04594         <span class="keywordtype">long</span> row=A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[irow];
<a name="l04595"></a>04595         <span class="keywordtype">long</span> ind=row-is;
<a name="l04596"></a>04596         <span class="keywordflow">if</span>(ind&lt;0 || ind&gt;=bs){
<a name="l04597"></a>04597             info(<span class="stringliteral">"solving block %ld\n"</span>,ib);
<a name="l04598"></a>04598             error(<span class="stringliteral">"The array is not block diagonal matrix or not calculated property\n"</span>);
<a name="l04599"></a>04599         }
<a name="l04600"></a>04600         pbk[icol-is][ind]=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[irow];
<a name="l04601"></a>04601         }
<a name="l04602"></a>04602     }
<a name="l04603"></a>04603     }
<a name="l04604"></a>04604     <span class="keywordflow">return</span> out;
<a name="l04605"></a>04605 }
</pre></div>
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Oct 27 12:43:13 2010 for maos-0.6.1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
