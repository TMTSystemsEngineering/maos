<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>maos-0.6.4: lib/dmat.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lib/dmat.h File Reference</h1>Contains the mathematically functions regarding to <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> and <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a> object.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#b14d47edec330a505cf684a2b0c4ff9c">dnew_ref</a> (double *p, long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creat a X(mat) object to reference an already existing vector.  <a href="#b14d47edec330a505cf684a2b0c4ff9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#21a7a376c0208121a33994cc82e7e662">dnew_data</a> (double *p, long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creat a X(mat) object with already allocated memory chunk.  <a href="#21a7a376c0208121a33994cc82e7e662"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#0d7497e2dbb79adb228de6bdde4a201e">dnew</a> (long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new T matrix object.  <a href="#0d7497e2dbb79adb228de6bdde4a201e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#d1c7365b3e3f0da49ddbf496bd46514b">dfree_keepdata</a> (<a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the X(mat), but keep the data.  <a href="#d1c7365b3e3f0da49ddbf496bd46514b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#5714a51acdc824562d451b9fde5d5da2">dfree_do</a> (<a class="el" href="structdmat.html">dmat</a> *A, int keepdata)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(mat) object.  <a href="#5714a51acdc824562d451b9fde5d5da2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#301b5a86cec0090378b142a09fb2066a">dresize</a> (<a class="el" href="structdmat.html">dmat</a> *A, long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize a matrix by adding or removing columns or rows.  <a href="#301b5a86cec0090378b142a09fb2066a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#a9c20ae37907780af63d91312d4fea38">dref</a> (<a class="el" href="structdmat.html">dmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creat a X(mat) reference an existing X(mat).  <a href="#a9c20ae37907780af63d91312d4fea38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#9033c130427b2e4cc3eabd68c9630948">dref_reshape</a> (<a class="el" href="structdmat.html">dmat</a> *in, int nx, int ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create an new X(mat) reference another with different shape.  <a href="#9033c130427b2e4cc3eabd68c9630948"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#d0c062d9a51fd5cff9924c066ca0b0bc">drefcols</a> (<a class="el" href="structdmat.html">dmat</a> *in, long icol, long ncol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creat a new X(mat) referencing columns in existing X(mat).  <a href="#d0c062d9a51fd5cff9924c066ca0b0bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#0e149114c808ff424f7fe215ee44d307">dsub</a> (const <a class="el" href="structdmat.html">dmat</a> *in, long sx, long nx, long sy, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new sub matrix of nx*ny starting from(sx,sy).  <a href="#0e149114c808ff424f7fe215ee44d307"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#131e99be189eda7c5b32aba76bcbe8d8">dcat</a> (const <a class="el" href="structdmat.html">dmat</a> *in1, const <a class="el" href="structdmat.html">dmat</a> *in2, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">concatenate two matrixes into 1 along dimension "dim"  <a href="#131e99be189eda7c5b32aba76bcbe8d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#ca6f393efef34132906a9e302e96b978">darrfree</a> (<a class="el" href="structdmat.html">dmat</a> **As, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(mat) array.  <a href="#ca6f393efef34132906a9e302e96b978"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#7ecadca31195b8b40135b7dbeb808906">ddup</a> (const <a class="el" href="structdmat.html">dmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">duplicate a X(mat) array  <a href="#7ecadca31195b8b40135b7dbeb808906"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#b5adc5cd1e79d9a79751ba482728f230">dcp</a> (<a class="el" href="structdmat.html">dmat</a> **out0, const <a class="el" href="structdmat.html">dmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy the values from one X(mat) to another.  <a href="#b5adc5cd1e79d9a79751ba482728f230"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#2ce308cca861c7b07e46fcbe1bedc919">dtrans</a> (const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">transpose a X(mat) object  <a href="#2ce308cca861c7b07e46fcbe1bedc919"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#705d6399ce6e7f7064d12f4eb131d47d">dset</a> (<a class="el" href="structdmat.html">dmat</a> *A, const double val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set values of each element in a X(mat) to val.  <a href="#705d6399ce6e7f7064d12f4eb131d47d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#e98618064b54869b4180d0c7fd895645">dzero</a> (<a class="el" href="structdmat.html">dmat</a> *out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialize all numbers in a X(mat) object to 0  <a href="#e98618064b54869b4180d0c7fd895645"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#abb4fecd296ac9ec19263e0f9d853be7">dmax</a> (const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find the maximum value of a X(mat) object  <a href="#abb4fecd296ac9ec19263e0f9d853be7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#00004b652c3485c94f4f64cfdafe5577">dmin</a> (const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find the minimum value of a X(mat) object  <a href="#00004b652c3485c94f4f64cfdafe5577"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#060e5d00143124ecbad59364c16da459">dnorm2</a> (const <a class="el" href="structdmat.html">dmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the norm2 of A  <a href="#060e5d00143124ecbad59364c16da459"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#95eddaf29cb4e4f2b6d18f74a489bd50">drandu</a> (<a class="el" href="structdmat.html">dmat</a> *A, const double mean, <a class="el" href="structmt__state.html">mt_state</a> *rstat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill A with random uniform numbers between [0, 1]*max.  <a href="#95eddaf29cb4e4f2b6d18f74a489bd50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#9cd5fc527b28964eac1f1c0bc8a03601">drandn</a> (<a class="el" href="structdmat.html">dmat</a> *A, const double sigma, <a class="el" href="structmt__state.html">mt_state</a> *rstat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill A with random normal distribution numbers with standard deviation of sigma.  <a href="#9cd5fc527b28964eac1f1c0bc8a03601"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#657f20445f371c8deaff82a5a052c02f">dshow</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">display a X(mat) matrix.  <a href="#657f20445f371c8deaff82a5a052c02f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#9a9da6ac02ccf42247a8a78a131ca73a">dscale</a> (<a class="el" href="structdmat.html">dmat</a> *A, double w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">scale each element of A by w  <a href="#9a9da6ac02ccf42247a8a78a131ca73a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#176e534c9042ace51d05a620a2294248">dsum</a> (const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create sum of all the elements in A.  <a href="#176e534c9042ace51d05a620a2294248"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#4c4f53dc9572106deb6933eb103bf40b">dadd</a> (<a class="el" href="structdmat.html">dmat</a> **B0, double bc, const <a class="el" href="structdmat.html">dmat</a> *A, const double ac)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute B=bc*B+ac*A behavior changed on 2009-11-02.  <a href="#4c4f53dc9572106deb6933eb103bf40b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#d5e98c2e933c9ca456e3dc1a47b6bea2">dinn</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the inner product of A and B.  <a href="#d5e98c2e933c9ca456e3dc1a47b6bea2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#85aee0e43bf0c24f996b45f3e1d721a6">dwdot</a> (const double *a, const <a class="el" href="structdmat.html">dmat</a> *w, const double *b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute weighted dot product a'*(w*b)  <a href="#85aee0e43bf0c24f996b45f3e1d721a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#ac8016fed8bbcc2a49d5a9ba3b835755">dwdot2</a> (const double *a, const <a class="el" href="structdmat.html">dmat</a> *w, const double *b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">special version of dwdot for just 2 element vectors.  <a href="#ac8016fed8bbcc2a49d5a9ba3b835755"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#2ad0b887d8ae79cd753310e095e2bd07">dwdot3</a> (const double *a, const <a class="el" href="structdmat.html">dmat</a> *w, const double *b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">special version of dwdot for just 3 element vectors.  <a href="#2ad0b887d8ae79cd753310e095e2bd07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#fda5697c36cb1de9790b812d919697c8">dcwm</a> (<a class="el" href="structdmat.html">dmat</a> *B, const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute component wise multiply B=B.  <a href="#fda5697c36cb1de9790b812d919697c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#108a4a2f57a5f271427d7af94a71abd8">dmulvec</a> (double *restrict y, const <a class="el" href="structdmat.html">dmat</a> *restrict A, const double *restrict x, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">multiply a X(mat) matrix with a vector and accumulate to y: y+=A*x*alpha  <a href="#108a4a2f57a5f271427d7af94a71abd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#a9ddb63c56fcc2219955260936ee9e40">dmm</a> (<a class="el" href="structdmat.html">dmat</a> **C0, const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *B, const char trans[2], const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute matrix product using blas dgemm with beta=1; C=beta*C+ alpha *trans(A)*trans(B); if C exist.  <a href="#a9ddb63c56fcc2219955260936ee9e40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#b48bc9b9c8f923e19dafc70b8fff5de2">dinvspd_inplace</a> (<a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace invert a small square SPD matrix using lapack dposv_, usually (A'*w*A).  <a href="#b48bc9b9c8f923e19dafc70b8fff5de2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#30ba84a58a9c9dd2e0a0afb5e389ffad">dinvspd</a> (const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">out of place version of dinvspd_inplace  <a href="#30ba84a58a9c9dd2e0a0afb5e389ffad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#661f5d1ec1bbcf8237c0f99b2b659314">dinv_inplace</a> (<a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace invert a general square matrix using lapack dgesv_  <a href="#661f5d1ec1bbcf8237c0f99b2b659314"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#7a04b161bee57112f209fa41a89c0295">dinv</a> (const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">out of place version of dinv  <a href="#7a04b161bee57112f209fa41a89c0295"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#da3db752eaaa609a7ec31fc98804d996">dmcc</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *wt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute (A'*W*A); where diag(W)=wt  <a href="#da3db752eaaa609a7ec31fc98804d996"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#15b43fafd86e62f49de974bb3da6f51c">dimcc</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *wt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute inv(dmcc(A, wt))  <a href="#15b43fafd86e62f49de974bb3da6f51c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#81d6ed373bf09f884a5114c8b0f543ac">dtmcc</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *wt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute (A*W*A'); where diag(W)=wt  <a href="#81d6ed373bf09f884a5114c8b0f543ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#cac32a8e663201109abf36bd322e9a46">dpinv</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *wt, const <a class="el" href="structdsp.html">dsp</a> *Wsp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the pseudo inverse of matrix A with weigthing of full matrix W or sparse matrix weighting Wsp.  <a href="#cac32a8e663201109abf36bd322e9a46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#a91e97f6979658a32b79a70b748b4810">ddiff</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the relative difference betwee two vectors.  <a href="#a91e97f6979658a32b79a70b748b4810"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#4529479ba036e3aae3b1827f161a7f9b">dcircle</a> (<a class="el" href="structdmat.html">dmat</a> *A, double cx, double cy, double r, double val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a new gray pixel map generation based on bilinear influence functions used in mkw.  <a href="#4529479ba036e3aae3b1827f161a7f9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#bb7ee19f9a9bd8c7d4f3fc680a202601">dcircle_symbolic</a> (<a class="el" href="structdmat.html">dmat</a> *A, double cx, double cy, double r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">similar to X(circle).  <a href="#bb7ee19f9a9bd8c7d4f3fc680a202601"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#9d9ed91255390f1e4649fc623dfa17ce">dfftshift</a> (<a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">shift frequency components by n/2  <a href="#9d9ed91255390f1e4649fc623dfa17ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#9f252bb4fd703109c58f8c330d6f11df">dcpcorner2center</a> (<a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reorder B and embed/crop into center of A  <a href="#9f252bb4fd703109c58f8c330d6f11df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#05330b7f5be190a6567ee775e73464c9">dshift</a> (<a class="el" href="structdmat.html">dmat</a> **B0, const <a class="el" href="structdmat.html">dmat</a> *A, int sx, int sy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cyclic shift A by nx and ny to B.  <a href="#05330b7f5be190a6567ee775e73464c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#58ed65327dde1b0410fa992eda632d3b">drotvec</a> (<a class="el" href="structdmat.html">dmat</a> *A, const double theta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">rotate the vectors CCW.  <a href="#58ed65327dde1b0410fa992eda632d3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#b4e3ddd0d5e6249c6d90c26991d8028c">drotvecnn</a> (<a class="el" href="structdmat.html">dmat</a> **B0, const <a class="el" href="structdmat.html">dmat</a> *A, double theta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">rotate a 2x2 covariance matrix A by theta CCW (coordinate rotate -theta CCW) or from ra to xy coordinate.  <a href="#b4e3ddd0d5e6249c6d90c26991d8028c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#e6580138c809e940eb9105b2b3791292">dmulvec3</a> (double *y, const <a class="el" href="structdmat.html">dmat</a> *A, const double *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">T matrix vector multiply optimized for just three values.  <a href="#e6580138c809e940eb9105b2b3791292"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#6531cfb8534d620420fbdf1deffb227c">dcog</a> (double *grad, const <a class="el" href="structdmat.html">dmat</a> *i0, double offsetx, double offsety, double thres, double bkgrnd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute thresholded center of gravity.  <a href="#6531cfb8534d620420fbdf1deffb227c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#96ba5af3d8d18bfdf35cbbb3a49abd0c">dshift2center</a> (<a class="el" href="structdmat.html">dmat</a> *A, double offsetx, double offsety)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift the image in A to center on physical center+[offsetx,offsety] using cog and fft.  <a href="#96ba5af3d8d18bfdf35cbbb3a49abd0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#30e08db08cab036374dc0635df4665d6">dclip</a> (<a class="el" href="structdmat.html">dmat</a> *A, double min, double max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limit numbers in A to within [min, max].  <a href="#30e08db08cab036374dc0635df4665d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#0131ec62b0a77d0df03e71b35f2d7b85">dgramschmidt</a> (<a class="el" href="structdmat.html">dmat</a> *Mod, double *amp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">OrthNormalize column vector in Mod, with weighting from vector amp.  <a href="#0131ec62b0a77d0df03e71b35f2d7b85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#dd22a26474e6e6af8df941a6b25b0f05">dmuldiag</a> (<a class="el" href="structdmat.html">dmat</a> *A, <a class="el" href="structdmat.html">dmat</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A=A*B, where diag(B)=s.  <a href="#dd22a26474e6e6af8df941a6b25b0f05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#b6f63a9e507f7a58e4f1ba98d7bb3288">dcwpow</a> (<a class="el" href="structdmat.html">dmat</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raise all elements to power power.  <a href="#b6f63a9e507f7a58e4f1ba98d7bb3288"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#f6edae64ae92dc140f4a85679d6252ae">dsvd</a> (<a class="el" href="structdmat.html">dmat</a> **Sdiag, <a class="el" href="structdmat.html">dmat</a> **U, <a class="el" href="structdmat.html">dmat</a> **VT, const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SVD of a general matrix.  <a href="#f6edae64ae92dc140f4a85679d6252ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#0063f9a3cde12e2b0977ed7a485fbb2c">dsvd_pow</a> (<a class="el" href="structdmat.html">dmat</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes pow(A,power) using svd  <a href="#0063f9a3cde12e2b0977ed7a485fbb2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#42490ea31b5b30b0b618f417c76bd712">daddI</a> (<a class="el" href="structdmat.html">dmat</a> *A, double val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add val to diagonal values of A.  <a href="#42490ea31b5b30b0b618f417c76bd712"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#a23e8df5aa3152c6f01025e956958e9a">dtikcr</a> (<a class="el" href="structdmat.html">dmat</a> *A, double thres)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply tikhonov regularization to A.  <a href="#a23e8df5aa3152c6f01025e956958e9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#13ed19366b0b57c73f7a0f37bd20dfb4">dmulsp</a> (<a class="el" href="structdmat.html">dmat</a> **yout, const <a class="el" href="structdmat.html">dmat</a> *x, const <a class="el" href="structdsp.html">dsp</a> *A, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">y=y+alpha*OP(x)*OP(A); implemented by transposing x,y index in sptmulmat implementation TESTED OK.  <a href="#13ed19366b0b57c73f7a0f37bd20dfb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#3d3dc034d88f0a526fe242b1c1d3b1e5">dlogspace</a> (double emin, double emax, long n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create log spaced vector.  <a href="#3d3dc034d88f0a526fe242b1c1d3b1e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#f066671d15c55648b99456c410529e33">dlinspace</a> (double emin, double emax, long n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create linearly spaced vector.  <a href="#f066671d15c55648b99456c410529e33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#139bad85f7f26668a547d3bb581a199c">dinterp1</a> (<a class="el" href="structdmat.html">dmat</a> *xin, <a class="el" href="structdmat.html">dmat</a> *yin, <a class="el" href="structdmat.html">dmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolate using linear interp.  <a href="#139bad85f7f26668a547d3bb581a199c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#50a81407616c0a439e8d95fdc66c28e1">dinterp1log</a> (<a class="el" href="structdmat.html">dmat</a> *xin, <a class="el" href="structdmat.html">dmat</a> *yin, <a class="el" href="structdmat.html">dmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolate using log(xin) and log(xnew) xin is the coordinate of yin.  <a href="#50a81407616c0a439e8d95fdc66c28e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#041003260afdf29166953042ddb51e53">dhistfill</a> (<a class="el" href="structdmat.html">dmat</a> **out, const <a class="el" href="structdmat.html">dmat</a> *A, double center, double spacing, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For each entry in A, call repeatly to collect its histogram, centered at center, spaced by spacing, for n bins in total.  <a href="#041003260afdf29166953042ddb51e53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#c94bb7e7491459eba07f93115ee7d8a1">dspline_prep</a> (<a class="el" href="structdmat.html">dmat</a> *x, <a class="el" href="structdmat.html">dmat</a> *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">1D Cubic spline interpolation preparation.  <a href="#c94bb7e7491459eba07f93115ee7d8a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#d6c71f329b21ee28435a06fd64e828c8">dspline_eval</a> (<a class="el" href="structdmat.html">dmat</a> *coeff, <a class="el" href="structdmat.html">dmat</a> *x, <a class="el" href="structdmat.html">dmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evluate the cubic spline represented by nx5 matrix coeff, at location array xnew.  <a href="#d6c71f329b21ee28435a06fd64e828c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#66dcecfdc833ad4174eec33dafc3b8eb">dspline</a> (<a class="el" href="structdmat.html">dmat</a> *x, <a class="el" href="structdmat.html">dmat</a> *y, <a class="el" href="structdmat.html">dmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do 1D cubic spline all at once by calling X(spline_prep) and X(spline_evald).  <a href="#66dcecfdc833ad4174eec33dafc3b8eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#801f95bc127f94b526980791d71e2bb1">dbspline_prep</a> (<a class="el" href="structdmat.html">dmat</a> *x, <a class="el" href="structdmat.html">dmat</a> *y, <a class="el" href="structdmat.html">dmat</a> *z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2D cubic spline interpolation preparation.  <a href="#801f95bc127f94b526980791d71e2bb1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#88fcc3be27ce68860cc93c2540c363b2">dbspline_eval</a> (<a class="el" href="structdcell.html">dcell</a> *coeff, <a class="el" href="structdmat.html">dmat</a> *x, <a class="el" href="structdmat.html">dmat</a> *y, <a class="el" href="structdmat.html">dmat</a> *xnew, <a class="el" href="structdmat.html">dmat</a> *ynew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate 2D cubic spline at location defined 2-d arrays by xnew, ynew.  <a href="#88fcc3be27ce68860cc93c2540c363b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#abf4cf559f55b2e888fed7dd336f6e07">dcellnew</a> (const long nx, const long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a new block matrix.  <a href="#abf4cf559f55b2e888fed7dd336f6e07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#92bc9490727ab673ba458e0b78b81b05">dcellnew2</a> (const <a class="el" href="structdcell.html">dcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create an new X(cell) similar to A in shape  <a href="#92bc9490727ab673ba458e0b78b81b05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#e385d21eb33f992fd5ff4d3166d929ba">dcellzero</a> (<a class="el" href="structdcell.html">dcell</a> *dc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">setting all elements of a X(cell) to zero.  <a href="#e385d21eb33f992fd5ff4d3166d929ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#a23f0606a6c60596734b1128855dba6d">dcellset</a> (<a class="el" href="structdcell.html">dcell</a> *dc, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">setting all elements of a X(cell) to alpha.  <a href="#a23f0606a6c60596734b1128855dba6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#f306524d189291b53dc6dd8547c4ddf2">dcellfree_do</a> (<a class="el" href="structdcell.html">dcell</a> *dc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a X(cell) object.  <a href="#f306524d189291b53dc6dd8547c4ddf2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#faf442e020aff84b8b1fe1766ab89227">dcelltrans</a> (const <a class="el" href="structdcell.html">dcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">transpose a X(cell) object  <a href="#faf442e020aff84b8b1fe1766ab89227"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#31480c8af50a8adc9182fae5285aaa6e">dcellref</a> (const <a class="el" href="structdcell.html">dcell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creat a X(cell) reference an existing X(cell) by referencing the elements.  <a href="#31480c8af50a8adc9182fae5285aaa6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#dde326a0041feef662127b62b4c37f23">dcelldup</a> (const <a class="el" href="structdcell.html">dcell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">duplicate a X(cell) object.  <a href="#dde326a0041feef662127b62b4c37f23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#104912d02e021b396d29d78bd2249b95">dcellcp</a> (<a class="el" href="structdcell.html">dcell</a> **out0, const <a class="el" href="structdcell.html">dcell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy the values from one X(cell) to another.  <a href="#104912d02e021b396d29d78bd2249b95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#99511eff251a7861181946af30572ef9">dcellnorm2</a> (const <a class="el" href="structdcell.html">dcell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute norm2.  <a href="#99511eff251a7861181946af30572ef9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#ae5e354726e58598c4f9a0ab039f0b67">dcellscale</a> (<a class="el" href="structdcell.html">dcell</a> *A, double w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">scale each element of A.  <a href="#ae5e354726e58598c4f9a0ab039f0b67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#805f88ca094efb27fad5861042f5d4a4">dcellreduce</a> (const <a class="el" href="structdcell.html">dcell</a> *A, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reduce nx*ny cell matrix to 1*ny if dim=1 and nx*11 if dim=2  <a href="#805f88ca094efb27fad5861042f5d4a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#cf4358f31eff9028f0204dfceee00eb9">dcellcat</a> (const <a class="el" href="structdcell.html">dcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">concatenate two cell matrices along dimenstion 'dim'  <a href="#cf4358f31eff9028f0204dfceee00eb9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#fb150ef1f6f90d87d2060922e3a2a9b2">dcellcat_each</a> (const <a class="el" href="structdcell.html">dcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">concatenate coresponding elements of each X(cell).  <a href="#fb150ef1f6f90d87d2060922e3a2a9b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#1e5613fa12d1d0d0b41ff909ac84a33e">dcelldropempty</a> (<a class="el" href="structdcell.html">dcell</a> **A0, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">drop empty rows or columns.  <a href="#1e5613fa12d1d0d0b41ff909ac84a33e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#1c506292c4c46d72e8fd573540839ae7">dcelladd</a> (<a class="el" href="structdcell.html">dcell</a> **B0, double bc, const <a class="el" href="structdcell.html">dcell</a> *A, const double ac)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add one to another.  <a href="#1c506292c4c46d72e8fd573540839ae7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#74eda13294cbbec5c4e93e70d7297301">dcellinn</a> (const <a class="el" href="structdcell.html">dcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the inner produce of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>.  <a href="#74eda13294cbbec5c4e93e70d7297301"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#57b0daa3ccb27a83e4b2235da8eec035">dcellcwm</a> (<a class="el" href="structdcell.html">dcell</a> *B, const <a class="el" href="structdcell.html">dcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Component wise multiply of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a> B=A.  <a href="#57b0daa3ccb27a83e4b2235da8eec035"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#2011d79d74ff15b07162da6f0a28fd97">dcellmm</a> (<a class="el" href="structdcell.html">dcell</a> **C0, const <a class="el" href="structdcell.html">dcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B, const char trans[2], const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute A*B and add to C0.  <a href="#2011d79d74ff15b07162da6f0a28fd97"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#59e3e5c87a7038f6408858c159a166a4">dcellinvspd</a> (<a class="el" href="structdcell.html">dcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Invert a SPD matrix.  <a href="#59e3e5c87a7038f6408858c159a166a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#bdecf8635a39266960e7121b54be57d2">dcellinv</a> (<a class="el" href="structdcell.html">dcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Invert a matrix.  <a href="#bdecf8635a39266960e7121b54be57d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#cc0cce55471ddf4b189b5722f5f93790">dcellinvspd_each</a> (<a class="el" href="structdcell.html">dcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">invert each component of the <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>.  <a href="#cc0cce55471ddf4b189b5722f5f93790"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#02a07132b0fbb4f8fe6afeb3cd55176e">dcell2m</a> (const <a class="el" href="structdcell.html">dcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a block matrix to a matrix.  <a href="#02a07132b0fbb4f8fe6afeb3cd55176e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#5f5443ca322b4ed2cb65a24e638f928e">d2cellref</a> (const <a class="el" href="structdmat.html">dmat</a> *A, int *dims, int ndim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convert a vector to cell using dimensions specified in dims.  <a href="#5f5443ca322b4ed2cb65a24e638f928e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#bed4b3e507a4bb20689c0fce64de6c0a">d2cell</a> (<a class="el" href="structdcell.html">dcell</a> **B, const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdcell.html">dcell</a> *ref)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">make A a cell array using shape information from ref if *B is NULL  <a href="#bed4b3e507a4bb20689c0fce64de6c0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#4e9d5e166621f79342478304769a43fc">dcelldropzero</a> (<a class="el" href="structdcell.html">dcell</a> *B, double thres)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">drop empty blocks (zero).  <a href="#4e9d5e166621f79342478304769a43fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#ce747978615516a6c46a9dc7b823cdde">dcelldiff</a> (const <a class="el" href="structdcell.html">dcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute ||A-B||/||A|| use mean.  <a href="#ce747978615516a6c46a9dc7b823cdde"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#ba0fbb0b2f60c70c1aeff1921ad82b24">dcellclip</a> (<a class="el" href="structdcell.html">dcell</a> *Ac, double min, double max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">clip a X(cell) array to max at 'max', min at 'min'  <a href="#ba0fbb0b2f60c70c1aeff1921ad82b24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#8f5e44c289528e1cfecabe114bf98253">dcelltikcr</a> (<a class="el" href="structdcell.html">dcell</a> *A, double thres)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply tickholov regularization of relative thres to cell array by converting it to mat.  <a href="#8f5e44c289528e1cfecabe114bf98253"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e84c45e9ca11a75081b360a85051a089"></a><!-- doxytag: member="dmat.h::dcellpinv" ref="e84c45e9ca11a75081b360a85051a089" args="(const dcell *A, const dcell *wt, const spcell *Wsp)" -->
<a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>dcellpinv</b> (const <a class="el" href="structdcell.html">dcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *wt, const <a class="el" href="structspcell.html">spcell</a> *Wsp)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b0d2599366fb08286561b5000c2edcde"></a><!-- doxytag: member="dmat.h::dcellmulsp" ref="b0d2599366fb08286561b5000c2edcde" args="(dcell **C0, const dcell *A, const spcell *B, double alpha)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>dcellmulsp</b> (<a class="el" href="structdcell.html">dcell</a> **C0, const <a class="el" href="structdcell.html">dcell</a> *A, const <a class="el" href="structspcell.html">spcell</a> *B, double alpha)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#ed4f051cb2e11032d42d5e91e08f0f99">dcelladdI</a> (<a class="el" href="structdcell.html">dcell</a> *A, double a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add a to diagonal elements of A;  <a href="#ed4f051cb2e11032d42d5e91e08f0f99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#68953d78fbcaa6533fdd78b6b6513243">dcellsvd_pow</a> (<a class="el" href="structdcell.html">dcell</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the power of a block matrix using svd method.  <a href="#68953d78fbcaa6533fdd78b6b6513243"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#279fb443e6febe18586edcb53359cf5b">dcellcwpow</a> (<a class="el" href="structdcell.html">dcell</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">raise each cell in the cell array to power of power.  <a href="#279fb443e6febe18586edcb53359cf5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#3452afc53eefe2391f8720999be80c19">dwritedata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp, const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains routines to write/read dense/sparse matrix into/from file.  <a href="#3452afc53eefe2391f8720999be80c19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#9a8e4a59501eeb3bdd87e490ff04d0e7">dcellwritedata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp, const <a class="el" href="structdcell.html">dcell</a> *dc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to write cell array of dense matrix data.  <a href="#9a8e4a59501eeb3bdd87e490ff04d0e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#f9c045fc5554493f577bb51a30bd620c">dreaddata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to read dense matrix into memory from file pointer.  <a href="#f9c045fc5554493f577bb51a30bd620c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#f7d37cf8830abee2f6a43a6455e81f86">dcellreaddata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to read dense matrix cell array into memory from file pointer.  <a href="#f7d37cf8830abee2f6a43a6455e81f86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#21964c0cee9cb479b21ad2227a9a60dc">spwritedata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp, const <a class="el" href="structdsp.html">dsp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to write sparse matrix data into file pointed using a file pointer.  <a href="#21964c0cee9cb479b21ad2227a9a60dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#9d9de86adc0703c3b1eeddc552e9b309">spreaddata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to read sparse matrix data from file pointer into memory.  <a href="#9d9de86adc0703c3b1eeddc552e9b309"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#37ebad9e8c582e694664b562a78114d2">dwrite</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write dense matrix into a file.  <a href="#37ebad9e8c582e694664b562a78114d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#70cd951a3932002ccc9270944d2005ec">dcellwrite</a> (const <a class="el" href="structdcell.html">dcell</a> *dc, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write cell array of dense matrix into a file.  <a href="#70cd951a3932002ccc9270944d2005ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#6406403e91ec976bb0d6c2e12b5d5a0f">dread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read dense matrix into memory from file.  <a href="#6406403e91ec976bb0d6c2e12b5d5a0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#dfec4b5637fce6a1cdb10b84d744c8fe">dcellread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read cell array of dense matrix into memory from file.  <a href="#dfec4b5637fce6a1cdb10b84d744c8fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#779cefb17e24b648212cc59f9324f5ae">spwrite</a> (const <a class="el" href="structdsp.html">dsp</a> *sp, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write sparse matrix into file.  <a href="#779cefb17e24b648212cc59f9324f5ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#fa58b8e2aea2a94ae0422ede37957a0f">spcellwrite</a> (const <a class="el" href="structspcell.html">spcell</a> *spc, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write cell array of sparse matrix into file.  <a href="#fa58b8e2aea2a94ae0422ede37957a0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#06bbd169953a4a808c647bd0a9e6f0d3">spread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read sparse metrix from file.  <a href="#06bbd169953a4a808c647bd0a9e6f0d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#dda41e6426ecac836fa3dd576f0d2bd9">spcellread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read cell array of sparse matrix from file.  <a href="#dda41e6426ecac836fa3dd576f0d2bd9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#316507e4c46251f724a2c22f1db76353">dnew_mmap</a> (long nx, long ny, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(mat) matrix object, mmapped from file.  <a href="#316507e4c46251f724a2c22f1db76353"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#a3b557cdaaf833c08dba873203894db5">dcellnew_mmap</a> (long nx, long ny, long *nnx, long *nny, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(cell) matrix cell object, mmapped from file.  <a href="#a3b557cdaaf833c08dba873203894db5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#e90d6b50dabcacd842a59ebc2e1326a7">dcellnewsame_mmap</a> (long nx, long ny, long mx, long my, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(cell) matrix cell object, with identical blocks, mmapped from file.  <a href="#e90d6b50dabcacd842a59ebc2e1326a7"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Contains the mathematically functions regarding to <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> and <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a> object. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="b14d47edec330a505cf684a2b0c4ff9c"></a><!-- doxytag: member="dmat.h::dnew_ref" ref="b14d47edec330a505cf684a2b0c4ff9c" args="(double *p, long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dnew_ref           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creat a X(mat) object to reference an already existing vector. 
<p>
free the X(mat) object won't free the existing vector. <div class="fragment"><pre class="fragment"><a name="l00122"></a>00122                                           {
<a name="l00123"></a>00123     <span class="keywordflow">return</span> X(new_do)(p,nx,ny,1);
<a name="l00124"></a>00124 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="21a7a376c0208121a33994cc82e7e662"></a><!-- doxytag: member="dmat.h::dnew_data" ref="21a7a376c0208121a33994cc82e7e662" args="(double *p, long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dnew_data           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creat a X(mat) object with already allocated memory chunk. 
<p>
the memory is freed when the memory is freed. <div class="fragment"><pre class="fragment"><a name="l00130"></a>00130                                            {
<a name="l00131"></a>00131     <span class="keywordflow">return</span> X(new_do)(p,nx,ny,0);
<a name="l00132"></a>00132 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0d7497e2dbb79adb228de6bdde4a201e"></a><!-- doxytag: member="dmat.h::dnew" ref="0d7497e2dbb79adb228de6bdde4a201e" args="(long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dnew           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new T matrix object. 
<p>
initialized all to zero. <div class="fragment"><pre class="fragment"><a name="l00137"></a>00137                                 {
<a name="l00138"></a>00138     <span class="keywordflow">return</span> X(new_do)(NULL,nx,ny,0);
<a name="l00139"></a>00139 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d1c7365b3e3f0da49ddbf496bd46514b"></a><!-- doxytag: member="dmat.h::dfree_keepdata" ref="d1c7365b3e3f0da49ddbf496bd46514b" args="(dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dfree_keepdata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free the X(mat), but keep the data. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00144"></a>00144                                 {
<a name="l00145"></a>00145     X(free_do)(A,1);
<a name="l00146"></a>00146 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5714a51acdc824562d451b9fde5d5da2"></a><!-- doxytag: member="dmat.h::dfree_do" ref="5714a51acdc824562d451b9fde5d5da2" args="(dmat *A, int keepdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>keepdata</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(mat) object. 
<p>
if keepdata!=0, will not free A-&gt;p. <div class="fragment"><pre class="fragment"><a name="l00150"></a>00150                                         {
<a name="l00151"></a>00151     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00152"></a>00152     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdmat.html#0aed31047c7881be15167e19415a0557" title="reference count">nref</a>[0]==1){
<a name="l00153"></a>00153     free(A-&gt;<a class="code" href="structdmat.html#0aed31047c7881be15167e19415a0557" title="reference count">nref</a>);
<a name="l00154"></a>00154     <span class="keywordflow">if</span>(!keepdata &amp;&amp; A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>){
<a name="l00155"></a>00155         <span class="keywordflow">switch</span>(A-&gt;<a class="code" href="structdmat.html#75e5b16c2af85a4f512543afc8faa5ff" title="specify whether this is allocated or in shared memory.">type</a>){
<a name="l00156"></a>00156         <span class="keywordflow">case</span> MT_NORMAL:
<a name="l00157"></a>00157         free(A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>); 
<a name="l00158"></a>00158 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>        <a class="code" href="fft_8c.html#1752744dba77b7791b1a629eab4ca99e" title="Free FFTW plans.">cfree_plan</a>(A);
<a name="l00160"></a>00160 <span class="preprocessor">#endif</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span>        <span class="keywordflow">break</span>;
<a name="l00162"></a>00162         <span class="keywordflow">case</span> MT_MMAP:
<a name="l00163"></a>00163         {
<a name="l00164"></a>00164 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span>        <a class="code" href="fft_8c.html#1752744dba77b7791b1a629eab4ca99e" title="Free FFTW plans.">cfree_plan</a>(A);
<a name="l00166"></a>00166 <span class="preprocessor">#endif</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span>        <span class="keywordtype">long</span> headersize=<span class="keyword">sizeof</span>(long)*2+<span class="keyword">sizeof</span>(uint32_t);
<a name="l00168"></a>00168         munmap(((<span class="keywordtype">char</span>*)A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>)-headersize, headersize+A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>*<span class="keyword">sizeof</span>(T));
<a name="l00169"></a>00169         }
<a name="l00170"></a>00170         <span class="keywordflow">break</span>;
<a name="l00171"></a>00171         <span class="keywordflow">case</span> MT_REF:<span class="comment">//reference from a nother vector. don't free.</span>
<a name="l00172"></a>00172         <span class="keywordflow">break</span>;
<a name="l00173"></a>00173         <span class="keywordflow">default</span>:
<a name="l00174"></a>00174         warning(<span class="stringliteral">"Wrong format: p=%p. type=%ld\n"</span>, A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>, A-&gt;<a class="code" href="structdmat.html#75e5b16c2af85a4f512543afc8faa5ff" title="specify whether this is allocated or in shared memory.">type</a>);
<a name="l00175"></a>00175         }
<a name="l00176"></a>00176     }
<a name="l00177"></a>00177     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdmat.html#0aed31047c7881be15167e19415a0557" title="reference count">nref</a>[0]&gt;1){
<a name="l00178"></a>00178     A-&gt;<a class="code" href="structdmat.html#0aed31047c7881be15167e19415a0557" title="reference count">nref</a>[0]--;
<a name="l00179"></a>00179     }<span class="keywordflow">else</span>{
<a name="l00180"></a>00180     error(<span class="stringliteral">"The ref is less than 1. unlikely!!!:%ld\n"</span>,A-&gt;<a class="code" href="structdmat.html#0aed31047c7881be15167e19415a0557" title="reference count">nref</a>[0]);
<a name="l00181"></a>00181     }
<a name="l00182"></a>00182     free(A);
<a name="l00183"></a>00183 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="301b5a86cec0090378b142a09fb2066a"></a><!-- doxytag: member="dmat.h::dresize" ref="301b5a86cec0090378b142a09fb2066a" args="(dmat *A, long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dresize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resize a matrix by adding or removing columns or rows. 
<p>
Data is kept whever possible. Not used as of 2010-09-07. <div class="fragment"><pre class="fragment"><a name="l00189"></a>00189                                            {
<a name="l00190"></a>00190     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdmat.html#0aed31047c7881be15167e19415a0557" title="reference count">nref</a>[0]&gt;1){
<a name="l00191"></a>00191     error(<span class="stringliteral">"Resizing a referenced vector\n"</span>);
<a name="l00192"></a>00192     }
<a name="l00193"></a>00193     <span class="keywordflow">if</span>(nx==0 || ny==0){
<a name="l00194"></a>00194     warning(<span class="stringliteral">"resizing to (%ld, %ld). Free the vector.\n"</span>, nx,ny);
<a name="l00195"></a>00195     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>) free(A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>);
<a name="l00196"></a>00196     A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>=NULL;
<a name="l00197"></a>00197     A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>=nx;
<a name="l00198"></a>00198     A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>=ny;
<a name="l00199"></a>00199     }
<a name="l00200"></a>00200     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>&gt;nx || A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>&gt;ny){
<a name="l00201"></a>00201     warning(<span class="stringliteral">"Resize from (%ld,%ld) to (%ld,%ld)\n"</span>,
<a name="l00202"></a>00202         A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>,A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>,nx,ny);
<a name="l00203"></a>00203     }
<a name="l00204"></a>00204     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>==nx){
<a name="l00205"></a>00205     A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>=realloc(A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>, <span class="keyword">sizeof</span>(T)*nx*ny);
<a name="l00206"></a>00206     <span class="keywordflow">if</span>(nx*ny&gt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>){
<a name="l00207"></a>00207         memset(A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>+A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>, 0, (nx*ny-A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>)*<span class="keyword">sizeof</span>(T));
<a name="l00208"></a>00208     }
<a name="l00209"></a>00209     }<span class="keywordflow">else</span>{
<a name="l00210"></a>00210     warning(<span class="stringliteral">"column vector length is not preserved!!!"</span>);
<a name="l00211"></a>00211     T *p=calloc(nx*ny,<span class="keyword">sizeof</span>(T));
<a name="l00212"></a>00212     <span class="keywordtype">long</span> minx=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>&lt;nx?A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>:nx;
<a name="l00213"></a>00213     <span class="keywordtype">long</span> miny=A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>&lt;ny?A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>:ny;
<a name="l00214"></a>00214     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;miny; iy++){
<a name="l00215"></a>00215         memcpy(p+iy*nx, A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>+iy*A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, <span class="keyword">sizeof</span>(T)*minx);
<a name="l00216"></a>00216     }
<a name="l00217"></a>00217     free(A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>);
<a name="l00218"></a>00218     A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>=p;
<a name="l00219"></a>00219     }
<a name="l00220"></a>00220 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a9c20ae37907780af63d91312d4fea38"></a><!-- doxytag: member="dmat.h::dref" ref="a9c20ae37907780af63d91312d4fea38" args="(dmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dref           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creat a X(mat) reference an existing X(mat). 
<p>
Use the reference carefully. <div class="fragment"><pre class="fragment"><a name="l00225"></a>00225                           {
<a name="l00226"></a>00226     <span class="keywordflow">if</span>(!in) <span class="keywordflow">return</span> NULL;
<a name="l00227"></a>00227     X(mat) *out=calloc(1, <span class="keyword">sizeof</span>(X(mat)));
<a name="l00228"></a>00228     <span class="keywordflow">if</span>(!out){
<a name="l00229"></a>00229     error(<span class="stringliteral">"Allocation failed\n"</span>);
<a name="l00230"></a>00230     }
<a name="l00231"></a>00231     memcpy(out,in,<span class="keyword">sizeof</span>(X(mat)));
<a name="l00232"></a>00232     out-&gt;nref[0]++;
<a name="l00233"></a>00233     <span class="keywordflow">return</span> out;
<a name="l00234"></a>00234 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9033c130427b2e4cc3eabd68c9630948"></a><!-- doxytag: member="dmat.h::dref_reshape" ref="9033c130427b2e4cc3eabd68c9630948" args="(dmat *in, int nx, int ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dref_reshape           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create an new X(mat) reference another with different shape. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00239"></a>00239                                                   {
<a name="l00240"></a>00240     X(mat) *out=X(ref)(in);
<a name="l00241"></a>00241     <span class="keywordflow">if</span>(in-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*in-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>!=nx*ny){
<a name="l00242"></a>00242     error(<span class="stringliteral">"Must not change number of elements\n"</span>);
<a name="l00243"></a>00243     }
<a name="l00244"></a>00244     out-&gt;nx=nx;
<a name="l00245"></a>00245     out-&gt;ny=ny;
<a name="l00246"></a>00246     <span class="keywordflow">return</span> out;
<a name="l00247"></a>00247 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d0c062d9a51fd5cff9924c066ca0b0bc"></a><!-- doxytag: member="dmat.h::drefcols" ref="d0c062d9a51fd5cff9924c066ca0b0bc" args="(dmat *in, long icol, long ncol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* drefcols           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>icol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ncol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creat a new X(mat) referencing columns in existing X(mat). 
<p>
reference counted. not used <div class="fragment"><pre class="fragment"><a name="l00253"></a>00253                                                     {
<a name="l00254"></a>00254     X(mat) *out=calloc(1, <span class="keyword">sizeof</span>(X(mat)));
<a name="l00255"></a>00255     out-&gt;type=MT_REF;
<a name="l00256"></a>00256     out-&gt;nref=in-&gt;<a class="code" href="structdmat.html#0aed31047c7881be15167e19415a0557" title="reference count">nref</a>;
<a name="l00257"></a>00257     out-&gt;nref[0]++;
<a name="l00258"></a>00258     out-&gt;nx=in-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l00259"></a>00259     out-&gt;ny=ncol;
<a name="l00260"></a>00260     out-&gt;p=in-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>+icol*out-&gt;nx;
<a name="l00261"></a>00261     <span class="keywordflow">return</span> out;
<a name="l00262"></a>00262 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0e149114c808ff424f7fe215ee44d307"></a><!-- doxytag: member="dmat.h::dsub" ref="0e149114c808ff424f7fe215ee44d307" args="(const dmat *in, long sx, long nx, long sy, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dsub           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new sub matrix of nx*ny starting from(sx,sy). 
<p>
<div class="fragment"><pre class="fragment"><a name="l00267"></a>00267                                                                     {
<a name="l00268"></a>00268     <span class="keywordflow">if</span>(nx&lt;=sx){
<a name="l00269"></a>00269     nx=in-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>-sx;
<a name="l00270"></a>00270     }
<a name="l00271"></a>00271     <span class="keywordflow">if</span>(ny&lt;=sy){
<a name="l00272"></a>00272     ny=in-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>-sy;
<a name="l00273"></a>00273     }
<a name="l00274"></a>00274     X(mat)*out=X(<span class="keyword">new</span>)(nx, ny);
<a name="l00275"></a>00275     <span class="keywordflow">if</span>(sx+nx&gt;in-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> || sy+ny&gt;in-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>){
<a name="l00276"></a>00276     error(<span class="stringliteral">"Invalid parameter range\n"</span>);
<a name="l00277"></a>00277     }
<a name="l00278"></a>00278     PMAT(in, pin);
<a name="l00279"></a>00279     PMAT(out, pout);
<a name="l00280"></a>00280     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;ny; iy++){
<a name="l00281"></a>00281     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;nx; ix++){
<a name="l00282"></a>00282         pout[iy][ix]=pin[iy+sy][ix+sx];
<a name="l00283"></a>00283     }
<a name="l00284"></a>00284     }
<a name="l00285"></a>00285     <span class="keywordflow">return</span> out;
<a name="l00286"></a>00286 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="131e99be189eda7c5b32aba76bcbe8d8"></a><!-- doxytag: member="dmat.h::dcat" ref="131e99be189eda7c5b32aba76bcbe8d8" args="(const dmat *in1, const dmat *in2, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dcat           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
concatenate two matrixes into 1 along dimension "dim" 
<p>
<div class="fragment"><pre class="fragment"><a name="l00291"></a>00291                                                              {
<a name="l00292"></a>00292     <span class="keywordflow">if</span>(!in2){
<a name="l00293"></a>00293     <span class="keywordflow">if</span>(in1){
<a name="l00294"></a>00294         <span class="keywordflow">return</span> X(dup)(in1);
<a name="l00295"></a>00295     }<span class="keywordflow">else</span>{
<a name="l00296"></a>00296         <span class="keywordflow">return</span> NULL;
<a name="l00297"></a>00297     }
<a name="l00298"></a>00298     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(!in1){
<a name="l00299"></a>00299     <span class="keywordflow">return</span> X(dup)(in2);
<a name="l00300"></a>00300     }
<a name="l00301"></a>00301 
<a name="l00302"></a>00302     X(mat) *out=NULL;
<a name="l00303"></a>00303 
<a name="l00304"></a>00304     <span class="keywordflow">if</span>(dim==1){
<a name="l00305"></a>00305     <span class="comment">//along x.</span>
<a name="l00306"></a>00306     <span class="keywordflow">if</span>(in1-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>!=in2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>){
<a name="l00307"></a>00307         error(<span class="stringliteral">"Mismatch. in1 is (%ld, %ld), in2 is (%ld, %ld)\n"</span>, 
<a name="l00308"></a>00308           in1-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, in1-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>, in2-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, in2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00309"></a>00309     }
<a name="l00310"></a>00310     out=X(<span class="keyword">new</span>)(in1-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>+in2-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, in1-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00311"></a>00311     PMAT(out,pout);
<a name="l00312"></a>00312     PMAT(in1,pin1);
<a name="l00313"></a>00313     PMAT(in2,pin2);
<a name="l00314"></a>00314     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;in1-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l00315"></a>00315         memcpy(pout[iy],pin1[iy], in1-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*<span class="keyword">sizeof</span>(T));
<a name="l00316"></a>00316         memcpy(pout[iy]+in1-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, pin2[iy], in2-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*<span class="keyword">sizeof</span>(T));
<a name="l00317"></a>00317     }
<a name="l00318"></a>00318     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim==2){
<a name="l00319"></a>00319     <span class="comment">//along y.</span>
<a name="l00320"></a>00320     <span class="keywordflow">if</span>(in1-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>!=in2-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>){
<a name="l00321"></a>00321         error(<span class="stringliteral">"Mismatch. in1 is (%ld, %ld), in2 is (%ld, %ld)\n"</span>, 
<a name="l00322"></a>00322           in1-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, in1-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>, in2-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, in2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00323"></a>00323     }
<a name="l00324"></a>00324     out=X(<span class="keyword">new</span>)(in1-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, in1-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>+in2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00325"></a>00325     memcpy(out-&gt;p, in1-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>, in1-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*in1-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>*<span class="keyword">sizeof</span>(T));
<a name="l00326"></a>00326     memcpy(out-&gt;p+in1-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*in1-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>,in2-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>,in2-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*in2-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>*<span class="keyword">sizeof</span>(T));
<a name="l00327"></a>00327     }<span class="keywordflow">else</span>{
<a name="l00328"></a>00328     error(<span class="stringliteral">"Invalid dim\n"</span>);
<a name="l00329"></a>00329     }
<a name="l00330"></a>00330     <span class="keywordflow">return</span> out;
<a name="l00331"></a>00331 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ca6f393efef34132906a9e302e96b978"></a><!-- doxytag: member="dmat.h::darrfree" ref="ca6f393efef34132906a9e302e96b978" args="(dmat **As, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void darrfree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>As</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(mat) array. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00336"></a>00336                                    {
<a name="l00337"></a>00337     <span class="keywordtype">int</span> i;
<a name="l00338"></a>00338     <span class="keywordflow">if</span>(!As) <span class="keywordflow">return</span>;
<a name="l00339"></a>00339     <span class="keywordflow">for</span>(i=0; i&lt;n; i++){
<a name="l00340"></a>00340     X(free)(As[i]);
<a name="l00341"></a>00341     }
<a name="l00342"></a>00342     free(As);
<a name="l00343"></a>00343 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7ecadca31195b8b40135b7dbeb808906"></a><!-- doxytag: member="dmat.h::ddup" ref="7ecadca31195b8b40135b7dbeb808906" args="(const dmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* ddup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
duplicate a X(mat) array 
<p>
<div class="fragment"><pre class="fragment"><a name="l00374"></a>00374                                 {
<a name="l00375"></a>00375     X(mat) *out=NULL;
<a name="l00376"></a>00376     X(cp)(&amp;out, in);
<a name="l00377"></a>00377     <span class="keywordflow">return</span> out;
<a name="l00378"></a>00378 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b5adc5cd1e79d9a79751ba482728f230"></a><!-- doxytag: member="dmat.h::dcp" ref="b5adc5cd1e79d9a79751ba482728f230" args="(dmat **out0, const dmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy the values from one X(mat) to another. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00383"></a>00383                                            {
<a name="l00384"></a>00384     <span class="keywordflow">if</span>(in &amp;&amp; in-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>!=0 &amp;&amp; in-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>!=0){
<a name="l00385"></a>00385     <span class="keywordflow">if</span>(!*out0) 
<a name="l00386"></a>00386         *out0=X(<span class="keyword">new</span>)(in-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, in-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00387"></a>00387     <span class="keywordflow">else</span>{
<a name="l00388"></a>00388         assert(in-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>==(*out0)-&gt;nx &amp;&amp; in-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a> == (*out0)-&gt;ny);
<a name="l00389"></a>00389     }
<a name="l00390"></a>00390     X(mat) *out=*out0;
<a name="l00391"></a>00391     memcpy(out-&gt;p, in-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>, in-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*in-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>*<span class="keyword">sizeof</span>(T));
<a name="l00392"></a>00392     }<span class="keywordflow">else</span>{
<a name="l00393"></a>00393     X(free)(*out0); *out0=NULL;
<a name="l00394"></a>00394     }
<a name="l00395"></a>00395 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2ce308cca861c7b07e46fcbe1bedc919"></a><!-- doxytag: member="dmat.h::dtrans" ref="2ce308cca861c7b07e46fcbe1bedc919" args="(const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dtrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
transpose a X(mat) object 
<p>
<div class="fragment"><pre class="fragment"><a name="l00400"></a>00400                                  {
<a name="l00401"></a>00401     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l00402"></a>00402     X(mat) *B=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>,A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>);
<a name="l00403"></a>00403     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>==1 || A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1){
<a name="l00404"></a>00404     memcpy(B-&gt;p, A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>, A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>*<span class="keyword">sizeof</span>(T));
<a name="l00405"></a>00405     }<span class="keywordflow">else</span>{
<a name="l00406"></a>00406     T (*Bp)[B-&gt;nx]=(<span class="keywordtype">void</span>*)B-&gt;p;
<a name="l00407"></a>00407     T (*Ap)[A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>]=(<span class="keywordtype">void</span>*)A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00408"></a>00408     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;nx; ix++){
<a name="l00409"></a>00409         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l00410"></a>00410         Bp[ix][iy]=Ap[iy][ix];
<a name="l00411"></a>00411         }
<a name="l00412"></a>00412     }
<a name="l00413"></a>00413     }
<a name="l00414"></a>00414     <span class="keywordflow">return</span> B;
<a name="l00415"></a>00415 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="705d6399ce6e7f7064d12f4eb131d47d"></a><!-- doxytag: member="dmat.h::dset" ref="705d6399ce6e7f7064d12f4eb131d47d" args="(dmat *A, const double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set values of each element in a X(mat) to val. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00420"></a>00420                                    {
<a name="l00421"></a>00421     <span class="keywordflow">if</span>(A){
<a name="l00422"></a>00422     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; i++){
<a name="l00423"></a>00423         A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i]=val;
<a name="l00424"></a>00424     }
<a name="l00425"></a>00425     }
<a name="l00426"></a>00426 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e98618064b54869b4180d0c7fd895645"></a><!-- doxytag: member="dmat.h::dzero" ref="e98618064b54869b4180d0c7fd895645" args="(dmat *out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dzero           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>out</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
initialize all numbers in a X(mat) object to 0 
<p>
<div class="fragment"><pre class="fragment"><a name="l00431"></a>00431                          {
<a name="l00432"></a>00432     <span class="keywordflow">if</span>(out){
<a name="l00433"></a>00433     memset(out-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>, 0, <span class="keyword">sizeof</span>(T)*out-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*out-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00434"></a>00434     }
<a name="l00435"></a>00435 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="abb4fecd296ac9ec19263e0f9d853be7"></a><!-- doxytag: member="dmat.h::dmax" ref="abb4fecd296ac9ec19263e0f9d853be7" args="(const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dmax           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find the maximum value of a X(mat) object 
<p>
<div class="fragment"><pre class="fragment"><a name="l00348"></a>00348                               {
<a name="l00349"></a>00349     <span class="keywordtype">double</span> max,min,sum;
<a name="l00350"></a>00350 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l00351"></a>00351 <span class="preprocessor"></span>    maxmincmp(A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>,A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>,&amp;max,&amp;min,&amp;sum);
<a name="l00352"></a>00352 <span class="preprocessor">#else</span>
<a name="l00353"></a>00353 <span class="preprocessor"></span>    maxmindbl(A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>,A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>,&amp;max,&amp;min,&amp;sum);
<a name="l00354"></a>00354 <span class="preprocessor">#endif</span>
<a name="l00355"></a>00355 <span class="preprocessor"></span>    <span class="keywordflow">return</span> max;
<a name="l00356"></a>00356 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="00004b652c3485c94f4f64cfdafe5577"></a><!-- doxytag: member="dmat.h::dmin" ref="00004b652c3485c94f4f64cfdafe5577" args="(const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dmin           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find the minimum value of a X(mat) object 
<p>
<div class="fragment"><pre class="fragment"><a name="l00361"></a>00361                               {
<a name="l00362"></a>00362     <span class="keywordtype">double</span> max,min,sum;
<a name="l00363"></a>00363 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l00364"></a>00364 <span class="preprocessor"></span>    maxmincmp(A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>,A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>,&amp;max,&amp;min,&amp;sum);
<a name="l00365"></a>00365 <span class="preprocessor">#else</span>
<a name="l00366"></a>00366 <span class="preprocessor"></span>    maxmindbl(A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>,A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>,&amp;max,&amp;min,&amp;sum);
<a name="l00367"></a>00367 <span class="preprocessor">#endif</span>
<a name="l00368"></a>00368 <span class="preprocessor"></span>    <span class="keywordflow">return</span> min;
<a name="l00369"></a>00369 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="060e5d00143124ecbad59364c16da459"></a><!-- doxytag: member="dmat.h::dnorm2" ref="060e5d00143124ecbad59364c16da459" args="(const dmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dnorm2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the norm2 of A 
<p>
<div class="fragment"><pre class="fragment"><a name="l00440"></a>00440                                {
<a name="l00441"></a>00441     <span class="keywordtype">double</span> out=0;
<a name="l00442"></a>00442     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;nx; i++){
<a name="l00443"></a>00443     out+=(double)(A-&gt;p[i]*CONJ(A-&gt;p[i]));
<a name="l00444"></a>00444     }
<a name="l00445"></a>00445     <span class="keywordflow">return</span> out;
<a name="l00446"></a>00446 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="95eddaf29cb4e4f2b6d18f74a489bd50"></a><!-- doxytag: member="dmat.h::drandu" ref="95eddaf29cb4e4f2b6d18f74a489bd50" args="(dmat *A, const double mean, mt_state *rstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drandu           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmt__state.html">mt_state</a> *&nbsp;</td>
          <td class="paramname"> <em>rstat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill A with random uniform numbers between [0, 1]*max. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00451"></a>00451                                                          {
<a name="l00452"></a>00452     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00453"></a>00453     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; i++){
<a name="l00454"></a>00454     A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i]=RANDU(rstat)*max;
<a name="l00455"></a>00455     }
<a name="l00456"></a>00456 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9cd5fc527b28964eac1f1c0bc8a03601"></a><!-- doxytag: member="dmat.h::drandn" ref="9cd5fc527b28964eac1f1c0bc8a03601" args="(dmat *A, const double sigma, mt_state *rstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drandn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmt__state.html">mt_state</a> *&nbsp;</td>
          <td class="paramname"> <em>rstat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill A with random normal distribution numbers with standard deviation of sigma. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00461"></a>00461                                                            {
<a name="l00462"></a>00462     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00463"></a>00463     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; i++){
<a name="l00464"></a>00464     A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i]=RANDN(rstat)*sigma;
<a name="l00465"></a>00465     }
<a name="l00466"></a>00466 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="657f20445f371c8deaff82a5a052c02f"></a><!-- doxytag: member="dmat.h::dshow" ref="657f20445f371c8deaff82a5a052c02f" args="(const dmat *A, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dshow           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
display a X(mat) matrix. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00471"></a>00471                                                       {
<a name="l00472"></a>00472     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00473"></a>00473     format2fn;
<a name="l00474"></a>00474     info(<span class="stringliteral">"show: %s"</span>,fn);
<a name="l00475"></a>00475     T (*restrict p)[A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>]=(T (*)[A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>])A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00476"></a>00476     <span class="keywordtype">long</span> colmax=10;
<a name="l00477"></a>00477     <span class="keywordtype">long</span> icol,i,j;
<a name="l00478"></a>00478     <span class="keywordflow">for</span>(icol=0; icol&lt;ceil((<span class="keywordtype">double</span>)A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>/(<span class="keywordtype">double</span>)colmax); icol++){
<a name="l00479"></a>00479     <span class="keywordtype">int</span> ncol=(icol+1)*colmax;
<a name="l00480"></a>00480     <span class="keywordflow">if</span>(ncol&gt;A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>) ncol=A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l00481"></a>00481     printf(<span class="stringliteral">"Cols %ld to %d\n"</span>, icol, ncol-1);
<a name="l00482"></a>00482     <span class="keywordflow">for</span>(j=0; j&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; j++){
<a name="l00483"></a>00483         <span class="keywordflow">for</span>(i=icol*colmax; i&lt;ncol; i++){
<a name="l00484"></a>00484         PRINT(p[i][j]);
<a name="l00485"></a>00485         }
<a name="l00486"></a>00486         printf(<span class="stringliteral">"\n"</span>);
<a name="l00487"></a>00487     }
<a name="l00488"></a>00488     }
<a name="l00489"></a>00489 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9a9da6ac02ccf42247a8a78a131ca73a"></a><!-- doxytag: member="dmat.h::dscale" ref="9a9da6ac02ccf42247a8a78a131ca73a" args="(dmat *A, double w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>w</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
scale each element of A by w 
<p>
<div class="fragment"><pre class="fragment"><a name="l00494"></a>00494                              {
<a name="l00495"></a>00495     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00496"></a>00496     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; i++){
<a name="l00497"></a>00497     A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i]*=w;
<a name="l00498"></a>00498     }
<a name="l00499"></a>00499 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="176e534c9042ace51d05a620a2294248"></a><!-- doxytag: member="dmat.h::dsum" ref="176e534c9042ace51d05a620a2294248" args="(const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dsum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create sum of all the elements in A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00504"></a>00504                          {
<a name="l00505"></a>00505     T v=0;
<a name="l00506"></a>00506     <span class="keywordflow">if</span>(A){
<a name="l00507"></a>00507     T *restrict p=A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;<span class="comment"></span>
<a name="l00508"></a>00508 <span class="comment">    /**</span>
<a name="l00509"></a>00509 <span class="comment">       Loops like this will only be vectorized with -ffast-math because</span>
<a name="l00510"></a>00510 <span class="comment">       different orders of accumulation give different results for floating</span>
<a name="l00511"></a>00511 <span class="comment">       point numbers.</span>
<a name="l00512"></a>00512 <span class="comment">    */</span>
<a name="l00513"></a>00513     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; i++){
<a name="l00514"></a>00514         v+=p[i];
<a name="l00515"></a>00515     }
<a name="l00516"></a>00516     }
<a name="l00517"></a>00517     <span class="keywordflow">return</span> v;
<a name="l00518"></a>00518 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4c4f53dc9572106deb6933eb103bf40b"></a><!-- doxytag: member="dmat.h::dadd" ref="4c4f53dc9572106deb6933eb103bf40b" args="(dmat **B0, double bc, const dmat *A, const double ac)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dadd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>ac</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute B=bc*B+ac*A behavior changed on 2009-11-02. 
<p>
if A is NULL, don't do anything. <div class="fragment"><pre class="fragment"><a name="l00524"></a>00524                                                           {
<a name="l00525"></a>00525     <span class="keywordflow">if</span>(A){
<a name="l00526"></a>00526     <span class="keywordflow">if</span>(!*B0){
<a name="l00527"></a>00527         *B0=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>); bc=0;
<a name="l00528"></a>00528     }
<a name="l00529"></a>00529     X(mat) *B=*B0;
<a name="l00530"></a>00530     assert(A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>==B-&gt;nx &amp;&amp; A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a> == B-&gt;ny);
<a name="l00531"></a>00531     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; i++){
<a name="l00532"></a>00532         B-&gt;p[i]=B-&gt;p[i]*bc+A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i]*ac;
<a name="l00533"></a>00533     }
<a name="l00534"></a>00534     }
<a name="l00535"></a>00535 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d5e98c2e933c9ca456e3dc1a47b6bea2"></a><!-- doxytag: member="dmat.h::dinn" ref="d5e98c2e933c9ca456e3dc1a47b6bea2" args="(const dmat *A, const dmat *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the inner product of A and B. 
<p>
(inner product) <div class="fragment"><pre class="fragment"><a name="l00541"></a>00541                                          {
<a name="l00542"></a>00542     assert(A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>==B-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> &amp;&amp; A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1 &amp;&amp; B-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1);
<a name="l00543"></a>00543     T out=0;
<a name="l00544"></a>00544     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; i++){
<a name="l00545"></a>00545     out+=A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i]*B-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i];
<a name="l00546"></a>00546     }
<a name="l00547"></a>00547     <span class="keywordflow">if</span>(isnan(out)){
<a name="l00548"></a>00548     error(<span class="stringliteral">"NaN found\n"</span>);
<a name="l00549"></a>00549     }
<a name="l00550"></a>00550     <span class="keywordflow">return</span> out;
<a name="l00551"></a>00551 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="85aee0e43bf0c24f996b45f3e1d721a6"></a><!-- doxytag: member="dmat.h::dwdot" ref="85aee0e43bf0c24f996b45f3e1d721a6" args="(const double *a, const dmat *w, const double *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dwdot           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute weighted dot product a'*(w*b) 
<p>
<div class="fragment"><pre class="fragment"><a name="l00556"></a>00556                                                   {
<a name="l00557"></a>00557     PMAT(w,pw);
<a name="l00558"></a>00558     T res=0;
<a name="l00559"></a>00559     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;w-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; j++){
<a name="l00560"></a>00560     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;w-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; i++){
<a name="l00561"></a>00561         res+=pw[j][i]*a[i]*b[j];
<a name="l00562"></a>00562     }
<a name="l00563"></a>00563     }
<a name="l00564"></a>00564     <span class="keywordflow">return</span> res;
<a name="l00565"></a>00565 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ac8016fed8bbcc2a49d5a9ba3b835755"></a><!-- doxytag: member="dmat.h::dwdot2" ref="ac8016fed8bbcc2a49d5a9ba3b835755" args="(const double *a, const dmat *w, const double *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dwdot2           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
special version of dwdot for just 2 element vectors. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00570"></a>00570                                                    {
<a name="l00571"></a>00571     assert(w-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>==2 &amp;&amp; w-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==2);
<a name="l00572"></a>00572     T (*W)[2]=(T(*)[2])w-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00573"></a>00573     T res;
<a name="l00574"></a>00574     res=a[0]*(W[0][0]*b[0]+W[1][0]*b[1])
<a name="l00575"></a>00575     +a[1]*(W[0][1]*b[0]+W[1][1]*b[1]);
<a name="l00576"></a>00576     <span class="keywordflow">return</span> res;
<a name="l00577"></a>00577 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2ad0b887d8ae79cd753310e095e2bd07"></a><!-- doxytag: member="dmat.h::dwdot3" ref="2ad0b887d8ae79cd753310e095e2bd07" args="(const double *a, const dmat *w, const double *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dwdot3           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
special version of dwdot for just 3 element vectors. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00582"></a>00582                                                    {
<a name="l00583"></a>00583     assert(w-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>==3 &amp;&amp; w-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==3);
<a name="l00584"></a>00584     T (*W)[3]=(T(*)[3])w-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00585"></a>00585     T res;
<a name="l00586"></a>00586     res=a[0]*(W[0][0]*b[0]+W[1][0]*b[1]+W[2][0]*b[2])
<a name="l00587"></a>00587     +a[1]*(W[0][1]*b[0]+W[1][1]*b[1]+W[2][1]*b[2])
<a name="l00588"></a>00588     +a[2]*(W[0][2]*b[0]+W[1][2]*b[1]+W[2][2]*b[2]);
<a name="l00589"></a>00589     <span class="keywordflow">return</span> res;
<a name="l00590"></a>00590 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="fda5697c36cb1de9790b812d919697c8"></a><!-- doxytag: member="dmat.h::dcwm" ref="fda5697c36cb1de9790b812d919697c8" args="(dmat *B, const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcwm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute component wise multiply B=B. 
<p>
*A <div class="fragment"><pre class="fragment"><a name="l00595"></a>00595                                        {
<a name="l00596"></a>00596     assert(A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>==B-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> &amp;&amp; A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==B-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00597"></a>00597     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; i++){
<a name="l00598"></a>00598     B-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i]*=A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i];
<a name="l00599"></a>00599     }
<a name="l00600"></a>00600 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="108a4a2f57a5f271427d7af94a71abd8"></a><!-- doxytag: member="dmat.h::dmulvec" ref="108a4a2f57a5f271427d7af94a71abd8" args="(double *restrict y, const dmat *restrict A, const double *restrict x, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dmulvec           </td>
          <td>(</td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
multiply a X(mat) matrix with a vector and accumulate to y: y+=A*x*alpha 
<p>
<div class="fragment"><pre class="fragment"><a name="l00607"></a>00607                                               {
<a name="l00608"></a>00608     assert(y &amp;&amp; x &amp;&amp; A);
<a name="l00609"></a>00609     T (*restrict Ap)[A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>]=(<span class="keywordtype">void</span>*)A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00610"></a>00610     <span class="keywordflow">if</span>(ABS(alpha-1)&gt;1.e-15){
<a name="l00611"></a>00611     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l00612"></a>00612         T tmp=x[iy]*alpha;
<a name="l00613"></a>00613         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; ix++){
<a name="l00614"></a>00614         y[ix]+=Ap[iy][ix]*tmp;
<a name="l00615"></a>00615         }
<a name="l00616"></a>00616     }
<a name="l00617"></a>00617     }<span class="keywordflow">else</span>{
<a name="l00618"></a>00618     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l00619"></a>00619         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; ix++){
<a name="l00620"></a>00620         y[ix]+=Ap[iy][ix]*x[iy];
<a name="l00621"></a>00621         }
<a name="l00622"></a>00622     }
<a name="l00623"></a>00623     }
<a name="l00624"></a>00624 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a9ddb63c56fcc2219955260936ee9e40"></a><!-- doxytag: member="dmat.h::dmm" ref="a9ddb63c56fcc2219955260936ee9e40" args="(dmat **C0, const dmat *A, const dmat *B, const char trans[2], const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dmm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>trans</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute matrix product using blas dgemm with beta=1; C=beta*C+ alpha *trans(A)*trans(B); if C exist. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00631"></a>00631                                           {
<a name="l00632"></a>00632     <span class="keywordflow">if</span>(!A || !B) <span class="keywordflow">return</span>;
<a name="l00633"></a>00633     <span class="keywordtype">int</span> m,n,k,lda,ldb,ldc,k2;
<a name="l00634"></a>00634     <span class="keywordflow">if</span> (trans[0]==<span class="charliteral">'T'</span> || trans[0]==<span class="charliteral">'t'</span> || trans[0]==<span class="charliteral">'C'</span> || trans[0]==<span class="charliteral">'c'</span>){
<a name="l00635"></a>00635     m=A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; k=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l00636"></a>00636     }<span class="keywordflow">else</span>{
<a name="l00637"></a>00637     m=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; k=A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l00638"></a>00638     }
<a name="l00639"></a>00639     <span class="keywordflow">if</span> (trans[1]==<span class="charliteral">'T'</span> || trans[1]==<span class="charliteral">'t'</span>|| trans[0]==<span class="charliteral">'C'</span> || trans[0]==<span class="charliteral">'c'</span>){
<a name="l00640"></a>00640     n=B-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l00641"></a>00641     k2=B-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l00642"></a>00642     }<span class="keywordflow">else</span>{
<a name="l00643"></a>00643     n=B-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l00644"></a>00644     k2=B-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l00645"></a>00645     }
<a name="l00646"></a>00646     <span class="keywordflow">if</span>(k!=k2) error(<span class="stringliteral">"dmm: Matrix doesn't match\n"</span>);
<a name="l00647"></a>00647     <span class="keywordflow">if</span>(!*C0){
<a name="l00648"></a>00648     *C0=X(<span class="keyword">new</span>)(m,n); 
<a name="l00649"></a>00649     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(m!=(*C0)-&gt;nx || n!=(*C0)-&gt;ny){
<a name="l00650"></a>00650     error(<span class="stringliteral">"dmm: Matrix doesn't match\n"</span>);
<a name="l00651"></a>00651     }
<a name="l00652"></a>00652     X(mat) *C=*C0;
<a name="l00653"></a>00653     lda=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l00654"></a>00654     ldb=B-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l00655"></a>00655     ldc=C-&gt;nx;
<a name="l00656"></a>00656     <span class="keyword">const</span> T beta=1;
<a name="l00657"></a>00657     Z(gemm)(&amp;trans[0], &amp;trans[1], &amp;m,&amp;n,&amp;k,&amp;alpha, 
<a name="l00658"></a>00658         A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>, &amp;lda, B-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>, &amp;ldb, &amp;beta, C-&gt;p,&amp;ldc);
<a name="l00659"></a>00659 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b48bc9b9c8f923e19dafc70b8fff5de2"></a><!-- doxytag: member="dmat.h::dinvspd_inplace" ref="b48bc9b9c8f923e19dafc70b8fff5de2" args="(dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dinvspd_inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace invert a small square SPD matrix using lapack dposv_, usually (A'*w*A). 
<p>
by solving Ax=I; copy x to A. dposv_ modifies A also. be careful <div class="fragment"><pre class="fragment"><a name="l00666"></a>00666                                  {
<a name="l00667"></a>00667     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00668"></a>00668     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>!=A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>) error(<span class="stringliteral">"Must be a square matrix"</span>);
<a name="l00669"></a>00669     <span class="keywordtype">int</span> info=0, N=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l00670"></a>00670     <span class="keyword">const</span> <span class="keywordtype">char</span> uplo=<span class="charliteral">'U'</span>;
<a name="l00671"></a>00671     <span class="comment">// B is identity matrix</span>
<a name="l00672"></a>00672     T *B=calloc(N*N,<span class="keyword">sizeof</span>(T));
<a name="l00673"></a>00673     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0;i&lt;N;i++)
<a name="l00674"></a>00674     B[i+i*N]=1;
<a name="l00675"></a>00675     Z(posv)(&amp;uplo, &amp;N, &amp;N, A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>, &amp;N, B, &amp;N, &amp;info);
<a name="l00676"></a>00676     <span class="keywordflow">if</span>(info!=0){
<a name="l00677"></a>00677     X(write)(A,<span class="stringliteral">"posv"</span>);
<a name="l00678"></a>00678     error(<span class="stringliteral">"posv_ failed, info=%d. data saved to posv.\n"</span>,info);
<a name="l00679"></a>00679     }
<a name="l00680"></a>00680     memcpy(A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>, B, <span class="keyword">sizeof</span>(T)*N*N);
<a name="l00681"></a>00681     free(B);
<a name="l00682"></a>00682 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="30ba84a58a9c9dd2e0a0afb5e389ffad"></a><!-- doxytag: member="dmat.h::dinvspd" ref="30ba84a58a9c9dd2e0a0afb5e389ffad" args="(const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dinvspd           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
out of place version of dinvspd_inplace 
<p>
<div class="fragment"><pre class="fragment"><a name="l00687"></a>00687                                   {
<a name="l00688"></a>00688     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l00689"></a>00689     X(mat) *out=NULL;
<a name="l00690"></a>00690     X(cp)(&amp;out, A);
<a name="l00691"></a>00691     X(invspd_inplace)(out);
<a name="l00692"></a>00692     <span class="keywordflow">return</span> out;
<a name="l00693"></a>00693 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="661f5d1ec1bbcf8237c0f99b2b659314"></a><!-- doxytag: member="dmat.h::dinv_inplace" ref="661f5d1ec1bbcf8237c0f99b2b659314" args="(dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dinv_inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace invert a general square matrix using lapack dgesv_ 
<p>
<div class="fragment"><pre class="fragment"><a name="l00698"></a>00698                              {
<a name="l00699"></a>00699     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00700"></a>00700     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>!=A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>) error(<span class="stringliteral">"Must be a square matrix"</span>);
<a name="l00701"></a>00701     <span class="keywordtype">int</span> info=0, N=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l00702"></a>00702     T *B=calloc(N*N,<span class="keyword">sizeof</span>(T));
<a name="l00703"></a>00703     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;i++)
<a name="l00704"></a>00704     B[i+i*N]=1;
<a name="l00705"></a>00705     <span class="keywordtype">int</span> *ipiv=calloc(N, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00706"></a>00706     Z(gesv)(&amp;N, &amp;N, A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>, &amp;N, ipiv, B, &amp;N, &amp;info);
<a name="l00707"></a>00707     <span class="keywordflow">if</span>(info!=0){
<a name="l00708"></a>00708     X(write)(A,<span class="stringliteral">"gesv"</span>);
<a name="l00709"></a>00709     error(<span class="stringliteral">"dgesv_ failed, info=%d. data saved to posv.\n"</span>,info);
<a name="l00710"></a>00710     }
<a name="l00711"></a>00711     memcpy(A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>, B, <span class="keyword">sizeof</span>(T)*N*N);
<a name="l00712"></a>00712     free(B);
<a name="l00713"></a>00713     free(ipiv);
<a name="l00714"></a>00714 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7a04b161bee57112f209fa41a89c0295"></a><!-- doxytag: member="dmat.h::dinv" ref="7a04b161bee57112f209fa41a89c0295" args="(const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dinv           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
out of place version of dinv 
<p>
<div class="fragment"><pre class="fragment"><a name="l00719"></a>00719                                {
<a name="l00720"></a>00720     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l00721"></a>00721     X(mat) *out=NULL;
<a name="l00722"></a>00722     X(cp)(&amp;out, A);
<a name="l00723"></a>00723     X(inv_inplace)(out);
<a name="l00724"></a>00724     <span class="keywordflow">return</span> out;
<a name="l00725"></a>00725 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="da3db752eaaa609a7ec31fc98804d996"></a><!-- doxytag: member="dmat.h::dmcc" ref="da3db752eaaa609a7ec31fc98804d996" args="(const dmat *A, const dmat *wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dmcc           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute (A'*W*A); where diag(W)=wt 
<p>
<div class="fragment"><pre class="fragment"><a name="l00730"></a>00730                                                  {
<a name="l00731"></a>00731     assert(A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>==wt-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> &amp;&amp; wt-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1);
<a name="l00732"></a>00732     <span class="keywordtype">int</span> nmod=A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l00733"></a>00733     <span class="keywordtype">int</span> nsa2=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l00734"></a>00734     X(mat) *ata=X(<span class="keyword">new</span>)(nmod, nmod);;
<a name="l00735"></a>00735     T (*ATA)[nmod]=(T(*)[nmod])ata-&gt;p; 
<a name="l00736"></a>00736     T (*Ap)[nsa2]=(T(*)[nsa2])A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00737"></a>00737     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> imod=0; imod&lt;nmod; imod++){
<a name="l00738"></a>00738     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jmod=imod; jmod&lt;nmod; jmod++){
<a name="l00739"></a>00739         T tmp=0;
<a name="l00740"></a>00740         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ik=0; ik&lt;nsa2; ik++){
<a name="l00741"></a>00741         tmp+=Ap[imod][ik]*Ap[jmod][ik]*wt-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[ik];
<a name="l00742"></a>00742         }
<a name="l00743"></a>00743         ATA[imod][jmod]=tmp;
<a name="l00744"></a>00744         <span class="keywordflow">if</span>(imod!=jmod)
<a name="l00745"></a>00745         ATA[jmod][imod]=ATA[imod][jmod];
<a name="l00746"></a>00746     }
<a name="l00747"></a>00747     }
<a name="l00748"></a>00748     <span class="keywordflow">return</span> ata;
<a name="l00749"></a>00749 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="15b43fafd86e62f49de974bb3da6f51c"></a><!-- doxytag: member="dmat.h::dimcc" ref="15b43fafd86e62f49de974bb3da6f51c" args="(const dmat *A, const dmat *wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dimcc           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute inv(dmcc(A, wt)) 
<p>
<div class="fragment"><pre class="fragment"><a name="l00754"></a>00754                                                   {
<a name="l00755"></a>00755     X(mat) *mcc=X(mcc)(A,wt);
<a name="l00756"></a>00756     X(invspd_inplace)(mcc);
<a name="l00757"></a>00757     <span class="keywordflow">return</span> mcc;
<a name="l00758"></a>00758 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="81d6ed373bf09f884a5114c8b0f543ac"></a><!-- doxytag: member="dmat.h::dtmcc" ref="81d6ed373bf09f884a5114c8b0f543ac" args="(const dmat *A, const dmat *wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dtmcc           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute (A*W*A'); where diag(W)=wt 
<p>
<div class="fragment"><pre class="fragment"><a name="l00763"></a>00763                                                   {
<a name="l00764"></a>00764     assert(A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==wt-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> &amp;&amp; wt-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1);
<a name="l00765"></a>00765     <span class="keywordtype">int</span> nmod=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l00766"></a>00766     <span class="keywordtype">int</span> nsa2=A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l00767"></a>00767     X(mat) *ata=X(<span class="keyword">new</span>)(nmod, nmod);;
<a name="l00768"></a>00768     T (*ATA)[nmod]=(T(*)[nmod])ata-&gt;p; 
<a name="l00769"></a>00769     T (*Ap)[nmod]=(T(*)[nmod])A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00770"></a>00770     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> imod=0; imod&lt;nmod; imod++){
<a name="l00771"></a>00771     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jmod=imod; jmod&lt;nmod; jmod++){
<a name="l00772"></a>00772         T tmp=0;
<a name="l00773"></a>00773         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;nsa2; k++){
<a name="l00774"></a>00774         tmp+=Ap[k][imod]*Ap[k][jmod]*wt-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[k];
<a name="l00775"></a>00775         }
<a name="l00776"></a>00776         ATA[imod][jmod]=tmp;
<a name="l00777"></a>00777         <span class="keywordflow">if</span>(imod!=jmod)
<a name="l00778"></a>00778         ATA[jmod][imod]=ATA[imod][jmod];
<a name="l00779"></a>00779     }
<a name="l00780"></a>00780     }
<a name="l00781"></a>00781     <span class="keywordflow">return</span> ata;
<a name="l00782"></a>00782 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cac32a8e663201109abf36bd322e9a46"></a><!-- doxytag: member="dmat.h::dpinv" ref="cac32a8e663201109abf36bd322e9a46" args="(const dmat *A, const dmat *wt, const dsp *Wsp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dpinv           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>Wsp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the pseudo inverse of matrix A with weigthing of full matrix W or sparse matrix weighting Wsp. 
<p>
For full matrix, wt can be either W or diag (W) for diagonal weighting. B=inv(A'*W*A)*A'*W; <div class="fragment"><pre class="fragment"><a name="l00788"></a>00788                                                                     {
<a name="l00789"></a>00789     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l00790"></a>00790     X(mat) *AtW=NULL;
<a name="l00791"></a>00791     <span class="comment">//Compute AtW=A'*W</span>
<a name="l00792"></a>00792     <span class="keywordflow">if</span>(wt){
<a name="l00793"></a>00793     <span class="keywordflow">if</span>(Wsp){
<a name="l00794"></a>00794         error(<span class="stringliteral">"Both wt and Wsp are supplied. Not supported\n"</span>);
<a name="l00795"></a>00795     }
<a name="l00796"></a>00796     <span class="keywordflow">if</span>(wt-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==wt-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>){
<a name="l00797"></a>00797         X(mm)(&amp;AtW, A, wt, <span class="stringliteral">"tn"</span>, 1);
<a name="l00798"></a>00798     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(wt-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1){
<a name="l00799"></a>00799         AtW=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>,A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>);
<a name="l00800"></a>00800         PMAT(A,pA);
<a name="l00801"></a>00801         PMAT(AtW,pAtW);
<a name="l00802"></a>00802         T *w=wt-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00803"></a>00803         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l00804"></a>00804         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0;ix&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; ix++){
<a name="l00805"></a>00805             pAtW[ix][iy]=pA[iy][ix]*w[ix];
<a name="l00806"></a>00806         }
<a name="l00807"></a>00807         }
<a name="l00808"></a>00808     }<span class="keywordflow">else</span>{
<a name="l00809"></a>00809         error(<span class="stringliteral">"Invalid format\n"</span>);
<a name="l00810"></a>00810     }
<a name="l00811"></a>00811     }<span class="keywordflow">else</span>{
<a name="l00812"></a>00812     <span class="keywordflow">if</span>(Wsp){
<a name="l00813"></a>00813         X(mat)*At = X(trans)(A);
<a name="l00814"></a>00814         X(mulsp)(&amp;AtW, At, Wsp, 1);
<a name="l00815"></a>00815         X(free)(At);
<a name="l00816"></a>00816     }<span class="keywordflow">else</span>{
<a name="l00817"></a>00817         AtW=X(trans)(A);
<a name="l00818"></a>00818     }
<a name="l00819"></a>00819     }
<a name="l00820"></a>00820     <span class="comment">//Compute cc=A'*W*A</span>
<a name="l00821"></a>00821     X(mat) *cc=NULL;
<a name="l00822"></a>00822     X(mm) (&amp;cc, AtW, A, <span class="stringliteral">"nn"</span>, 1);
<a name="l00823"></a>00823     <span class="comment">//Compute inv of cc</span>
<a name="l00824"></a>00824     <span class="comment">//X(invspd_inplace)(cc);</span>
<a name="l00825"></a>00825     X(svd_pow)(cc,-1);<span class="comment">//invert the matrix using SVD. safe with small eigen values.</span>
<a name="l00826"></a>00826     X(mat) *out=NULL;
<a name="l00827"></a>00827     <span class="comment">//Compute (A'*W*A)*A'*W</span>
<a name="l00828"></a>00828     X(mm) (&amp;out, cc, AtW, <span class="stringliteral">"nn"</span>, 1);
<a name="l00829"></a>00829     X(free)(AtW);
<a name="l00830"></a>00830     X(free)(cc);
<a name="l00831"></a>00831     <span class="keywordflow">return</span> out;
<a name="l00832"></a>00832 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a91e97f6979658a32b79a70b748b4810"></a><!-- doxytag: member="dmat.h::ddiff" ref="a91e97f6979658a32b79a70b748b4810" args="(const dmat *A, const dmat *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ddiff           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the relative difference betwee two vectors. 
<p>
||A-B||/||A|| using norm2. for debugging purpose. <div class="fragment"><pre class="fragment"><a name="l00838"></a>00838                                            {
<a name="l00839"></a>00839     X(mat) *C=NULL;
<a name="l00840"></a>00840     X(cp)(&amp;C,A);
<a name="l00841"></a>00841     X(<span class="keyword">add</span>)(&amp;C,1,B,-1);
<a name="l00842"></a>00842     T d=X(norm2)(C)*2/(X(norm2)(C)+X(norm2)(B));
<a name="l00843"></a>00843     <span class="keywordflow">return</span> isnan(d)?0:d;
<a name="l00844"></a>00844 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4529479ba036e3aae3b1827f161a7f9b"></a><!-- doxytag: member="dmat.h::dcircle" ref="4529479ba036e3aae3b1827f161a7f9b" args="(dmat *A, double cx, double cy, double r, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcircle           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
a new gray pixel map generation based on bilinear influence functions used in mkw. 
<p>
creates slightly larger map. add an filled circle. cx,cy,r are in unit of pixels <div class="fragment"><pre class="fragment"><a name="l00851"></a>00851                                                                 {
<a name="l00852"></a>00852     <span class="keywordtype">int</span> nres=100;
<a name="l00853"></a>00853     <span class="keyword">const</span> <span class="keywordtype">double</span> res=1./(double)(nres);
<a name="l00854"></a>00854     <span class="keyword">const</span> <span class="keywordtype">double</span> res1=1./(double)(nres);
<a name="l00855"></a>00855     <span class="keyword">const</span> <span class="keywordtype">double</span> res2=res1*res1*4.;
<a name="l00856"></a>00856     <span class="keywordtype">double</span> resm=(double)(nres-1)/2.;
<a name="l00857"></a>00857     <span class="keywordtype">double</span> r2=r*r;
<a name="l00858"></a>00858     <span class="keywordtype">double</span> r2l=(r-1.5)*(r-1.5);
<a name="l00859"></a>00859     <span class="keywordtype">double</span> r2u=(r+2.5)*(r+2.5);
<a name="l00860"></a>00860     PMAT(A,As);
<a name="l00861"></a>00861     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l00862"></a>00862     <span class="keywordtype">double</span> r2y=(iy-cy)*(iy-cy);
<a name="l00863"></a>00863     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; ix++){
<a name="l00864"></a>00864         <span class="keywordtype">double</span> r2r=(ix-cx)*(ix-cx)+r2y;
<a name="l00865"></a>00865         <span class="keywordflow">if</span>(r2r&lt;r2l) 
<a name="l00866"></a>00866             As[iy][ix]+=val;
<a name="l00867"></a>00867         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(r2r&lt;r2u){
<a name="l00868"></a>00868         <span class="keywordtype">double</span> tot=0.;
<a name="l00869"></a>00869         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jy=0; jy&lt;nres; jy++){
<a name="l00870"></a>00870             <span class="keywordtype">double</span> iiy=iy+(jy-resm)*2*res;
<a name="l00871"></a>00871             <span class="keywordtype">double</span> rr2y=(iiy-cy)*(iiy-cy);
<a name="l00872"></a>00872             <span class="keywordtype">double</span> wty=1.-fabs(iy-iiy);
<a name="l00873"></a>00873             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jx=0; jx&lt;nres; jx++){
<a name="l00874"></a>00874             <span class="keywordtype">double</span> iix=ix+(jx-resm)*2*res;
<a name="l00875"></a>00875             <span class="keywordtype">double</span> rr2r=(iix-cx)*(iix-cx)+rr2y;
<a name="l00876"></a>00876             <span class="keywordtype">double</span> wtx=1.-fabs(ix-iix);
<a name="l00877"></a>00877             <span class="keywordflow">if</span>(rr2r&lt;r2)
<a name="l00878"></a>00878                 tot+=res2*wty*wtx;
<a name="l00879"></a>00879             }
<a name="l00880"></a>00880         }
<a name="l00881"></a>00881         As[iy][ix]+=tot*val;
<a name="l00882"></a>00882         }
<a name="l00883"></a>00883     }
<a name="l00884"></a>00884     }
<a name="l00885"></a>00885 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bb7ee19f9a9bd8c7d4f3fc680a202601"></a><!-- doxytag: member="dmat.h::dcircle_symbolic" ref="bb7ee19f9a9bd8c7d4f3fc680a202601" args="(dmat *A, double cx, double cy, double r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcircle_symbolic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
similar to X(circle). 
<p>
but don't actually compute the weights. just test the corners; <div class="fragment"><pre class="fragment"><a name="l00891"></a>00891                                                                   {
<a name="l00892"></a>00892     <span class="keywordtype">double</span> r2=r*r;
<a name="l00893"></a>00893     <span class="keywordtype">double</span> r2u=(r+2.5)*(r+2.5);
<a name="l00894"></a>00894     double (*As)[A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>]=(double(*)[A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>])A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00895"></a>00895     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;ny; iy++){
<a name="l00896"></a>00896     <span class="keywordtype">double</span> r2y=(iy-cy)*(iy-cy);
<a name="l00897"></a>00897     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; ix++){
<a name="l00898"></a>00898         <span class="keywordtype">double</span> r2r=(ix-cx)*(ix-cx)+r2y;
<a name="l00899"></a>00899         <span class="keywordflow">if</span>(r2r&lt;r2) 
<a name="l00900"></a>00900             As[iy][ix]=1;
<a name="l00901"></a>00901         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(r2r&lt;r2u){
<a name="l00902"></a>00902         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jy=-1; jy&lt;2; jy++){
<a name="l00903"></a>00903             <span class="keywordtype">double</span> iiy=iy+jy;
<a name="l00904"></a>00904             <span class="keywordtype">double</span> rr2y=(iiy-cy)*(iiy-cy);
<a name="l00905"></a>00905             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jx=-1; jx&lt;2; jx++){
<a name="l00906"></a>00906             <span class="keywordtype">double</span> iix=ix+jx;
<a name="l00907"></a>00907             <span class="keywordtype">double</span> rr2r=pow(iix-cx,2)+rr2y;
<a name="l00908"></a>00908             <span class="keywordflow">if</span>(rr2r&lt;r2){
<a name="l00909"></a>00909                 As[iy][ix]=1;
<a name="l00910"></a>00910                 <span class="keywordflow">goto</span> next;
<a name="l00911"></a>00911             }
<a name="l00912"></a>00912             }
<a name="l00913"></a>00913         }
<a name="l00914"></a>00914         }
<a name="l00915"></a>00915     next:
<a name="l00916"></a>00916         <span class="keywordflow">continue</span>;
<a name="l00917"></a>00917     }
<a name="l00918"></a>00918     }
<a name="l00919"></a>00919 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9d9ed91255390f1e4649fc623dfa17ce"></a><!-- doxytag: member="dmat.h::dfftshift" ref="9d9ed91255390f1e4649fc623dfa17ce" args="(dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dfftshift           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
shift frequency components by n/2 
<p>
<div class="fragment"><pre class="fragment"><a name="l00924"></a>00924                            {
<a name="l00925"></a>00925     <span class="keywordtype">size_t</span> i;
<a name="l00926"></a>00926     <span class="keyword">const</span> <span class="keywordtype">size_t</span> nx=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l00927"></a>00927     <span class="keyword">const</span> <span class="keywordtype">size_t</span> ny=A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l00928"></a>00928     assert ((nx&amp;1)==0);
<a name="l00929"></a>00929     <span class="keyword">const</span> <span class="keywordtype">size_t</span> nx2=nx/2;
<a name="l00930"></a>00930     <span class="keyword">const</span> <span class="keywordtype">size_t</span> ny2=ny/2;
<a name="l00931"></a>00931     <span class="keyword">const</span> <span class="keywordtype">size_t</span> nx2d=nx2*<span class="keyword">sizeof</span>(T);
<a name="l00932"></a>00932     T *tmp=(T*)malloc(nx2d);
<a name="l00933"></a>00933     T *data=A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00934"></a>00934     <span class="keywordflow">if</span>(ny==1){
<a name="l00935"></a>00935     memcpy(tmp,data,nx2d);
<a name="l00936"></a>00936     memcpy(data,data+nx2,nx2d);
<a name="l00937"></a>00937     memcpy(data+nx2,tmp,nx2d);
<a name="l00938"></a>00938     }<span class="keywordflow">else</span>{
<a name="l00939"></a>00939     assert((ny&amp;1)==0);
<a name="l00940"></a>00940     <span class="keywordflow">for</span>(i=0; i&lt;ny2; i++){
<a name="l00941"></a>00941         memcpy(tmp,data+i*nx,nx2d);
<a name="l00942"></a>00942         memcpy(data+i*nx,data+(i+ny2)*nx+nx2, nx2d);
<a name="l00943"></a>00943         memcpy(data+(i+ny2)*nx+nx2,tmp, nx2d);
<a name="l00944"></a>00944         memcpy(tmp,data+i*nx+nx2,nx2d);
<a name="l00945"></a>00945         memcpy(data+i*nx+nx2,data+(i+ny2)*nx, nx2d); 
<a name="l00946"></a>00946         memcpy(data+(i+ny2)*nx,tmp, nx2d);
<a name="l00947"></a>00947     }
<a name="l00948"></a>00948     }
<a name="l00949"></a>00949     
<a name="l00950"></a>00950     free(tmp);
<a name="l00951"></a>00951 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9f252bb4fd703109c58f8c330d6f11df"></a><!-- doxytag: member="dmat.h::dcpcorner2center" ref="9f252bb4fd703109c58f8c330d6f11df" args="(dmat *A, const dmat *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcpcorner2center           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reorder B and embed/crop into center of A 
<p>
<div class="fragment"><pre class="fragment">
   4 * * 3
   * * * *
   * * * *
   2 * * 1
   </pre></div> to <div class="fragment"><pre class="fragment">
   1 2 
   3 4
   </pre></div> <div class="fragment"><pre class="fragment"><a name="l00968"></a>00968                                                   {
<a name="l00969"></a>00969     <span class="keyword">const</span> <span class="keywordtype">size_t</span> nx=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l00970"></a>00970     <span class="keyword">const</span> <span class="keywordtype">size_t</span> ny=A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l00971"></a>00971     T *Ap=A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00972"></a>00972     memset(Ap, 0, <span class="keyword">sizeof</span>(T)*nx*ny);
<a name="l00973"></a>00973     <span class="keyword">const</span> <span class="keywordtype">size_t</span> ninx=B-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l00974"></a>00974     <span class="keyword">const</span> <span class="keywordtype">size_t</span> niny=B-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l00975"></a>00975     <span class="keyword">const</span> T * Bp=B-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00976"></a>00976     assert((nx&amp;1)==0 &amp;&amp; (ny&amp;1)==0 &amp;&amp; (ninx&amp;1)==0 &amp;&amp; (niny&amp;1)==0);
<a name="l00977"></a>00977 
<a name="l00978"></a>00978     <span class="keyword">const</span> <span class="keywordtype">int</span> ny2=(ny&lt;niny)?ny/2:niny/2;
<a name="l00979"></a>00979     <span class="keyword">const</span> <span class="keywordtype">int</span> nx2=(nx&lt;ninx)?nx/2:ninx/2;
<a name="l00980"></a>00980     <span class="keyword">const</span> <span class="keywordtype">int</span> xskip=nx/2-nx2;
<a name="l00981"></a>00981     <span class="keyword">const</span> <span class="keywordtype">int</span> yskip=ny/2-ny2;
<a name="l00982"></a>00982     T* Ap0=Ap+yskip*nx+xskip;
<a name="l00983"></a>00983     <span class="keyword">const</span> <span class="keywordtype">int</span> nx2d=nx2*<span class="keyword">sizeof</span>(T);
<a name="l00984"></a>00984     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;ny2; i++){
<a name="l00985"></a>00985     memcpy(Ap0+i*nx, Bp+(niny-ny2+i)*ninx+(ninx-nx2),nx2d); 
<a name="l00986"></a>00986     memcpy(Ap0+i*nx+nx2, Bp+(niny-ny2+i)*ninx, nx2d); 
<a name="l00987"></a>00987     memcpy(Ap0+(i+ny2)*nx, Bp+i*ninx+(ninx-nx2), nx2d); 
<a name="l00988"></a>00988     memcpy(Ap0+(i+ny2)*nx+nx2, Bp+i*ninx, nx2d); 
<a name="l00989"></a>00989     }
<a name="l00990"></a>00990 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="05330b7f5be190a6567ee775e73464c9"></a><!-- doxytag: member="dmat.h::dshift" ref="05330b7f5be190a6567ee775e73464c9" args="(dmat **B0, const dmat *A, int sx, int sy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dshift           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
cyclic shift A by nx and ny to B. 
<p>
<div class="fragment"><pre class="fragment">
   4   3     1   2 
      
   2   1 to  3   4
   </pre></div> <div class="fragment"><pre class="fragment"><a name="l01000"></a>01000                                                            {
<a name="l01001"></a>01001     <span class="keywordflow">if</span>(!*B0){
<a name="l01002"></a>01002     *B0=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l01003"></a>01003     }
<a name="l01004"></a>01004     X(mat) *B=*B0;
<a name="l01005"></a>01005 
<a name="l01006"></a>01006     <span class="keyword">const</span> <span class="keywordtype">int</span> nx=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; 
<a name="l01007"></a>01007     <span class="keyword">const</span> <span class="keywordtype">int</span> ny=A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l01008"></a>01008     sx=sx%nx; <span class="keywordflow">if</span>(sx&lt;0) sx+=nx;
<a name="l01009"></a>01009     sy=sy%ny; <span class="keywordflow">if</span>(sy&lt;0) sy+=ny;
<a name="l01010"></a>01010     <span class="keywordflow">if</span>(sx!=0 || sy!=0){
<a name="l01011"></a>01011     <span class="keywordtype">int</span> dy=ny-sy;
<a name="l01012"></a>01012     <span class="keywordtype">int</span> dx=nx-sx;
<a name="l01013"></a>01013     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;sy; iy++){
<a name="l01014"></a>01014         memcpy(B-&gt;p+iy*nx, A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>+(dy+iy)*nx+dx, sx*<span class="keyword">sizeof</span>(T));<span class="comment">//3</span>
<a name="l01015"></a>01015         memcpy(B-&gt;p+iy*nx+sx, A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>+(dy+iy)*nx, dx*<span class="keyword">sizeof</span>(T));<span class="comment">//4</span>
<a name="l01016"></a>01016     }
<a name="l01017"></a>01017     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=sy; iy&lt;ny; iy++){
<a name="l01018"></a>01018         memcpy(B-&gt;p+iy*nx, A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>+(iy-sy)*nx+dx, sx*<span class="keyword">sizeof</span>(T));<span class="comment">//1</span>
<a name="l01019"></a>01019         memcpy(B-&gt;p+iy*nx+sx, A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>+(iy-sy)*nx, dx*<span class="keyword">sizeof</span>(T));<span class="comment">//2</span>
<a name="l01020"></a>01020     }
<a name="l01021"></a>01021     }<span class="keywordflow">else</span>{
<a name="l01022"></a>01022     memcpy(B-&gt;p, A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>, <span class="keyword">sizeof</span>(T)*nx*ny);
<a name="l01023"></a>01023     }
<a name="l01024"></a>01024 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="58ed65327dde1b0410fa992eda632d3b"></a><!-- doxytag: member="dmat.h::drotvec" ref="58ed65327dde1b0410fa992eda632d3b" args="(dmat *A, const double theta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drotvec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>theta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
rotate the vectors CCW. 
<p>
same as rotate coordinate theta CW. A(:,1) is x, A(:,2) is y. <div class="fragment"><pre class="fragment"><a name="l01031"></a>01031                                              {
<a name="l01032"></a>01032     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>!=2) error(<span class="stringliteral">"Wrong dimension\n"</span>);
<a name="l01033"></a>01033     <span class="keyword">const</span> <span class="keywordtype">double</span> ctheta=cos(theta);
<a name="l01034"></a>01034     <span class="keyword">const</span> <span class="keywordtype">double</span> stheta=sin(theta);
<a name="l01035"></a>01035     T (*Ap)[A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>]=(<span class="keywordtype">void</span>*)A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l01036"></a>01036     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;nx; i++){
<a name="l01037"></a>01037     T tmp=Ap[0][i]*ctheta-Ap[1][i]*stheta;
<a name="l01038"></a>01038     Ap[1][i]=Ap[0][i]*stheta+Ap[1][i]*ctheta;
<a name="l01039"></a>01039     Ap[0][i]=tmp;
<a name="l01040"></a>01040     }
<a name="l01041"></a>01041 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b4e3ddd0d5e6249c6d90c26991d8028c"></a><!-- doxytag: member="dmat.h::drotvecnn" ref="b4e3ddd0d5e6249c6d90c26991d8028c" args="(dmat **B0, const dmat *A, double theta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drotvecnn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>theta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
rotate a 2x2 covariance matrix A by theta CCW (coordinate rotate -theta CCW) or from ra to xy coordinate. 
<p>
R*A*R'; <div class="fragment"><pre class="fragment"><a name="l01048"></a>01048                                                             {
<a name="l01049"></a>01049     assert(A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>==2 &amp;&amp; A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==2);
<a name="l01050"></a>01050     <span class="keywordflow">if</span>(!*B0) 
<a name="l01051"></a>01051     *B0=X(<span class="keyword">new</span>)(2,2);
<a name="l01052"></a>01052     X(mat) *B=*B0;
<a name="l01053"></a>01053     assert(B-&gt;nx==2 &amp;&amp; B-&gt;ny==2);
<a name="l01054"></a>01054     <span class="keyword">const</span> T ctheta=cos(theta);
<a name="l01055"></a>01055     <span class="keyword">const</span> T stheta=sin(theta);
<a name="l01056"></a>01056     T tmp[2][2];
<a name="l01057"></a>01057     <span class="keyword">const</span> T (*Ap)[2]=(<span class="keyword">const</span> T (*)[2])A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l01058"></a>01058     T (*Bp)[2]=(T (*)[2])B-&gt;p;
<a name="l01059"></a>01059     <span class="comment">//first apply left R</span>
<a name="l01060"></a>01060     tmp[0][0]=ctheta*Ap[0][0]-stheta*Ap[0][1];
<a name="l01061"></a>01061     tmp[1][0]=ctheta*Ap[1][0]-stheta*Ap[1][1];
<a name="l01062"></a>01062     tmp[0][1]=stheta*Ap[0][0]+ctheta*Ap[0][1];
<a name="l01063"></a>01063     tmp[1][1]=stheta*Ap[1][0]+ctheta*Ap[1][1];
<a name="l01064"></a>01064     <span class="comment">//then apply right R'</span>
<a name="l01065"></a>01065     
<a name="l01066"></a>01066     Bp[0][0]=ctheta*tmp[0][0]-stheta*tmp[1][0];
<a name="l01067"></a>01067     Bp[1][0]=stheta*tmp[0][0]+ctheta*tmp[1][0];
<a name="l01068"></a>01068     Bp[0][1]=ctheta*tmp[0][1]-stheta*tmp[1][1];
<a name="l01069"></a>01069     Bp[1][1]=stheta*tmp[0][1]+ctheta*tmp[1][1];
<a name="l01070"></a>01070 
<a name="l01071"></a>01071 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e6580138c809e940eb9105b2b3791292"></a><!-- doxytag: member="dmat.h::dmulvec3" ref="e6580138c809e940eb9105b2b3791292" args="(double *y, const dmat *A, const double *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dmulvec3           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
T matrix vector multiply optimized for just three values. 
<p>
y=A*x; <div class="fragment"><pre class="fragment"><a name="l01077"></a>01077                                                   {
<a name="l01078"></a>01078     assert(A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>==3 &amp;&amp; A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==3);
<a name="l01079"></a>01079     T(*Ap)[3]=(T(*)[3])A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l01080"></a>01080     <span class="comment">//calculate y=A*x for 3.</span>
<a name="l01081"></a>01081     y[0]=Ap[0][0]*x[0]+Ap[1][0]*x[1]+Ap[2][0]*x[2];
<a name="l01082"></a>01082     y[1]=Ap[0][1]*x[0]+Ap[1][1]*x[1]+Ap[2][1]*x[2];
<a name="l01083"></a>01083     y[2]=Ap[0][2]*x[0]+Ap[1][2]*x[1]+Ap[2][2]*x[2];
<a name="l01084"></a>01084 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6531cfb8534d620420fbdf1deffb227c"></a><!-- doxytag: member="dmat.h::dcog" ref="6531cfb8534d620420fbdf1deffb227c" args="(double *grad, const dmat *i0, double offsetx, double offsety, double thres, double bkgrnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcog           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsetx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsety</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>thres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>bkgrnd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute thresholded center of gravity. 
<p>
The threshold is absolute value. bkgrnd is removed from i0 when computing cog. offset is the offset of the reference point (cog=0) from the physical center. all length are given in terms of pixel. <div class="fragment"><pre class="fragment"><a name="l01095"></a>01095                                                     {
<a name="l01096"></a>01096     <span class="keywordtype">double</span> sum=0,sumx=0,sumy=0;
<a name="l01097"></a>01097     <span class="keywordtype">double</span> iI;
<a name="l01098"></a>01098     PMAT(i0,pi0);
<a name="l01099"></a>01099     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;i0-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l01100"></a>01100     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;i0-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; ix++){
<a name="l01101"></a>01101         iI=REAL(pi0[iy][ix])-bkgrnd;
<a name="l01102"></a>01102         <span class="keywordflow">if</span>(iI&gt;thres){
<a name="l01103"></a>01103         sum+=iI;
<a name="l01104"></a>01104         sumx+=iI*ix;
<a name="l01105"></a>01105         sumy+=iI*iy;
<a name="l01106"></a>01106         }
<a name="l01107"></a>01107     }
<a name="l01108"></a>01108     }
<a name="l01109"></a>01109     <span class="keywordflow">if</span>(fabs(sum)&gt;0){
<a name="l01110"></a>01110     grad[0]=sumx/sum-((double)(i0-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>-1)*0.5+offsetx);
<a name="l01111"></a>01111     grad[1]=sumy/sum-((double)(i0-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>-1)*0.5+offsety);
<a name="l01112"></a>01112     }<span class="keywordflow">else</span>{
<a name="l01113"></a>01113     grad[0]=0;
<a name="l01114"></a>01114     grad[1]=0;
<a name="l01115"></a>01115     }
<a name="l01116"></a>01116 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="96ba5af3d8d18bfdf35cbbb3a49abd0c"></a><!-- doxytag: member="dmat.h::dshift2center" ref="96ba5af3d8d18bfdf35cbbb3a49abd0c" args="(dmat *A, double offsetx, double offsety)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dshift2center           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsetx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsety</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shift the image in A to center on physical center+[offsetx,offsety] using cog and fft. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01122"></a>01122                                                                {
<a name="l01123"></a>01123     <span class="keywordtype">double</span> grad[2];
<a name="l01124"></a>01124     <span class="keywordtype">double</span> Amax=X(max)(A);
<a name="l01125"></a>01125     X(cog)(grad,A,offsetx,offsety,Amax*0.1,Amax*0.2);
<a name="l01126"></a>01126     <span class="keywordflow">if</span>(fabs(grad[0])&gt;0.1 || fabs(grad[1])&gt;0.1){
<a name="l01127"></a>01127     <span class="comment">//info("Before shift, residual grad is %g %g\n",grad[0],grad[1]);</span>
<a name="l01128"></a>01128     <a class="code" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a> *B=<a class="code" href="cmat_8h.html#bb2b86ffc48237c760e652708aaf1415" title="Create a new T matrix object.">cnew</a>(A-&gt;nx,A-&gt;ny);
<a name="l01129"></a>01129     <a class="code" href="fft_8c.html#8b872386a7d070a175aa54dadcf2c68e" title="Create FFTW plans for 2d FFT transforms.">cfft2plan</a>(B,-1);
<a name="l01130"></a>01130     <a class="code" href="fft_8c.html#8b872386a7d070a175aa54dadcf2c68e" title="Create FFTW plans for 2d FFT transforms.">cfft2plan</a>(B,1);
<a name="l01131"></a>01131 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l01132"></a>01132 <span class="preprocessor"></span>    <a class="code" href="cmat_8h.html#db3c55ee96a9e7249403f738d251688c" title="copy the values from one X(mat) to another.">ccp</a>(&amp;B,A);
<a name="l01133"></a>01133 <span class="preprocessor">#else</span>
<a name="l01134"></a>01134 <span class="preprocessor"></span>    <a class="code" href="cmat__extra_8c.html#4ff6717c6a0f3919c71a2dc6fde5aae8" title="Copy a dmat into real part of cmat.">ccpd</a>(&amp;B,A);
<a name="l01135"></a>01135 <span class="preprocessor">#endif</span>
<a name="l01136"></a>01136 <span class="preprocessor"></span>    <span class="keywordtype">double</span> scale=1./(A-&gt;nx*A-&gt;ny);
<a name="l01137"></a>01137     <a class="code" href="cmat_8h.html#2e68e24dcc5d7ffd8d9b2c575e0830b9" title="shift frequency components by n/2">cfftshift</a>(B);
<a name="l01138"></a>01138     <a class="code" href="fft_8c.html#5e22d51b30da1c5c057cb5b8f121273d" title="Do 2d FFT transforms.">cfft2</a>(B,-1);
<a name="l01139"></a>01139     <a class="code" href="cmat__extra_8c.html#f912fcd3192a45180c528f075f1d0988" title="Tilt the otf to make the image shift.">ctilt</a>(B,-grad[0],-grad[1],0);
<a name="l01140"></a>01140     <a class="code" href="fft_8c.html#5e22d51b30da1c5c057cb5b8f121273d" title="Do 2d FFT transforms.">cfft2</a>(B,1);
<a name="l01141"></a>01141     <a class="code" href="cmat_8h.html#2e68e24dcc5d7ffd8d9b2c575e0830b9" title="shift frequency components by n/2">cfftshift</a>(B);
<a name="l01142"></a>01142     <a class="code" href="cmat_8h.html#204751357459432e00c5f5ee8d261f56" title="scale each element of A by w">cscale</a>(B,scale);
<a name="l01143"></a>01143 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l01144"></a>01144 <span class="preprocessor"></span>    <a class="code" href="cmat_8h.html#db3c55ee96a9e7249403f738d251688c" title="copy the values from one X(mat) to another.">ccp</a>(&amp;A,B);
<a name="l01145"></a>01145 <span class="preprocessor">#else</span>
<a name="l01146"></a>01146 <span class="preprocessor"></span>    <a class="code" href="cmat__extra_8c.html#b2baa26f7bd8861ab342eee97889522d" title="Copy real part of a cmat to dmat with optional scaling: A0=A0.">creal2d</a>(&amp;A,0,B,1);
<a name="l01147"></a>01147 <span class="preprocessor">#endif</span>
<a name="l01148"></a>01148 <span class="preprocessor"></span>    X(cog)(grad,A,offsetx,offsety,Amax*0.1,Amax*0.2);
<a name="l01149"></a>01149     <span class="comment">//info("After shift, residual grad is %g %g\n",grad[0],grad[1]);</span>
<a name="l01150"></a>01150     cfree(B);
<a name="l01151"></a>01151     }
<a name="l01152"></a>01152 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="30e08db08cab036374dc0635df4665d6"></a><!-- doxytag: member="dmat.h::dclip" ref="30e08db08cab036374dc0635df4665d6" args="(dmat *A, double min, double max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dclip           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Limit numbers in A to within [min, max]. 
<p>
used for DM clipping. <div class="fragment"><pre class="fragment"><a name="l01157"></a>01157                                               {
<a name="l01158"></a>01158     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> 0;
<a name="l01159"></a>01159     <span class="keywordflow">if</span>(isinf(min)==-1 &amp;&amp; isinf(max)==1) <span class="keywordflow">return</span> 0;
<a name="l01160"></a>01160     <span class="keywordflow">if</span>(max&lt;=min){
<a name="l01161"></a>01161     error(<span class="stringliteral">"upper light should be larger than lower limit\n"</span>);
<a name="l01162"></a>01162     }
<a name="l01163"></a>01163     T *restrict Ap=A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l01164"></a>01164     <span class="keywordtype">int</span> nclip=0;
<a name="l01165"></a>01165     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> *A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; i++){
<a name="l01166"></a>01166     <span class="keywordflow">if</span>(REAL(Ap[i])&gt;max) {
<a name="l01167"></a>01167         Ap[i]=max;
<a name="l01168"></a>01168         nclip++;
<a name="l01169"></a>01169     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(REAL(Ap[i])&lt;min) {
<a name="l01170"></a>01170         Ap[i]=min;
<a name="l01171"></a>01171         nclip++;
<a name="l01172"></a>01172     }
<a name="l01173"></a>01173     }
<a name="l01174"></a>01174     <span class="keywordflow">return</span> nclip;
<a name="l01175"></a>01175 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0131ec62b0a77d0df03e71b35f2d7b85"></a><!-- doxytag: member="dmat.h::dgramschmidt" ref="0131ec62b0a77d0df03e71b35f2d7b85" args="(dmat *Mod, double *amp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dgramschmidt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>amp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
OrthNormalize column vector in Mod, with weighting from vector amp. 
<p>
&lt;Mod|wt|Mod&gt; is equal to sum(wt). 2010-07-21: Bug found: The result is not orthonormal. cause: nonvalid is not initialized to 0. <div class="fragment"><pre class="fragment"><a name="l01182"></a>01182                                              {
<a name="l01183"></a>01183     <span class="keyword">const</span> <span class="keywordtype">int</span> nmod=Mod-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l01184"></a>01184     <span class="keyword">const</span> <span class="keywordtype">long</span> nx=Mod-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l01185"></a>01185     T wtsum=(T)nx;
<a name="l01186"></a>01186     <span class="keywordflow">if</span>(amp){
<a name="l01187"></a>01187     wtsum=<a class="code" href="mathmisc_8c.html#2e90f5760bd508b1e45e25ca9f2c39f4" title="Compute the sum of double vector.">dblsum</a>(amp, nx);
<a name="l01188"></a>01188     }
<a name="l01189"></a>01189     <span class="keywordtype">int</span> nonvalid[nmod];
<a name="l01190"></a>01190     memset(nonvalid, 0, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)*nmod);
<a name="l01191"></a>01191     PMAT(Mod,pMod);
<a name="l01192"></a>01192     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> imod=0; imod&lt;nmod; imod++){
<a name="l01193"></a>01193     <span class="keywordflow">if</span>(imod&gt;0){<span class="comment">//orthogonalize</span>
<a name="l01194"></a>01194         T cross;
<a name="l01195"></a>01195         <span class="comment">//compute dot product.</span>
<a name="l01196"></a>01196         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jmod=0; jmod&lt;imod; jmod++){
<a name="l01197"></a>01197         <span class="keywordflow">if</span>(nonvalid[jmod]) <span class="keywordflow">continue</span>;
<a name="l01198"></a>01198         cross=-dot_do(pMod[imod],pMod[jmod],amp,nx)/wtsum;
<a name="l01199"></a>01199         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;nx; ix++){
<a name="l01200"></a>01200             pMod[imod][ix]+=cross*pMod[jmod][ix];
<a name="l01201"></a>01201         }
<a name="l01202"></a>01202         }
<a name="l01203"></a>01203     }
<a name="l01204"></a>01204     
<a name="l01205"></a>01205     T norm=SQRT(dot_do(pMod[imod],pMod[imod],amp,nx)/wtsum);
<a name="l01206"></a>01206     <span class="keywordflow">if</span>(ABS(norm)&gt;1.e-15){
<a name="l01207"></a>01207         norm=1./norm;
<a name="l01208"></a>01208         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;nx; ix++){
<a name="l01209"></a>01209         pMod[imod][ix]*=norm;
<a name="l01210"></a>01210         }
<a name="l01211"></a>01211     }<span class="keywordflow">else</span>{
<a name="l01212"></a>01212         nonvalid[imod]=1;
<a name="l01213"></a>01213         warning(<span class="stringliteral">"Column %d is not independent on other columns\n"</span>,imod);
<a name="l01214"></a>01214     }
<a name="l01215"></a>01215     }
<a name="l01216"></a>01216 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dd22a26474e6e6af8df941a6b25b0f05"></a><!-- doxytag: member="dmat.h::dmuldiag" ref="dd22a26474e6e6af8df941a6b25b0f05" args="(dmat *A, dmat *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dmuldiag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A=A*B, where diag(B)=s. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01221"></a>01221                                      {
<a name="l01222"></a>01222     assert(A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==s-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> &amp;&amp; s-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1);
<a name="l01223"></a>01223     PMAT(A,pA);
<a name="l01224"></a>01224     <span class="keyword">const</span> T *ps=s-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l01225"></a>01225     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; iy++){
<a name="l01226"></a>01226     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; ix++){
<a name="l01227"></a>01227         pA[iy][ix]*=ps[iy];
<a name="l01228"></a>01228     }
<a name="l01229"></a>01229     }
<a name="l01230"></a>01230 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b6f63a9e507f7a58e4f1ba98d7bb3288"></a><!-- doxytag: member="dmat.h::dcwpow" ref="b6f63a9e507f7a58e4f1ba98d7bb3288" args="(dmat *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcwpow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Raise all elements to power power. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01235"></a>01235                                      {
<a name="l01236"></a>01236     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l01237"></a>01237     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; i++){
<a name="l01238"></a>01238     A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i]=Y(pow)(A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i],power);
<a name="l01239"></a>01239     }
<a name="l01240"></a>01240 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f6edae64ae92dc140f4a85679d6252ae"></a><!-- doxytag: member="dmat.h::dsvd" ref="f6edae64ae92dc140f4a85679d6252ae" args="(dmat **Sdiag, dmat **U, dmat **VT, const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dsvd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>Sdiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
SVD of a general matrix. 
<p>
A=U*diag(S)*V'; diag(S) is returned. <div class="fragment"><pre class="fragment"><a name="l01247"></a>01247                                                                    {
<a name="l01248"></a>01248     <span class="keywordtype">char</span> jobuv=<span class="charliteral">'S'</span>;
<a name="l01249"></a>01249     <span class="keywordtype">int</span> M=(int)A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l01250"></a>01250     <span class="keywordtype">int</span> N=(<span class="keywordtype">int</span>)A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l01251"></a>01251     <span class="keywordflow">if</span>((Sdiag&amp;&amp;*Sdiag)||(U&amp;&amp;*U)||(VT&amp;&amp;*VT)){
<a name="l01252"></a>01252     warning(<span class="stringliteral">"Sdiag,U,VT should all be NULL. discard their value\n"</span>);
<a name="l01253"></a>01253     }
<a name="l01254"></a>01254     X(mat) *tmp=X(dup)(A);
<a name="l01255"></a>01255     <span class="keywordtype">int</span> nsvd=M&lt;N?M:N;
<a name="l01256"></a>01256     <a class="code" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> *s=<a class="code" href="dmat_8h.html#0d7497e2dbb79adb228de6bdde4a201e" title="Create a new T matrix object.">dnew</a>(nsvd,1);
<a name="l01257"></a>01257     X(mat) *u=X(<span class="keyword">new</span>)(M,nsvd);
<a name="l01258"></a>01258     X(mat) *vt=X(<span class="keyword">new</span>)(nsvd,N);
<a name="l01259"></a>01259     <span class="keywordtype">int</span> lwork=-1;
<a name="l01260"></a>01260     T work0[1];
<a name="l01261"></a>01261     <span class="keywordtype">int</span> info=0;
<a name="l01262"></a>01262 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l01263"></a>01263 <span class="preprocessor"></span>    <span class="keywordtype">double</span> *rwork=malloc(nsvd*5*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l01264"></a>01264     Z(gesvd)(&amp;jobuv,&amp;jobuv,&amp;M,&amp;N,tmp-&gt;p,&amp;M,s-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>,u-&gt;p,&amp;M,vt-&gt;p,&amp;nsvd,work0,&amp;lwork,rwork,&amp;info);
<a name="l01265"></a>01265 <span class="preprocessor">#else</span>
<a name="l01266"></a>01266 <span class="preprocessor"></span>    Z(gesvd)(&amp;jobuv,&amp;jobuv,&amp;M,&amp;N,tmp-&gt;p,&amp;M,s-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>,u-&gt;p,&amp;M,vt-&gt;p,&amp;nsvd,work0,&amp;lwork,&amp;info);
<a name="l01267"></a>01267 <span class="preprocessor">#endif</span>
<a name="l01268"></a>01268 <span class="preprocessor"></span>    lwork=(int)(work0[0]);
<a name="l01269"></a>01269     T *work1=malloc(<span class="keyword">sizeof</span>(T)*lwork);
<a name="l01270"></a>01270 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l01271"></a>01271 <span class="preprocessor"></span>    Z(gesvd)(&amp;jobuv,&amp;jobuv,&amp;M,&amp;N,tmp-&gt;p,&amp;M,s-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>,u-&gt;p,&amp;M,vt-&gt;p,&amp;nsvd,work1,&amp;lwork,rwork,&amp;info);
<a name="l01272"></a>01272 <span class="preprocessor">#else</span>
<a name="l01273"></a>01273 <span class="preprocessor"></span>    Z(gesvd)(&amp;jobuv,&amp;jobuv,&amp;M,&amp;N,tmp-&gt;p,&amp;M,s-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>,u-&gt;p,&amp;M,vt-&gt;p,&amp;nsvd,work1,&amp;lwork,&amp;info);
<a name="l01274"></a>01274 <span class="preprocessor">#endif</span>
<a name="l01275"></a>01275 <span class="preprocessor"></span>    free(work1);
<a name="l01276"></a>01276     <span class="keywordflow">if</span>(info){
<a name="l01277"></a>01277     <span class="keywordflow">if</span>(info&lt;0){
<a name="l01278"></a>01278         error(<span class="stringliteral">"The %d-th argument has an illegal value\n"</span>,info);
<a name="l01279"></a>01279     }<span class="keywordflow">else</span>{
<a name="l01280"></a>01280         error(<span class="stringliteral">"svd: dbdsqr doesn't converge. info is %d\n"</span>,info);
<a name="l01281"></a>01281     }
<a name="l01282"></a>01282     }
<a name="l01283"></a>01283     <span class="keywordflow">if</span>(Sdiag) *Sdiag=s; <span class="keywordflow">else</span> dfree(s);
<a name="l01284"></a>01284     <span class="keywordflow">if</span>(U) *U=u; <span class="keywordflow">else</span> X(free)(u);
<a name="l01285"></a>01285     <span class="keywordflow">if</span>(VT) *VT=vt; <span class="keywordflow">else</span> X(free)(vt);
<a name="l01286"></a>01286     X(free)(tmp);
<a name="l01287"></a>01287 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l01288"></a>01288 <span class="preprocessor"></span>    free(rwork);
<a name="l01289"></a>01289 <span class="preprocessor">#endif</span>
<a name="l01290"></a>01290 <span class="preprocessor"></span>}
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0063f9a3cde12e2b0977ed7a485fbb2c"></a><!-- doxytag: member="dmat.h::dsvd_pow" ref="0063f9a3cde12e2b0977ed7a485fbb2c" args="(dmat *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dsvd_pow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
computes pow(A,power) using svd 
<p>
<div class="fragment"><pre class="fragment"><a name="l01295"></a>01295                                         {
<a name="l01296"></a>01296     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>!=A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>){
<a name="l01297"></a>01297     warning(<span class="stringliteral">"dsvd_pow is only good for square arrays.\n"</span>);
<a name="l01298"></a>01298     }
<a name="l01299"></a>01299     <a class="code" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> *Sdiag=NULL;
<a name="l01300"></a>01300     X(mat) *U=NULL;
<a name="l01301"></a>01301     X(mat) *VT=NULL;
<a name="l01302"></a>01302     
<a name="l01303"></a>01303     X(svd)(&amp;Sdiag, &amp;U, &amp;VT, A);
<a name="l01304"></a>01304     <span class="comment">//eigen values below the threshold will not be used. the first is always the biggest.</span>
<a name="l01305"></a>01305     <span class="keywordtype">double</span> thres=fabs(Sdiag-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[0])*EPS;
<a name="l01306"></a>01306     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;Sdiag-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; i++){
<a name="l01307"></a>01307     <span class="keywordflow">if</span>(fabs(Sdiag-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i])&gt;thres){<span class="comment">//only do with </span>
<a name="l01308"></a>01308         Sdiag-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i]=pow(Sdiag-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i],power);
<a name="l01309"></a>01309     }<span class="keywordflow">else</span>{
<a name="l01310"></a>01310         Sdiag-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i]=0;
<a name="l01311"></a>01311     }
<a name="l01312"></a>01312     }
<a name="l01313"></a>01313     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy &lt;VT-&gt;ny; iy++){
<a name="l01314"></a>01314     T *p=VT-&gt;p+iy*VT-&gt;nx;
<a name="l01315"></a>01315     <span class="keywordflow">for</span> (<span class="keywordtype">long</span> ix=0; ix&lt;VT-&gt;nx; ix++){
<a name="l01316"></a>01316         p[ix]*=Sdiag-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[ix];
<a name="l01317"></a>01317     }
<a name="l01318"></a>01318     }
<a name="l01319"></a>01319     X(zero)(A);
<a name="l01320"></a>01320     X(mm)(&amp;A,U,VT,<span class="stringliteral">"nn"</span>,1);
<a name="l01321"></a>01321     X(free)(U);
<a name="l01322"></a>01322     X(free)(VT);
<a name="l01323"></a>01323     dfree(Sdiag);
<a name="l01324"></a>01324 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="42490ea31b5b30b0b618f417c76bd712"></a><!-- doxytag: member="dmat.h::daddI" ref="42490ea31b5b30b0b618f417c76bd712" args="(dmat *A, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void daddI           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add val to diagonal values of A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01329"></a>01329                               {
<a name="l01330"></a>01330     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l01331"></a>01331     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>!=A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>)
<a name="l01332"></a>01332     warning(<span class="stringliteral">"daddI: A is not square\n"</span>);
<a name="l01333"></a>01333     <span class="keywordtype">long</span> M=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>&lt;A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>?A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>:A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l01334"></a>01334     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;M; i++){
<a name="l01335"></a>01335     A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i+i*A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>]+=val;
<a name="l01336"></a>01336     } 
<a name="l01337"></a>01337 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a23e8df5aa3152c6f01025e956958e9a"></a><!-- doxytag: member="dmat.h::dtikcr" ref="a23e8df5aa3152c6f01025e956958e9a" args="(dmat *A, double thres)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dtikcr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>thres</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply tikhonov regularization to A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01342"></a>01342                                  {
<a name="l01343"></a>01343     <a class="code" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> *S=NULL;
<a name="l01344"></a>01344     X(svd)(&amp;S,NULL,NULL,A);
<a name="l01345"></a>01345     T val=S-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[0]*thres;
<a name="l01346"></a>01346     dfree(S);
<a name="l01347"></a>01347     X(addI)(A,val);
<a name="l01348"></a>01348 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="13ed19366b0b57c73f7a0f37bd20dfb4"></a><!-- doxytag: member="dmat.h::dmulsp" ref="13ed19366b0b57c73f7a0f37bd20dfb4" args="(dmat **yout, const dmat *x, const dsp *A, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dmulsp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
y=y+alpha*OP(x)*OP(A); implemented by transposing x,y index in sptmulmat implementation TESTED OK. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01355"></a>01355                                                                            {
<a name="l01356"></a>01356     <span class="keywordflow">if</span>(A&amp;&amp;x){
<a name="l01357"></a>01357     <span class="keywordtype">long</span> icol, ix;
<a name="l01358"></a>01358     <span class="keywordflow">if</span>(!*yout){
<a name="l01359"></a>01359         *yout=X(<span class="keyword">new</span>)(x-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>);
<a name="l01360"></a>01360     }
<a name="l01361"></a>01361     X(mat) *y=*yout;
<a name="l01362"></a>01362     assert(x-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>==y-&gt;nx);
<a name="l01363"></a>01363     <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>==1){
<a name="l01364"></a>01364         Y(sptmulvec)(y-&gt;p, A, x-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>, alpha);
<a name="l01365"></a>01365     }<span class="keywordflow">else</span>{
<a name="l01366"></a>01366         <span class="keywordtype">int</span> jcol;
<a name="l01367"></a>01367         PMAT(y,Y); PMAT(x,X);
<a name="l01368"></a>01368         <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;1.e-100){
<a name="l01369"></a>01369         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l01370"></a>01370             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l01371"></a>01371             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;nx; jcol++){
<a name="l01372"></a>01372                 Y[icol][jcol]+=A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix]*X[A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]][jcol];
<a name="l01373"></a>01373             }
<a name="l01374"></a>01374             }
<a name="l01375"></a>01375         }
<a name="l01376"></a>01376         }<span class="keywordflow">else</span>{
<a name="l01377"></a>01377         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>; icol++){
<a name="l01378"></a>01378             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l01379"></a>01379             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;nx; jcol++){
<a name="l01380"></a>01380                 Y[icol][jcol]+=alpha*A-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a>[ix]*X[A-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[ix]][jcol];
<a name="l01381"></a>01381             }
<a name="l01382"></a>01382             }
<a name="l01383"></a>01383         }
<a name="l01384"></a>01384         }
<a name="l01385"></a>01385     }
<a name="l01386"></a>01386     }
<a name="l01387"></a>01387 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3d3dc034d88f0a526fe242b1c1d3b1e5"></a><!-- doxytag: member="dmat.h::dlogspace" ref="3d3dc034d88f0a526fe242b1c1d3b1e5" args="(double emin, double emax, long n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dlogspace           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create log spaced vector. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01392"></a>01392                                                      {
<a name="l01393"></a>01393     X(mat)* out=X(<span class="keyword">new</span>)(n,1);
<a name="l01394"></a>01394     <span class="keywordtype">double</span> esep=(emax-emin)/(n-1);
<a name="l01395"></a>01395     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;n; i++){
<a name="l01396"></a>01396     <span class="keywordtype">double</span> ex=emin+esep*i;
<a name="l01397"></a>01397     out-&gt;p[i]=pow(10, ex);
<a name="l01398"></a>01398     }
<a name="l01399"></a>01399     <span class="keywordflow">return</span> out;
<a name="l01400"></a>01400 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f066671d15c55648b99456c410529e33"></a><!-- doxytag: member="dmat.h::dlinspace" ref="f066671d15c55648b99456c410529e33" args="(double emin, double emax, long n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dlinspace           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create linearly spaced vector. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01405"></a>01405                                                    {
<a name="l01406"></a>01406     X(mat)* out=X(<span class="keyword">new</span>)(n,1);
<a name="l01407"></a>01407     <span class="keywordtype">double</span> sep=(max-min)/(n-1);
<a name="l01408"></a>01408     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;n; i++){
<a name="l01409"></a>01409     out-&gt;p[i]=min+sep*i;
<a name="l01410"></a>01410     }
<a name="l01411"></a>01411     <span class="keywordflow">return</span> out;
<a name="l01412"></a>01412 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="139bad85f7f26668a547d3bb581a199c"></a><!-- doxytag: member="dmat.h::dinterp1" ref="139bad85f7f26668a547d3bb581a199c" args="(dmat *xin, dmat *yin, dmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dinterp1           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>yin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpolate using linear interp. 
<p>
xin is the coordinate of yin. xnew is the coordinate of the output. <div class="fragment"><pre class="fragment"><a name="l01418"></a>01418                                                     {
<a name="l01419"></a>01419     <span class="keywordtype">long</span> nmax=xin-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l01420"></a>01420     <span class="keywordtype">long</span> nmax1=nmax-1;
<a name="l01421"></a>01421     <span class="keywordtype">double</span> xminl=(xin-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[0]);
<a name="l01422"></a>01422     <span class="keywordtype">double</span> xmaxl=(xin-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[nmax-1]);
<a name="l01423"></a>01423     <span class="keywordtype">double</span> xsep=(xmaxl-xminl)/(<span class="keywordtype">double</span>)(nmax1);
<a name="l01424"></a>01424     <span class="keywordtype">double</span> xsep1=1./xsep;
<a name="l01425"></a>01425     <span class="keywordflow">if</span>(fabs(xsep+xminl-xin-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[1])&gt;1.e-3){
<a name="l01426"></a>01426     error(<span class="stringliteral">"Xin is not linearly spaced\n"</span>);
<a name="l01427"></a>01427     }
<a name="l01428"></a>01428     <span class="keywordflow">if</span>(xin-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>!=1 || xnew-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>!=1){
<a name="l01429"></a>01429     error(<span class="stringliteral">"Either xin or xnew is in wrong format\n"</span>);
<a name="l01430"></a>01430     }
<a name="l01431"></a>01431 
<a name="l01432"></a>01432     X(mat) *ynew=X(<span class="keyword">new</span>)(xnew-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, xnew-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l01433"></a>01433     PMAT(yin, pyin);
<a name="l01434"></a>01434     PMAT(ynew, pynew);
<a name="l01435"></a>01435     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;ynew-&gt;ny; iy++){
<a name="l01436"></a>01436     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;ynew-&gt;nx; ix++){
<a name="l01437"></a>01437         <span class="keywordtype">double</span> xx=((xnew-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[ix])-xminl)*xsep1;
<a name="l01438"></a>01438         <span class="keywordflow">if</span>(xx&lt;0 || xx&gt;nmax1){
<a name="l01439"></a>01439         pynew[iy][ix]=0;
<a name="l01440"></a>01440         }<span class="keywordflow">else</span>{
<a name="l01441"></a>01441         <span class="keywordtype">long</span> xxm=ifloor(xx);
<a name="l01442"></a>01442         <span class="keywordtype">double</span> xxw=xx-xxm;
<a name="l01443"></a>01443         pynew[iy][ix]=xxw*pyin[iy][xxm+1]+(1.-xxw)*pyin[iy][xxm];
<a name="l01444"></a>01444         }
<a name="l01445"></a>01445     }
<a name="l01446"></a>01446     }
<a name="l01447"></a>01447     <span class="keywordflow">return</span> ynew;
<a name="l01448"></a>01448 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="50a81407616c0a439e8d95fdc66c28e1"></a><!-- doxytag: member="dmat.h::dinterp1log" ref="50a81407616c0a439e8d95fdc66c28e1" args="(dmat *xin, dmat *yin, dmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dinterp1log           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>yin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpolate using log(xin) and log(xnew) xin is the coordinate of yin. 
<p>
xnew is the coordinate of the output. <div class="fragment"><pre class="fragment"><a name="l01454"></a>01454                                                        {
<a name="l01455"></a>01455     <span class="keywordtype">long</span> nmax=xin-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l01456"></a>01456     <span class="keywordtype">long</span> nmax1=nmax-1;
<a name="l01457"></a>01457     <span class="keywordtype">double</span> xminl=log10(xin-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[0]);
<a name="l01458"></a>01458     <span class="keywordtype">double</span> xmaxl=log10(xin-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[nmax-1]);
<a name="l01459"></a>01459     <span class="keywordtype">double</span> xsep=(xmaxl-xminl)/(<span class="keywordtype">double</span>)(nmax1);
<a name="l01460"></a>01460     <span class="keywordtype">double</span> xsep1=1./xsep;
<a name="l01461"></a>01461     <span class="keywordflow">if</span>(fabs(xsep+xminl-log10(xin-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[1]))&gt;1.e-3){
<a name="l01462"></a>01462     info(<span class="stringliteral">"xsep=%g, nmax1=%ld, xminl=%g, xmaxl=%g\n"</span>,xsep, nmax1, xminl, xmaxl);
<a name="l01463"></a>01463     error(<span class="stringliteral">"Xin is not logrithmicly spaced\n"</span>);
<a name="l01464"></a>01464     }
<a name="l01465"></a>01465     <span class="keywordflow">if</span>(xin-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>!=1 || xnew-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>!=1){
<a name="l01466"></a>01466     error(<span class="stringliteral">"Either xin or xnew is in wrong format\n"</span>);
<a name="l01467"></a>01467     }
<a name="l01468"></a>01468 
<a name="l01469"></a>01469     X(mat) *ynew=X(<span class="keyword">new</span>)(xnew-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, xnew-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l01470"></a>01470     PMAT(yin, pyin);
<a name="l01471"></a>01471     PMAT(ynew, pynew);
<a name="l01472"></a>01472     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;ynew-&gt;ny; iy++){
<a name="l01473"></a>01473     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;ynew-&gt;nx; ix++){
<a name="l01474"></a>01474         <span class="keywordtype">double</span> xx=(log10(xnew-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[ix])-xminl)*xsep1;
<a name="l01475"></a>01475         <span class="keywordflow">if</span>(xx&lt;0 || xx&gt;nmax1){
<a name="l01476"></a>01476         pynew[iy][ix]=0;
<a name="l01477"></a>01477         }<span class="keywordflow">else</span>{
<a name="l01478"></a>01478         <span class="keywordtype">long</span> xxm=ifloor(xx);
<a name="l01479"></a>01479         <span class="keywordtype">double</span> xxw=xx-xxm;
<a name="l01480"></a>01480         pynew[iy][ix]=xxw*pyin[iy][xxm+1]+(1.-xxw)*pyin[iy][xxm];
<a name="l01481"></a>01481         }
<a name="l01482"></a>01482     }
<a name="l01483"></a>01483     }
<a name="l01484"></a>01484     <span class="keywordflow">return</span> ynew;
<a name="l01485"></a>01485 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="041003260afdf29166953042ddb51e53"></a><!-- doxytag: member="dmat.h::dhistfill" ref="041003260afdf29166953042ddb51e53" args="(dmat **out, const dmat *A, double center, double spacing, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dhistfill           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For each entry in A, call repeatly to collect its histogram, centered at center, spaced by spacing, for n bins in total. 
<p>
center if at bin n/2. <div class="fragment"><pre class="fragment"><a name="l01565"></a>01565                                               {
<a name="l01566"></a>01566     <span class="keywordflow">if</span>(!A || !A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>) <span class="keywordflow">return</span>;
<a name="l01567"></a>01567     <span class="keywordtype">int</span> nn=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l01568"></a>01568     <span class="keywordflow">if</span>(!*out){
<a name="l01569"></a>01569     *out=<a class="code" href="dmat_8h.html#0d7497e2dbb79adb228de6bdde4a201e" title="Create a new T matrix object.">dnew</a>(n,nn);
<a name="l01570"></a>01570     }
<a name="l01571"></a>01571     double (*restrict Op)[n]=(<span class="keywordtype">void</span>*)(*out)-&gt;p;
<a name="l01572"></a>01572     <span class="keyword">const</span> T *restrict Ap=A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l01573"></a>01573     <span class="keyword">const</span> <span class="keywordtype">double</span> spacingi=1./spacing;
<a name="l01574"></a>01574     <span class="keyword">const</span> <span class="keywordtype">int</span> noff=n/2;
<a name="l01575"></a>01575     <span class="keyword">const</span> <span class="keywordtype">int</span> n1=n-1;
<a name="l01576"></a>01576     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;nx*A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; i++){
<a name="l01577"></a>01577     <span class="keywordtype">int</span> ind=(int)round(REAL(Ap[i]-center)*spacingi)+noff;
<a name="l01578"></a>01578     <span class="keywordflow">if</span>(ind&lt;0) ind=0;
<a name="l01579"></a>01579     <span class="keywordflow">if</span>(ind&gt;n1) ind=n1;
<a name="l01580"></a>01580     Op[i][ind]++;
<a name="l01581"></a>01581     }
<a name="l01582"></a>01582 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c94bb7e7491459eba07f93115ee7d8a1"></a><!-- doxytag: member="dmat.h::dspline_prep" ref="c94bb7e7491459eba07f93115ee7d8a1" args="(dmat *x, dmat *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dspline_prep           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
1D Cubic spline interpolation preparation. 
<p>
if x has only 1 column: x is the coordinate. y is the function value. if x has two columns: first column is the coordinate, y is null.<p>
It is upto the user to make sure that the coordinate is increasingly ordered and evenly spaced .<p>
If the values of a function <img class="formulaInl" alt="$f(x)$" src="form_6.png"> and its derivative are know at x=0, and x=1 (normalized coordinate), then the function can be interpolated on the interval [0,1] using a third degree polynomial. This is called cubic interpolation. The formula of this polynomial can be easily derived.<p>
A third degree polynomial and its derivative: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x)=ax^3+bx^2+cx+d \]" src="form_7.png">
<p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x)=3ax^3+2bx+c \]" src="form_8.png">
<p>
 The coefficients can be derived from the value and derivatives: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} a&amp;=&amp;2f(0)-2f(1)+f^\prime (0)+f^\prime(1)\\ b&amp;=&amp;-3f(0)+3f(1)-2f^\prime(0)-f^\prime(0)\\ c&amp;=&amp;f^\prime(0)\\ d&amp;=&amp;f(0)\\ \end{eqnarray*}" src="form_9.png">
<p>
 the derivatives can be computed as <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} f^\prime(0)&amp;=&amp;\frac{f(1)-f(-1)}{2}\\ f^\prime(1)&amp;=&amp;\frac{f(2)-f(0)}{2}\\ \end{eqnarray*}" src="form_10.png">
<p>
 so we have the formula <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} a&amp;=&amp;-0.5 f(-1) + 1.5 f(0) - 1.5 f(1) + 0.5 f(2)\\ b&amp;=&amp; f(-1) - 2.5 f(0) + 2 f(1) - 0.5 f(2)\\ c&amp;=&amp;-0.5 f(-1) + 0.5 f(1) \\ d&amp;=&amp; f(0) \\ \end{eqnarray*}" src="form_11.png">
<p>
<p>
for the boundary pints, replace <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(-1))/2\]" src="form_12.png">
<p>
 by <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(0))\]" src="form_13.png">
<p>
 Otehr type of boundaries are handled in the same way.<p>
see <a href="http://www.paulinternet.nl/?page=bicubicx">http://www.paulinternet.nl/?page=bicubicx</a> <div class="fragment"><pre class="fragment"><a name="l01630"></a>01630                                             {
<a name="l01631"></a>01631     T *px,*py;
<a name="l01632"></a>01632     <span class="keyword">const</span> <span class="keywordtype">long</span> nx=x-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l01633"></a>01633     px=x-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l01634"></a>01634     <span class="keywordflow">switch</span>(x-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>){
<a name="l01635"></a>01635     <span class="keywordflow">case</span> 1:
<a name="l01636"></a>01636     py=y-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l01637"></a>01637     <span class="keywordflow">break</span>;
<a name="l01638"></a>01638     <span class="keywordflow">case</span> 2:
<a name="l01639"></a>01639     assert(y==NULL);
<a name="l01640"></a>01640     py=x-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>+nx;
<a name="l01641"></a>01641     <span class="keywordflow">break</span>;
<a name="l01642"></a>01642     <span class="keywordflow">default</span>:
<a name="l01643"></a>01643     py=NULL;
<a name="l01644"></a>01644     error(<span class="stringliteral">"Invalid input\n"</span>);
<a name="l01645"></a>01645     }
<a name="l01646"></a>01646     X(mat) *coeff=X(<span class="keyword">new</span>)(4,nx);
<a name="l01647"></a>01647     T xsep=(px[nx-1]-px[0])/(nx-1);
<a name="l01648"></a>01648     <span class="keywordtype">double</span> thres=ABS(xsep)*1.e-5;
<a name="l01649"></a>01649   
<a name="l01650"></a>01650     PMAT(coeff,pc);
<a name="l01651"></a>01651     T ypriv,ynext;
<a name="l01652"></a>01652     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;nx-1; ix++){
<a name="l01653"></a>01653     <span class="keywordflow">if</span>(ABS(px[ix+1]-px[ix]-xsep)&gt;thres){
<a name="l01654"></a>01654         error(<span class="stringliteral">"The coordinate is not evenly spaced\n"</span>);
<a name="l01655"></a>01655     }
<a name="l01656"></a>01656     <span class="keywordflow">if</span>(UNLIKELY(ix==0)){
<a name="l01657"></a>01657         ypriv=2*py[ix]-py[ix+1];
<a name="l01658"></a>01658     }<span class="keywordflow">else</span>{
<a name="l01659"></a>01659         ypriv=py[ix-1];
<a name="l01660"></a>01660     }
<a name="l01661"></a>01661     <span class="keywordflow">if</span>(UNLIKELY(ix==nx-2)){
<a name="l01662"></a>01662         ynext=2*py[ix+1]-py[ix];
<a name="l01663"></a>01663     }<span class="keywordflow">else</span>{
<a name="l01664"></a>01664         ynext=py[ix+2];
<a name="l01665"></a>01665     }
<a name="l01666"></a>01666     pc[ix][0]=-0.5*ypriv+1.5*py[ix]-1.5*py[ix+1]+0.5*ynext;<span class="comment">//a</span>
<a name="l01667"></a>01667     pc[ix][1]=     ypriv-2.5*py[ix]+2.0*py[ix+1]-0.5*ynext;<span class="comment">//b</span>
<a name="l01668"></a>01668     pc[ix][2]=-0.5*ypriv           +0.5*py[ix+1];<span class="comment">//c</span>
<a name="l01669"></a>01669     pc[ix][3]=               py[ix] ;<span class="comment">//d</span>
<a name="l01670"></a>01670     <span class="comment">/*</span>
<a name="l01671"></a>01671 <span class="comment">      For any point within this bin, with normalized coordinate t (0&lt;t&lt;1);</span>
<a name="l01672"></a>01672 <span class="comment">      y(t)=a*pow(t,3)+b*pow(t,2)+c*t+d;</span>
<a name="l01673"></a>01673 <span class="comment">    */</span>
<a name="l01674"></a>01674     }
<a name="l01675"></a>01675     <span class="keywordflow">return</span> coeff;
<a name="l01676"></a>01676 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d6c71f329b21ee28435a06fd64e828c8"></a><!-- doxytag: member="dmat.h::dspline_eval" ref="d6c71f329b21ee28435a06fd64e828c8" args="(dmat *coeff, dmat *x, dmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dspline_eval           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evluate the cubic spline represented by nx5 matrix coeff, at location array xnew. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01680"></a>01680                                                               {
<a name="l01681"></a>01681     assert(coeff-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>==4);
<a name="l01682"></a>01682     <span class="keyword">const</span> <span class="keywordtype">long</span> nx=coeff-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l01683"></a>01683     PMAT(coeff,pc);
<a name="l01684"></a>01684     T xmin=x-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[0];
<a name="l01685"></a>01685     T xsep1=(double)(nx-1)/(x-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[nx-1]-xmin);
<a name="l01686"></a>01686     X(mat) *out=X(<span class="keyword">new</span>)(xnew-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, xnew-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l01687"></a>01687     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;xnew-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*xnew-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; ix++){
<a name="l01688"></a>01688     <span class="keywordtype">double</span> xn=REAL((xnew-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[ix]-xmin)*xsep1);
<a name="l01689"></a>01689     <span class="keywordtype">long</span> xnf=floor(xn);
<a name="l01690"></a>01690     <span class="keywordflow">if</span>(xnf&lt;0) xnf=0;
<a name="l01691"></a>01691     <span class="keywordflow">if</span>(xnf&gt;nx-2) xnf=nx-2;
<a name="l01692"></a>01692     xn=xn-xnf;
<a name="l01693"></a>01693     T xn2=xn*xn;
<a name="l01694"></a>01694     T xn3=xn2*xn;
<a name="l01695"></a>01695     out-&gt;p[ix]=pc[xnf][0]*xn3+pc[xnf][1]*xn2+pc[xnf][2]*xn+pc[xnf][3];
<a name="l01696"></a>01696     }
<a name="l01697"></a>01697     <span class="keywordflow">return</span> out;
<a name="l01698"></a>01698 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="66dcecfdc833ad4174eec33dafc3b8eb"></a><!-- doxytag: member="dmat.h::dspline" ref="66dcecfdc833ad4174eec33dafc3b8eb" args="(dmat *x, dmat *y, dmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dspline           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Do 1D cubic spline all at once by calling X(spline_prep) and X(spline_evald). 
<p>
<div class="fragment"><pre class="fragment"><a name="l01702"></a>01702                                                    {
<a name="l01703"></a>01703     X(mat) *coeff=X(spline_prep)(x,y);
<a name="l01704"></a>01704     X(mat) *out=X(spline_eval)(coeff,x,xnew);
<a name="l01705"></a>01705     X(free)(coeff);
<a name="l01706"></a>01706     <span class="keywordflow">return</span> out;
<a name="l01707"></a>01707 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="801f95bc127f94b526980791d71e2bb1"></a><!-- doxytag: member="dmat.h::dbspline_prep" ref="801f95bc127f94b526980791d71e2bb1" args="(dmat *x, dmat *y, dmat *z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dbspline_prep           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
2D cubic spline interpolation preparation. 
<p>
x is the x coordinate vector of the 2-d grid. y is the y coordinate vector of the 2-d grid. z is defined on the 2-d grid. It is upto the user to make sure that the coordinate is increasingly ordered and evenly spaced .<p>
The boundaries are handled in the same way is X(spline). i.e. replace <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(-1))/2\]" src="form_12.png">
<p>
 by <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(0))\]" src="form_13.png">
<p>
 Otehr type of boundaries are handled in the same way. <div class="fragment"><pre class="fragment"><a name="l01720"></a>01720                                                        {
<a name="l01721"></a>01721     <span class="keyword">const</span> <span class="keywordtype">long</span> nx=x-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l01722"></a>01722     <span class="keyword">const</span> <span class="keywordtype">long</span> ny=y-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l01723"></a>01723     assert(x-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==1 &amp;&amp; y-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a> ==1 &amp;&amp; z-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>==nx &amp;&amp; z-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>==ny);
<a name="l01724"></a>01724     X(cell)*coeff=X(cellnew)(nx,ny);
<a name="l01725"></a>01725     PCELL(coeff,pc);
<a name="l01726"></a>01726   
<a name="l01727"></a>01727     PMAT(z,p);
<a name="l01728"></a>01728     T p00,p01,p02,p03,p10,p11,p12,p13,p20,p21,p22,p23,p30,p31,p32,p33;
<a name="l01729"></a>01729     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;ny-1; iy++){
<a name="l01730"></a>01730     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;nx-1; ix++){
<a name="l01731"></a>01731         <span class="keywordflow">if</span>(iy==0){
<a name="l01732"></a>01732         <span class="keywordflow">if</span>(ix==0){
<a name="l01733"></a>01733             p00=2*(2*p[iy][ix]-p[iy][ix+1])-(2*p[iy+1][ix]-p[iy+1][ix+1]);<span class="comment">//from a</span>
<a name="l01734"></a>01734         }<span class="keywordflow">else</span>{
<a name="l01735"></a>01735             p00=2*p[iy][ix-1]-p[iy+1][ix-1];<span class="comment">//from b</span>
<a name="l01736"></a>01736         }
<a name="l01737"></a>01737         p01=2*p[iy][ix]-p[iy+1][ix];
<a name="l01738"></a>01738         p02=2*p[iy][ix+1]-p[iy+1][ix+1];
<a name="l01739"></a>01739         <span class="keywordflow">if</span>(ix==nx-2){
<a name="l01740"></a>01740             p03=2*(p[iy][ix+1]*2-p[iy][ix])-(p[iy+1][ix+1]*2-p[iy+1][ix]);<span class="comment">//from n</span>
<a name="l01741"></a>01741         }<span class="keywordflow">else</span>{
<a name="l01742"></a>01742             p03=2*p[iy][ix+2]-p[iy+1][ix+2];<span class="comment">//from m</span>
<a name="l01743"></a>01743         }
<a name="l01744"></a>01744         }<span class="keywordflow">else</span>{
<a name="l01745"></a>01745         <span class="keywordflow">if</span>(ix==0){
<a name="l01746"></a>01746             p00=2*p[iy-1][ix]-p[iy-1][ix+1];<span class="comment">//a from b</span>
<a name="l01747"></a>01747         }<span class="keywordflow">else</span>{
<a name="l01748"></a>01748             p00=p[iy-1][ix-1];<span class="comment">//b</span>
<a name="l01749"></a>01749         }
<a name="l01750"></a>01750         p01=p[iy-1][ix];
<a name="l01751"></a>01751         p02=p[iy-1][ix+1];
<a name="l01752"></a>01752         <span class="keywordflow">if</span>(ix==nx-2){
<a name="l01753"></a>01753             p03=p[iy-1][ix+1]*2-p[iy-1][ix];<span class="comment">//n from m</span>
<a name="l01754"></a>01754         }<span class="keywordflow">else</span>{
<a name="l01755"></a>01755             p03=p[iy-1][ix+2];<span class="comment">//m</span>
<a name="l01756"></a>01756         }
<a name="l01757"></a>01757         }
<a name="l01758"></a>01758         <span class="keywordflow">if</span>(ix==0){
<a name="l01759"></a>01759         p10=p[iy][ix]*2-p[iy][ix+1];<span class="comment">//from c</span>
<a name="l01760"></a>01760         }<span class="keywordflow">else</span>{
<a name="l01761"></a>01761         p10=p[iy][ix-1];<span class="comment">//c</span>
<a name="l01762"></a>01762         }
<a name="l01763"></a>01763         p11=p[iy][ix];
<a name="l01764"></a>01764         p12=p[iy][ix+1];
<a name="l01765"></a>01765         <span class="keywordflow">if</span>(ix==nx-2){
<a name="l01766"></a>01766         p13=p[iy][ix+1]*2-p[iy][ix];<span class="comment">//from d</span>
<a name="l01767"></a>01767         }<span class="keywordflow">else</span>{
<a name="l01768"></a>01768         p13=p[iy][ix+2];<span class="comment">//d</span>
<a name="l01769"></a>01769         }
<a name="l01770"></a>01770         <span class="keywordflow">if</span>(ix==0){
<a name="l01771"></a>01771         p20=p[iy+1][ix]*2-p[iy+1][ix+1];<span class="comment">//from e</span>
<a name="l01772"></a>01772         }<span class="keywordflow">else</span>{
<a name="l01773"></a>01773         p20=p[iy+1][ix-1];<span class="comment">//e</span>
<a name="l01774"></a>01774         }
<a name="l01775"></a>01775         p21=p[iy+1][ix];
<a name="l01776"></a>01776         p22=p[iy+1][ix+1];
<a name="l01777"></a>01777         <span class="keywordflow">if</span>(ix==nx-2){
<a name="l01778"></a>01778         p23=p[iy+1][ix+1]*2-p[iy+1][ix];<span class="comment">//from f</span>
<a name="l01779"></a>01779         }<span class="keywordflow">else</span>{
<a name="l01780"></a>01780         p23=p[iy+1][ix+2];<span class="comment">//f</span>
<a name="l01781"></a>01781         }
<a name="l01782"></a>01782         <span class="keywordflow">if</span>(iy==ny-2){
<a name="l01783"></a>01783         <span class="keywordflow">if</span>(ix==0){
<a name="l01784"></a>01784             p30=2*(p[iy+1][ix]*2-p[iy+1][ix+1])-(p[iy][ix]*2-p[iy][ix+1]);<span class="comment">//from h</span>
<a name="l01785"></a>01785         }<span class="keywordflow">else</span>{
<a name="l01786"></a>01786             p30=2*p[iy+1][ix-1]-p[iy][ix-1];<span class="comment">//from g</span>
<a name="l01787"></a>01787         }
<a name="l01788"></a>01788         p31=2*p[iy+1][ix]-p[iy][ix];
<a name="l01789"></a>01789         p32=2*p[iy+1][ix+1]-p[iy][ix+1];
<a name="l01790"></a>01790         <span class="keywordflow">if</span>(ix==nx-2){
<a name="l01791"></a>01791             p33=2*(2*p[iy+1][ix+1]-p[iy+1][ix])-(2*p[iy][ix+1]-p[iy][ix]);<span class="comment">//from j</span>
<a name="l01792"></a>01792         }<span class="keywordflow">else</span>{
<a name="l01793"></a>01793             p33=2*p[iy+1][ix+2]-p[iy][ix+2];<span class="comment">//from i</span>
<a name="l01794"></a>01794         }
<a name="l01795"></a>01795         }<span class="keywordflow">else</span>{
<a name="l01796"></a>01796         <span class="keywordflow">if</span>(ix==0){
<a name="l01797"></a>01797             p30=p[iy+2][ix]*2-p[iy+2][ix+1];<span class="comment">//h from g</span>
<a name="l01798"></a>01798         }<span class="keywordflow">else</span>{
<a name="l01799"></a>01799             p30=p[iy+2][ix-1];<span class="comment">//g</span>
<a name="l01800"></a>01800         }
<a name="l01801"></a>01801         p31=p[iy+2][ix];
<a name="l01802"></a>01802         p32=p[iy+2][ix+1];
<a name="l01803"></a>01803         <span class="keywordflow">if</span>(ix==nx-2){
<a name="l01804"></a>01804             p33=2*p[iy+2][ix+1]-p[iy+2][ix];<span class="comment">//j from i</span>
<a name="l01805"></a>01805         }<span class="keywordflow">else</span>{
<a name="l01806"></a>01806             p33=p[iy+2][ix+2];<span class="comment">//i</span>
<a name="l01807"></a>01807         }
<a name="l01808"></a>01808         }
<a name="l01809"></a>01809         pc[iy][ix] = X(<span class="keyword">new</span>)(4,4);
<a name="l01810"></a>01810         PMAT(pc[iy][ix],ppc);
<a name="l01811"></a>01811         ppc[0][0] = p11;
<a name="l01812"></a>01812         ppc[0][1] = -.5*p10 + .5*p12;
<a name="l01813"></a>01813         ppc[0][2] = p10 - 2.5*p11 + 2*p12 - .5*p13;
<a name="l01814"></a>01814         ppc[0][3] = -.5*p10 + 1.5*p11 - 1.5*p12 + .5*p13;
<a name="l01815"></a>01815         ppc[1][0] = -.5*p01 + .5*p21;
<a name="l01816"></a>01816         ppc[1][1] = .25*p00 - .25*p02 - .25*p20 + .25*p22;
<a name="l01817"></a>01817         ppc[1][2] = -.5*p00 + 1.25*p01 - p02 + .25*p03 + .5*p20 - 1.25*p21 + p22 - .25*p23;
<a name="l01818"></a>01818         ppc[1][3] = .25*p00 - .75*p01 + .75*p02 - .25*p03 - .25*p20 + .75*p21 - .75*p22 + .25*p23;
<a name="l01819"></a>01819         ppc[2][0] = p01 - 2.5*p11 + 2*p21 - .5*p31;
<a name="l01820"></a>01820         ppc[2][1] = -.5*p00 + .5*p02 + 1.25*p10 - 1.25*p12 - p20 + p22 + .25*p30 - .25*p32;
<a name="l01821"></a>01821         ppc[2][2] = p00 - 2.5*p01 + 2*p02 - .5*p03 - 2.5*p10 + 6.25*p11 - 5*p12 + 1.25*p13 + 2*p20 - 5*p21 + 4*p22 - p23 - .5*p30 + 1.25*p31 - p32 + .25*p33;
<a name="l01822"></a>01822         ppc[2][3] = -.5*p00 + 1.5*p01 - 1.5*p02 + .5*p03 + 1.25*p10 - 3.75*p11 + 3.75*p12 - 1.25*p13 - p20 + 3*p21 - 3*p22 + p23 + .25*p30 - .75*p31 + .75*p32 - .25*p33;
<a name="l01823"></a>01823         ppc[3][0] = -.5*p01 + 1.5*p11 - 1.5*p21 + .5*p31;
<a name="l01824"></a>01824         ppc[3][1] = .25*p00 - .25*p02 - .75*p10 + .75*p12 + .75*p20 - .75*p22 - .25*p30 + .25*p32;
<a name="l01825"></a>01825         ppc[3][2] = -.5*p00 + 1.25*p01 - p02 + .25*p03 + 1.5*p10 - 3.75*p11 + 3*p12 - .75*p13 - 1.5*p20 + 3.75*p21 - 3*p22 + .75*p23 + .5*p30 - 1.25*p31 + p32 - .25*p33;
<a name="l01826"></a>01826         ppc[3][3] = .25*p00 - .75*p01 + .75*p02 - .25*p03 - .75*p10 + 2.25*p11 - 2.25*p12 + .75*p13 + .75*p20 - 2.25*p21 + 2.25*p22 - .75*p23 - .25*p30 + .75*p31 - .75*p32 + .25*p33;
<a name="l01827"></a>01827 
<a name="l01828"></a>01828     }
<a name="l01829"></a>01829     }
<a name="l01830"></a>01830     <span class="keywordflow">return</span> coeff;
<a name="l01831"></a>01831 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="88fcc3be27ce68860cc93c2540c363b2"></a><!-- doxytag: member="dmat.h::dbspline_eval" ref="88fcc3be27ce68860cc93c2540c363b2" args="(dcell *coeff, dmat *x, dmat *y, dmat *xnew, dmat *ynew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dbspline_eval           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>ynew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evaluate 2D cubic spline at location defined 2-d arrays by xnew, ynew. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01836"></a>01836                                                                                         {
<a name="l01837"></a>01837     <span class="keyword">const</span> <span class="keywordtype">long</span> nx=x-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l01838"></a>01838     <span class="keyword">const</span> <span class="keywordtype">long</span> ny=y-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l01839"></a>01839     T xmin=x-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[0];
<a name="l01840"></a>01840     T ymin=y-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[0];
<a name="l01841"></a>01841     T xsep1=(double)(nx-1)/(x-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[nx-1]-xmin);
<a name="l01842"></a>01842     T ysep1=(double)(ny-1)/(y-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[ny-1]-ymin);
<a name="l01843"></a>01843     assert(xnew-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> == ynew-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> &amp;&amp; xnew-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a> == ynew-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l01844"></a>01844     X(mat)*znew=X(<span class="keyword">new</span>)(xnew-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, xnew-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l01845"></a>01845     PCELL(coeff,pc);
<a name="l01846"></a>01846     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;xnew-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>*xnew-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>; ix++){
<a name="l01847"></a>01847     <span class="keywordtype">double</span> xm=REAL((xnew-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[ix]-xmin)*xsep1);
<a name="l01848"></a>01848     <span class="keywordtype">long</span> xmf=floor(xm);
<a name="l01849"></a>01849     <span class="keywordflow">if</span>(xmf&lt;0) xmf=0;
<a name="l01850"></a>01850     <span class="keywordflow">if</span>(xmf&gt;nx-2) xmf=nx-2;
<a name="l01851"></a>01851     xm=xm-xmf;
<a name="l01852"></a>01852 
<a name="l01853"></a>01853     <span class="keywordtype">double</span> ym=REAL((ynew-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[ix]-ymin)*ysep1);
<a name="l01854"></a>01854     <span class="keywordtype">long</span> ymf=floor(ym);
<a name="l01855"></a>01855     <span class="keywordflow">if</span>(ymf&lt;0) ymf=0;
<a name="l01856"></a>01856     <span class="keywordflow">if</span>(ymf&gt;ny-2) ymf=ny-2;
<a name="l01857"></a>01857     ym=ym-ymf;
<a name="l01858"></a>01858     
<a name="l01859"></a>01859     T xm2=xm *xm;
<a name="l01860"></a>01860     T xm3=xm2*xm;
<a name="l01861"></a>01861     T ym2=ym *ym;
<a name="l01862"></a>01862     T ym3=ym2*ym;
<a name="l01863"></a>01863     PMAT(pc[ymf][xmf],ppc);
<a name="l01864"></a>01864     znew-&gt;p[ix]= ppc[0][0] + ppc[0][1] * xm + ppc[0][2] * xm2 + ppc[0][3] * xm3 +
<a name="l01865"></a>01865         ppc[1][0] * ym + ppc[1][1] * ym * xm + ppc[1][2] * ym * xm2 + ppc[1][3] * ym * xm3 +
<a name="l01866"></a>01866         ppc[2][0] * ym2 + ppc[2][1] * ym2 * xm + ppc[2][2] * ym2 * xm2 + ppc[2][3] * ym2 * xm3 +
<a name="l01867"></a>01867         ppc[3][0] * ym3 + ppc[3][1] * ym3 * xm + ppc[3][2] * ym3 * xm2 + ppc[3][3] * ym3 * xm3;
<a name="l01868"></a>01868 
<a name="l01869"></a>01869     }
<a name="l01870"></a>01870     <span class="keywordflow">return</span> znew;
<a name="l01871"></a>01871 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="abf4cf559f55b2e888fed7dd336f6e07"></a><!-- doxytag: member="dmat.h::dcellnew" ref="abf4cf559f55b2e888fed7dd336f6e07" args="(const long nx, const long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellnew           </td>
          <td>(</td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create a new block matrix. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00062"></a>00062                                                  {
<a name="l00063"></a>00063     X(cell) *dc;
<a name="l00064"></a>00064     dc=calloc(1, <span class="keyword">sizeof</span>(X(cell)));
<a name="l00065"></a>00065     dc-&gt;nx=nx;
<a name="l00066"></a>00066     dc-&gt;ny=ny;
<a name="l00067"></a>00067     dc-&gt;p=calloc(nx*ny, <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00068"></a>00068     <span class="keywordflow">return</span> dc;
<a name="l00069"></a>00069 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="92bc9490727ab673ba458e0b78b81b05"></a><!-- doxytag: member="dmat.h::dcellnew2" ref="92bc9490727ab673ba458e0b78b81b05" args="(const dcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellnew2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create an new X(cell) similar to A in shape 
<p>
<div class="fragment"><pre class="fragment"><a name="l00074"></a>00074                                       {
<a name="l00075"></a>00075     X(cell) *out=X(cellnew)(A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>, A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>);
<a name="l00076"></a>00076     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; i++){
<a name="l00077"></a>00077     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[i]){
<a name="l00078"></a>00078         out-&gt;p[i]=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[i]-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, A-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[i]-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00079"></a>00079     }
<a name="l00080"></a>00080     }
<a name="l00081"></a>00081     <span class="keywordflow">return</span> out;
<a name="l00082"></a>00082 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e385d21eb33f992fd5ff4d3166d929ba"></a><!-- doxytag: member="dmat.h::dcellzero" ref="e385d21eb33f992fd5ff4d3166d929ba" args="(dcell *dc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellzero           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
setting all elements of a X(cell) to zero. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00143"></a>00143                              {
<a name="l00144"></a>00144     <span class="keywordflow">if</span>(dc){
<a name="l00145"></a>00145     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;dc-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>*dc-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; ix++){
<a name="l00146"></a>00146         X(zero)(dc-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[ix]);
<a name="l00147"></a>00147     }
<a name="l00148"></a>00148     }
<a name="l00149"></a>00149 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a23f0606a6c60596734b1128855dba6d"></a><!-- doxytag: member="dmat.h::dcellset" ref="a23f0606a6c60596734b1128855dba6d" args="(dcell *dc, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
setting all elements of a X(cell) to alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00154"></a>00154                                     {
<a name="l00155"></a>00155     <span class="keywordflow">if</span>(dc){
<a name="l00156"></a>00156     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;dc-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>*dc-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; ix++){
<a name="l00157"></a>00157         X(<span class="keyword">set</span>)(dc-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[ix],alpha);
<a name="l00158"></a>00158     }
<a name="l00159"></a>00159     }
<a name="l00160"></a>00160 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f306524d189291b53dc6dd8547c4ddf2"></a><!-- doxytag: member="dmat.h::dcellfree_do" ref="f306524d189291b53dc6dd8547c4ddf2" args="(dcell *dc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a X(cell) object. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00087"></a>00087                                 {
<a name="l00088"></a>00088     <span class="keywordflow">if</span>(!dc) <span class="keywordflow">return</span>;
<a name="l00089"></a>00089     <span class="keywordflow">if</span>(dc-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>){
<a name="l00090"></a>00090     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;dc-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>*dc-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; ix++){
<a name="l00091"></a>00091         X(free)(dc-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[ix]);
<a name="l00092"></a>00092     }
<a name="l00093"></a>00093     <span class="keywordflow">if</span>(dc-&gt;<a class="code" href="structdcell.html#a53b1549596e901a5e454da1c4212fd6" title="not NULL if mmaped.">mmap</a>){
<a name="l00094"></a>00094         munmap(dc-&gt;<a class="code" href="structdcell.html#a53b1549596e901a5e454da1c4212fd6" title="not NULL if mmaped.">mmap</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)*2+<span class="keyword">sizeof</span>(uint32_t));
<a name="l00095"></a>00095     }
<a name="l00096"></a>00096     free(dc-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>);
<a name="l00097"></a>00097     }
<a name="l00098"></a>00098     free(dc);
<a name="l00099"></a>00099 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="faf442e020aff84b8b1fe1766ab89227"></a><!-- doxytag: member="dmat.h::dcelltrans" ref="faf442e020aff84b8b1fe1766ab89227" args="(const dcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcelltrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
transpose a X(cell) object 
<p>
<div class="fragment"><pre class="fragment"><a name="l00165"></a>00165                                        {
<a name="l00166"></a>00166     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l00167"></a>00167     X(cell) *B=X(cellnew)(A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>, A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>);
<a name="l00168"></a>00168     X(mat)* (*Bp)[B-&gt;nx]=(<span class="keywordtype">void</span>*)B-&gt;p;
<a name="l00169"></a>00169     X(mat)* (*Ap)[A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>]=(<span class="keywordtype">void</span>*)A-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>;
<a name="l00170"></a>00170     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;nx; ix++){
<a name="l00171"></a>00171     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; iy++){
<a name="l00172"></a>00172         Bp[ix][iy]=X(trans)(Ap[iy][ix]);
<a name="l00173"></a>00173     }
<a name="l00174"></a>00174     }
<a name="l00175"></a>00175     <span class="keywordflow">return</span> B;
<a name="l00176"></a>00176 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="31480c8af50a8adc9182fae5285aaa6e"></a><!-- doxytag: member="dmat.h::dcellref" ref="31480c8af50a8adc9182fae5285aaa6e" args="(const dcell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellref           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creat a X(cell) reference an existing X(cell) by referencing the elements. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00105"></a>00105                                       {
<a name="l00106"></a>00106     <span class="keywordflow">if</span>(!in) <span class="keywordflow">return</span> NULL;
<a name="l00107"></a>00107     X(cell) *out=X(cellnew)(in-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>, in-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>);
<a name="l00108"></a>00108     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;in-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>*in-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; i++){
<a name="l00109"></a>00109     out-&gt;p[i]=X(ref)(in-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[i]);
<a name="l00110"></a>00110     }
<a name="l00111"></a>00111     <span class="keywordflow">return</span> out;
<a name="l00112"></a>00112 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dde326a0041feef662127b62b4c37f23"></a><!-- doxytag: member="dmat.h::dcelldup" ref="dde326a0041feef662127b62b4c37f23" args="(const dcell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcelldup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
duplicate a X(cell) object. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00117"></a>00117                                       {
<a name="l00118"></a>00118     X(cell) *out=NULL;
<a name="l00119"></a>00119     X(cellcp)(&amp;out, in);
<a name="l00120"></a>00120     <span class="keywordflow">return</span> out;
<a name="l00121"></a>00121 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="104912d02e021b396d29d78bd2249b95"></a><!-- doxytag: member="dmat.h::dcellcp" ref="104912d02e021b396d29d78bd2249b95" args="(dcell **out0, const dcell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellcp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy the values from one X(cell) to another. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00126"></a>00126                                                  {
<a name="l00127"></a>00127     <span class="keywordflow">if</span>(in){
<a name="l00128"></a>00128     <span class="keywordflow">if</span>(!*out0)
<a name="l00129"></a>00129         *out0=X(cellnew)(in-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>, in-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>);
<a name="l00130"></a>00130     X(cell)* out=*out0;
<a name="l00131"></a>00131     assert(out-&gt;nx==in-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a> &amp;&amp; out-&gt;ny==in-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>);
<a name="l00132"></a>00132     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;in-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>*in-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; i++){
<a name="l00133"></a>00133         X(cp)(&amp;out-&gt;p[i], in-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[i]);
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135     }<span class="keywordflow">else</span>{
<a name="l00136"></a>00136     X(cellfree)(*out0);<span class="comment">//copy a null X(cell) is same as erasing.</span>
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="99511eff251a7861181946af30572ef9"></a><!-- doxytag: member="dmat.h::dcellnorm2" ref="99511eff251a7861181946af30572ef9" args="(const dcell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dcellnorm2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute norm2. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00181"></a>00181                                      {
<a name="l00182"></a>00182     <span class="keywordtype">double</span> out=0;
<a name="l00183"></a>00183     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;nx*A-&gt;ny; i++){
<a name="l00184"></a>00184     out+=X(norm2)(A-&gt;p[i]);
<a name="l00185"></a>00185     }
<a name="l00186"></a>00186     <span class="keywordflow">return</span> out;
<a name="l00187"></a>00187 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ae5e354726e58598c4f9a0ab039f0b67"></a><!-- doxytag: member="dmat.h::dcellscale" ref="ae5e354726e58598c4f9a0ab039f0b67" args="(dcell *A, double w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>w</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
scale each element of A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00192"></a>00192                                        {
<a name="l00193"></a>00193     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00194"></a>00194     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; i++){
<a name="l00195"></a>00195     X(scale)(A-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[i],w);
<a name="l00196"></a>00196     }
<a name="l00197"></a>00197 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="805f88ca094efb27fad5861042f5d4a4"></a><!-- doxytag: member="dmat.h::dcellreduce" ref="805f88ca094efb27fad5861042f5d4a4" args="(const dcell *A, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellreduce           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reduce nx*ny cell matrix to 1*ny if dim=1 and nx*11 if dim=2 
<p>
<div class="fragment"><pre class="fragment"><a name="l00231"></a>00231                                                 {
<a name="l00232"></a>00232     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l00233"></a>00233     X(cell)* out=NULL;
<a name="l00234"></a>00234     <span class="keywordtype">long</span> nx, ny, *nxs, *nys;
<a name="l00235"></a>00235     X(celldim)(A, &amp;nx, &amp;ny, &amp;nxs, &amp;nys);
<a name="l00236"></a>00236     <span class="keywordflow">if</span>(nx==0 || ny==0) <span class="keywordflow">return</span> NULL;
<a name="l00237"></a>00237     PCELL(A,pA);
<a name="l00238"></a>00238     <span class="keywordflow">if</span>(dim==1){
<a name="l00239"></a>00239     out=X(cellnew)(1, A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>);
<a name="l00240"></a>00240     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; iy++){
<a name="l00241"></a>00241         <span class="keywordflow">if</span>(nys[iy]==0) <span class="keywordflow">continue</span>;
<a name="l00242"></a>00242         out-&gt;p[iy]=X(<span class="keyword">new</span>)(nx,nys[iy]);
<a name="l00243"></a>00243         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;nys[iy]; icol++){
<a name="l00244"></a>00244         <span class="keywordtype">long</span> kr=0;
<a name="l00245"></a>00245         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>; ix++){
<a name="l00246"></a>00246             <span class="keywordflow">if</span>(pA[iy][ix]){
<a name="l00247"></a>00247             memcpy(out-&gt;p[iy]-&gt;p+icol*nx+kr,
<a name="l00248"></a>00248                    pA[iy][ix]-&gt;p+icol*nxs[ix],
<a name="l00249"></a>00249                    nxs[ix]*<span class="keyword">sizeof</span>(T));
<a name="l00250"></a>00250             }           
<a name="l00251"></a>00251             kr+=nxs[ix];
<a name="l00252"></a>00252         }
<a name="l00253"></a>00253         }
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim==2){
<a name="l00256"></a>00256     out=X(cellnew)(A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>,1);
<a name="l00257"></a>00257     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>; ix++){
<a name="l00258"></a>00258         <span class="keywordflow">if</span>(nxs[ix]==0) <span class="keywordflow">continue</span>;
<a name="l00259"></a>00259         out-&gt;p[ix]=X(<span class="keyword">new</span>)(nxs[ix],ny);
<a name="l00260"></a>00260         <span class="keywordtype">long</span> kr=0;
<a name="l00261"></a>00261         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; iy++){
<a name="l00262"></a>00262         <span class="keywordflow">if</span>(pA[iy][ix]){
<a name="l00263"></a>00263             memcpy(out-&gt;p[ix]-&gt;p+kr*nxs[ix],
<a name="l00264"></a>00264                pA[iy][ix]-&gt;p,
<a name="l00265"></a>00265                nxs[ix]*nys[iy]*<span class="keyword">sizeof</span>(T));
<a name="l00266"></a>00266         }
<a name="l00267"></a>00267         kr+=nys[iy];
<a name="l00268"></a>00268         }
<a name="l00269"></a>00269     }
<a name="l00270"></a>00270     }<span class="keywordflow">else</span>{
<a name="l00271"></a>00271     error(<span class="stringliteral">"Invalid dim=%d\n"</span>,dim);
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273     free(nxs);
<a name="l00274"></a>00274     free(nys);
<a name="l00275"></a>00275     <span class="keywordflow">return</span> out;
<a name="l00276"></a>00276 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cf4358f31eff9028f0204dfceee00eb9"></a><!-- doxytag: member="dmat.h::dcellcat" ref="cf4358f31eff9028f0204dfceee00eb9" args="(const dcell *A, const dcell *B, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellcat           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
concatenate two cell matrices along dimenstion 'dim' 
<p>
<div class="fragment"><pre class="fragment"><a name="l00281"></a>00281                                                                 {
<a name="l00282"></a>00282     <span class="keywordflow">if</span>(!A){
<a name="l00283"></a>00283     <span class="keywordflow">if</span>(!B){
<a name="l00284"></a>00284         <span class="keywordflow">return</span> NULL;
<a name="l00285"></a>00285     }<span class="keywordflow">else</span>{
<a name="l00286"></a>00286         <span class="keywordflow">return</span> X(celldup)(B);
<a name="l00287"></a>00287     }
<a name="l00288"></a>00288     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(!B){
<a name="l00289"></a>00289     <span class="keywordflow">return</span> X(celldup)(A);
<a name="l00290"></a>00290     }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292     X(cell) *out=NULL;
<a name="l00293"></a>00293     PCELL(A,pA);
<a name="l00294"></a>00294     PCELL(B,pB);
<a name="l00295"></a>00295 
<a name="l00296"></a>00296     <span class="keywordflow">if</span>(dim==1){
<a name="l00297"></a>00297     <span class="comment">//along x.</span>
<a name="l00298"></a>00298     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>!=B-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>){
<a name="l00299"></a>00299         error(<span class="stringliteral">"Mismatch: A is (%ld, %ld), B is (%ld, %ld)\n"</span>,
<a name="l00300"></a>00300           A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>, A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>, B-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>, B-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>);
<a name="l00301"></a>00301     }
<a name="l00302"></a>00302     out=X(cellnew)(A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>+B-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>, A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>);
<a name="l00303"></a>00303     PCELL(out,pout);
<a name="l00304"></a>00304     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; iy++){
<a name="l00305"></a>00305         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>; ix++){
<a name="l00306"></a>00306         pout[iy][ix]=X(dup)(pA[iy][ix]);
<a name="l00307"></a>00307         }
<a name="l00308"></a>00308         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;B-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>; ix++){
<a name="l00309"></a>00309         pout[iy][ix+A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>]=X(dup)(pB[iy][ix]);
<a name="l00310"></a>00310         }
<a name="l00311"></a>00311     }
<a name="l00312"></a>00312     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim==2){
<a name="l00313"></a>00313     <span class="comment">//along y.</span>
<a name="l00314"></a>00314     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>!=B-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>){
<a name="l00315"></a>00315         error(<span class="stringliteral">"Mismatch. A is (%ld, %ld), B is (%ld, %ld)\n"</span>, 
<a name="l00316"></a>00316           A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>, A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>, B-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>, B-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>);
<a name="l00317"></a>00317     }
<a name="l00318"></a>00318     out=X(cellnew)(A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>, A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>+B-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>);
<a name="l00319"></a>00319     PCELL(out,pout);
<a name="l00320"></a>00320     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; iy++){
<a name="l00321"></a>00321         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>; ix++){
<a name="l00322"></a>00322         pout[iy][ix]=X(dup)(pA[iy][ix]);
<a name="l00323"></a>00323         }
<a name="l00324"></a>00324     }
<a name="l00325"></a>00325     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;B-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; iy++){
<a name="l00326"></a>00326         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;B-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>; ix++){
<a name="l00327"></a>00327         pout[iy+A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>][ix]=X(dup)(pB[iy][ix]);
<a name="l00328"></a>00328         }
<a name="l00329"></a>00329     }
<a name="l00330"></a>00330     }<span class="keywordflow">else</span>{
<a name="l00331"></a>00331     error(<span class="stringliteral">"Invalid dim\n"</span>);
<a name="l00332"></a>00332     }
<a name="l00333"></a>00333     <span class="keywordflow">return</span> out;
<a name="l00334"></a>00334 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="fb150ef1f6f90d87d2060922e3a2a9b2"></a><!-- doxytag: member="dmat.h::dcellcat_each" ref="fb150ef1f6f90d87d2060922e3a2a9b2" args="(const dcell *A, const dcell *B, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellcat_each           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
concatenate coresponding elements of each X(cell). 
<p>
They must have the same shape. <div class="fragment"><pre class="fragment"><a name="l00340"></a>00340                                                                      {
<a name="l00341"></a>00341     <span class="keywordflow">if</span>(!A){
<a name="l00342"></a>00342     <span class="keywordflow">if</span>(!B){
<a name="l00343"></a>00343         <span class="keywordflow">return</span> NULL;
<a name="l00344"></a>00344     }<span class="keywordflow">else</span>{
<a name="l00345"></a>00345         <span class="keywordflow">return</span> X(celldup)(B);
<a name="l00346"></a>00346     }
<a name="l00347"></a>00347     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(!B){
<a name="l00348"></a>00348     <span class="keywordflow">return</span> X(celldup)(A);
<a name="l00349"></a>00349     }
<a name="l00350"></a>00350     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>!=B-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a> || A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>!=B-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>){
<a name="l00351"></a>00351     error(<span class="stringliteral">"Mismatch: (%ld %ld), (%ld %ld)\n"</span>,A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>, A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>, B-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>, B-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>);
<a name="l00352"></a>00352     }
<a name="l00353"></a>00353     X(cell) *out=X(cellnew)(A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>, A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>);
<a name="l00354"></a>00354     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; ix++){
<a name="l00355"></a>00355     out-&gt;p[ix]=X(cat)(A-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[ix], B-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[ix], dim);
<a name="l00356"></a>00356     }
<a name="l00357"></a>00357     <span class="keywordflow">return</span> out;
<a name="l00358"></a>00358 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1e5613fa12d1d0d0b41ff909ac84a33e"></a><!-- doxytag: member="dmat.h::dcelldropempty" ref="1e5613fa12d1d0d0b41ff909ac84a33e" args="(dcell **A0, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcelldropempty           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
drop empty rows or columns. 
<p>
(size of *A0 is changed. <div class="fragment"><pre class="fragment"><a name="l00363"></a>00363                                             {
<a name="l00364"></a>00364     X(cell) *A=*A0;
<a name="l00365"></a>00365     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00366"></a>00366     PCELL(A,pA);
<a name="l00367"></a>00367     <span class="keywordflow">if</span>(dim==1){
<a name="l00368"></a>00368     <span class="comment">//drop rows</span>
<a name="l00369"></a>00369     <span class="keywordtype">int</span> keep[A-&gt;nx];
<a name="l00370"></a>00370     <span class="keywordtype">int</span> ndrop=0;
<a name="l00371"></a>00371     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;nx; ix++){
<a name="l00372"></a>00372         keep[ix]=0;
<a name="l00373"></a>00373         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;ny; iy++){
<a name="l00374"></a>00374         <span class="keywordflow">if</span>(pA[iy][ix]){
<a name="l00375"></a>00375             keep[ix]=1;
<a name="l00376"></a>00376             <span class="keywordflow">break</span>;
<a name="l00377"></a>00377         }
<a name="l00378"></a>00378         }
<a name="l00379"></a>00379         <span class="keywordflow">if</span>(keep[ix]==0)
<a name="l00380"></a>00380         ndrop++;
<a name="l00381"></a>00381     }
<a name="l00382"></a>00382     <span class="keywordflow">if</span>(ndrop!=0){
<a name="l00383"></a>00383         <span class="keywordflow">if</span>(ndrop==A-&gt;nx){
<a name="l00384"></a>00384         X(cellfree)(A);
<a name="l00385"></a>00385         *A0=NULL;
<a name="l00386"></a>00386         }<span class="keywordflow">else</span>{
<a name="l00387"></a>00387         X(cell) *B=calloc(1, <span class="keyword">sizeof</span>(X(cell)*));
<a name="l00388"></a>00388         B-&gt;p=calloc((A-&gt;nx-ndrop)*A-&gt;ny, <span class="keyword">sizeof</span>(X(mat)*));
<a name="l00389"></a>00389         PCELL(B,pB);
<a name="l00390"></a>00390         <span class="keywordtype">int</span> count=0;
<a name="l00391"></a>00391         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;nx; ix++){
<a name="l00392"></a>00392             <span class="keywordflow">if</span>(keep[ix]){
<a name="l00393"></a>00393             <span class="keywordflow">if</span>(count!=ix){
<a name="l00394"></a>00394                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;ny; iy++){
<a name="l00395"></a>00395                 pB[iy][count]=pA[iy][ix];
<a name="l00396"></a>00396                 }
<a name="l00397"></a>00397             }
<a name="l00398"></a>00398             count++;
<a name="l00399"></a>00399             }<span class="keywordflow">else</span>{
<a name="l00400"></a>00400             warning(<span class="stringliteral">"row %d dropped\n"</span>, ix);
<a name="l00401"></a>00401             }
<a name="l00402"></a>00402         }
<a name="l00403"></a>00403         free(A-&gt;p); free(A);
<a name="l00404"></a>00404         A=B;
<a name="l00405"></a>00405         }
<a name="l00406"></a>00406     }
<a name="l00407"></a>00407     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim==2){
<a name="l00408"></a>00408     <span class="comment">//drop cols</span>
<a name="l00409"></a>00409     <span class="keywordtype">int</span> count=0;
<a name="l00410"></a>00410     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;ny; iy++){
<a name="l00411"></a>00411         <span class="keywordtype">int</span> keep=0;
<a name="l00412"></a>00412         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;nx; ix++){
<a name="l00413"></a>00413         <span class="keywordflow">if</span>(pA[iy][ix]){
<a name="l00414"></a>00414             keep=1;
<a name="l00415"></a>00415             <span class="keywordflow">break</span>;
<a name="l00416"></a>00416         }
<a name="l00417"></a>00417         }
<a name="l00418"></a>00418         <span class="keywordflow">if</span>(keep){
<a name="l00419"></a>00419         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;nx; ix++){
<a name="l00420"></a>00420             pA[count][ix]=pA[iy][ix];
<a name="l00421"></a>00421         }
<a name="l00422"></a>00422         count++;
<a name="l00423"></a>00423         }<span class="keywordflow">else</span>{
<a name="l00424"></a>00424         <span class="comment">//warning("Col %d dropped\n", iy);</span>
<a name="l00425"></a>00425         }
<a name="l00426"></a>00426     }
<a name="l00427"></a>00427     A-&gt;ny=count;
<a name="l00428"></a>00428     <span class="keywordflow">if</span>(count==0){
<a name="l00429"></a>00429         X(cellfree)(A);
<a name="l00430"></a>00430         *A0=NULL;
<a name="l00431"></a>00431     }<span class="keywordflow">else</span>{
<a name="l00432"></a>00432         A-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>=realloc(A-&gt;p,<span class="keyword">sizeof</span>(X(mat)*)*A-&gt;ny*A-&gt;nx);
<a name="l00433"></a>00433     }
<a name="l00434"></a>00434     }<span class="keywordflow">else</span>{
<a name="l00435"></a>00435     error(<span class="stringliteral">"Invalid dim: %d\n"</span>,dim);
<a name="l00436"></a>00436     }
<a name="l00437"></a>00437  
<a name="l00438"></a>00438 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1c506292c4c46d72e8fd573540839ae7"></a><!-- doxytag: member="dmat.h::dcelladd" ref="1c506292c4c46d72e8fd573540839ae7" args="(dcell **B0, double bc, const dcell *A, const double ac)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcelladd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>ac</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add one to another. 
<p>
B=B*bc+A*ac <div class="fragment"><pre class="fragment"><a name="l00443"></a>00443                                                                           {
<a name="l00444"></a>00444     <span class="keywordflow">if</span>(A){
<a name="l00445"></a>00445     <span class="keywordflow">if</span>(!*B0){
<a name="l00446"></a>00446         *B0=X(cellnew)(A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>, A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>); bc=0;
<a name="l00447"></a>00447     }
<a name="l00448"></a>00448     X(cell) *B=*B0;
<a name="l00449"></a>00449     assert(A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>==B-&gt;nx &amp;&amp; A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a> == B-&gt;ny);
<a name="l00450"></a>00450     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; i++){
<a name="l00451"></a>00451         X(<span class="keyword">add</span>)(&amp;B-&gt;p[i], bc, A-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[i], ac);
<a name="l00452"></a>00452     }
<a name="l00453"></a>00453     }
<a name="l00454"></a>00454 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="74eda13294cbbec5c4e93e70d7297301"></a><!-- doxytag: member="dmat.h::dcellinn" ref="74eda13294cbbec5c4e93e70d7297301" args="(const dcell *A, const dcell *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dcellinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the inner produce of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00459"></a>00459                                               {
<a name="l00460"></a>00460     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>!=B-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a> || A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>!=1 || B-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>!=1) error(<span class="stringliteral">"mismatch\n"</span>);
<a name="l00461"></a>00461     T out=0;
<a name="l00462"></a>00462     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>; i++){
<a name="l00463"></a>00463     out+=X(inn)(A-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[i], B-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[i]);
<a name="l00464"></a>00464     }
<a name="l00465"></a>00465     <span class="keywordflow">return</span> out;
<a name="l00466"></a>00466 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="57b0daa3ccb27a83e4b2235da8eec035"></a><!-- doxytag: member="dmat.h::dcellcwm" ref="57b0daa3ccb27a83e4b2235da8eec035" args="(dcell *B, const dcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellcwm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Component wise multiply of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a> B=A. 
<p>
*B*alpha <div class="fragment"><pre class="fragment"><a name="l00472"></a>00472                                              {
<a name="l00473"></a>00473     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>!=B-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a> || A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a> !=B-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>) error(<span class="stringliteral">"mismatch\n"</span>);
<a name="l00474"></a>00474     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; i++){
<a name="l00475"></a>00475     X(cwm)(B-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[i], A-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[i]);
<a name="l00476"></a>00476     }
<a name="l00477"></a>00477 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2011d79d74ff15b07162da6f0a28fd97"></a><!-- doxytag: member="dmat.h::dcellmm" ref="2011d79d74ff15b07162da6f0a28fd97" args="(dcell **C0, const dcell *A, const dcell *B, const char trans[2], const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellmm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>trans</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute A*B and add to C0. 
<p>
C=C+trans(A)*trans(B)*alpha<p>
2009-11-09: There was initially a beta parameter It was implemented wrongly for beta!=1 because for every call to dmm, the already accumulated ones are scaled. removed beta. <div class="fragment"><pre class="fragment"><a name="l00489"></a>00489                                                    {
<a name="l00490"></a>00490     <span class="keywordflow">if</span>(!A || !B) <span class="keywordflow">return</span>;
<a name="l00491"></a>00491     <span class="keywordtype">int</span> ax, az;
<a name="l00492"></a>00492     <span class="keywordtype">int</span> nx,ny,nz;
<a name="l00493"></a>00493     <span class="keywordtype">int</span> bz, by;
<a name="l00494"></a>00494     <span class="keywordflow">if</span>(trans[0]==<span class="charliteral">'n'</span>||trans[0]==<span class="charliteral">'N'</span>){
<a name="l00495"></a>00495     nx=A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>; 
<a name="l00496"></a>00496     ax=1; az=A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>;
<a name="l00497"></a>00497     nz=A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>;
<a name="l00498"></a>00498     }<span class="keywordflow">else</span>{ 
<a name="l00499"></a>00499     nx=A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>;
<a name="l00500"></a>00500     az=1; ax=A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>;
<a name="l00501"></a>00501     nz=A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>;
<a name="l00502"></a>00502     }
<a name="l00503"></a>00503     <span class="keywordflow">if</span>(trans[1]==<span class="charliteral">'n'</span>||trans[0]==<span class="charliteral">'N'</span>){
<a name="l00504"></a>00504     ny=B-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; 
<a name="l00505"></a>00505     bz=1; by=B-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>;
<a name="l00506"></a>00506     <span class="keywordflow">if</span>(nz!=B-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>) error(<span class="stringliteral">"mismatch\n"</span>);
<a name="l00507"></a>00507     }<span class="keywordflow">else</span>{
<a name="l00508"></a>00508     ny=B-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>;
<a name="l00509"></a>00509     by=1; bz=B-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>;
<a name="l00510"></a>00510     <span class="keywordflow">if</span>(nz!=B-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>) error(<span class="stringliteral">"mismatch\n"</span>);
<a name="l00511"></a>00511     }
<a name="l00512"></a>00512     <span class="keywordflow">if</span>(!*C0){
<a name="l00513"></a>00513     *C0=X(cellnew)(nx,ny);
<a name="l00514"></a>00514     }
<a name="l00515"></a>00515     X(cell) *C=*C0;
<a name="l00516"></a>00516     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;ny; iy++){
<a name="l00517"></a>00517     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;nx; ix++){
<a name="l00518"></a>00518         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz=0; iz&lt;nz; iz++){
<a name="l00519"></a>00519         <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[ix*ax+iz*az]&amp;&amp;B-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[iz*bz+iy*by]){
<a name="l00520"></a>00520             X(mm)(&amp;C-&gt;p[ix+iy*nx],A-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[ix*ax+iz*az], 
<a name="l00521"></a>00521               B-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[iz*bz+iy*by],trans,alpha);
<a name="l00522"></a>00522         }
<a name="l00523"></a>00523         }
<a name="l00524"></a>00524     }
<a name="l00525"></a>00525     }
<a name="l00526"></a>00526 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="59e3e5c87a7038f6408858c159a166a4"></a><!-- doxytag: member="dmat.h::dcellinvspd" ref="59e3e5c87a7038f6408858c159a166a4" args="(dcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellinvspd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inplace Invert a SPD matrix. 
<p>
It is treated as a block matrix <div class="fragment"><pre class="fragment"><a name="l00531"></a>00531                                   {
<a name="l00532"></a>00532     X(mat) *Ab=X(cell2m)(A);
<a name="l00533"></a>00533     X(invspd_inplace)(Ab);
<a name="l00534"></a>00534     X(cell) *B=NULL;
<a name="l00535"></a>00535     X(2cell)(&amp;B, Ab, A);
<a name="l00536"></a>00536     X(celldropzero)(B,0);
<a name="l00537"></a>00537     X(free)(Ab);
<a name="l00538"></a>00538     <span class="keywordflow">return</span> B;
<a name="l00539"></a>00539 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bdecf8635a39266960e7121b54be57d2"></a><!-- doxytag: member="dmat.h::dcellinv" ref="bdecf8635a39266960e7121b54be57d2" args="(dcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellinv           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inplace Invert a matrix. 
<p>
It is treated as a block matrix. <div class="fragment"><pre class="fragment"><a name="l00544"></a>00544                                {
<a name="l00545"></a>00545     X(mat) *Ab=X(cell2m)(A);
<a name="l00546"></a>00546     X(inv_inplace)(Ab);
<a name="l00547"></a>00547     X(cell) *B=NULL;
<a name="l00548"></a>00548     X(2cell)(&amp;B, Ab, A);
<a name="l00549"></a>00549     X(celldropzero)(B,0);
<a name="l00550"></a>00550     X(free)(Ab);
<a name="l00551"></a>00551     <span class="keywordflow">return</span> B;
<a name="l00552"></a>00552 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cc0cce55471ddf4b189b5722f5f93790"></a><!-- doxytag: member="dmat.h::dcellinvspd_each" ref="cc0cce55471ddf4b189b5722f5f93790" args="(dcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellinvspd_each           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
invert each component of the <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>. 
<p>
Each cell is treated as an individual matrix. <div class="fragment"><pre class="fragment"><a name="l00557"></a>00557                                        {
<a name="l00558"></a>00558     X(cell) *out=NULL;
<a name="l00559"></a>00559     X(cellcp)(&amp;out,A);
<a name="l00560"></a>00560     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;out-&gt;nx*out-&gt;ny; i++){
<a name="l00561"></a>00561     X(invspd_inplace)(out-&gt;p[i]);
<a name="l00562"></a>00562     }
<a name="l00563"></a>00563     <span class="keywordflow">return</span> out;
<a name="l00564"></a>00564 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="02a07132b0fbb4f8fe6afeb3cd55176e"></a><!-- doxytag: member="dmat.h::dcell2m" ref="02a07132b0fbb4f8fe6afeb3cd55176e" args="(const dcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dcell2m           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a block matrix to a matrix. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00569"></a>00569                                    {
<a name="l00570"></a>00570     X(mat) *(*Ap)[A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>] = (X(mat) *(*)[A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>])A-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>;
<a name="l00571"></a>00571     <span class="keywordtype">long</span> nx,ny,*nxs,*nys;
<a name="l00572"></a>00572     X(celldim)(A,&amp;nx,&amp;ny,&amp;nxs,&amp;nys);
<a name="l00573"></a>00573     X(mat) *out=X(<span class="keyword">new</span>)(nx,ny);
<a name="l00574"></a>00574     <span class="keywordtype">long</span> jcol=0;
<a name="l00575"></a>00575     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; iy++){
<a name="l00576"></a>00576     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;nys[iy]; icol++){
<a name="l00577"></a>00577         <span class="keywordtype">long</span> kr=0;
<a name="l00578"></a>00578         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>; ix++){
<a name="l00579"></a>00579         <span class="keywordflow">if</span>(Ap[iy][ix]){
<a name="l00580"></a>00580             memcpy(out-&gt;p+((icol+jcol)*nx+kr),
<a name="l00581"></a>00581                Ap[iy][ix]-&gt;p+icol*nxs[ix],
<a name="l00582"></a>00582                nxs[ix]*<span class="keyword">sizeof</span>(T));
<a name="l00583"></a>00583         }
<a name="l00584"></a>00584         kr+=nxs[ix];
<a name="l00585"></a>00585         }
<a name="l00586"></a>00586     }
<a name="l00587"></a>00587     jcol+=nys[iy];
<a name="l00588"></a>00588     }
<a name="l00589"></a>00589     free(nxs);
<a name="l00590"></a>00590     free(nys);
<a name="l00591"></a>00591     <span class="keywordflow">return</span> out;
<a name="l00592"></a>00592 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5f5443ca322b4ed2cb65a24e638f928e"></a><!-- doxytag: member="dmat.h::d2cellref" ref="5f5443ca322b4ed2cb65a24e638f928e" args="(const dmat *A, int *dims, int ndim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* d2cellref           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
convert a vector to cell using dimensions specified in dims. 
<p>
Reference the vector <div class="fragment"><pre class="fragment"><a name="l00597"></a>00597                                                          {
<a name="l00598"></a>00598     <span class="keywordtype">long</span> nx=0;
<a name="l00599"></a>00599     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;ndim; ix++){
<a name="l00600"></a>00600     nx+=dims[ix];
<a name="l00601"></a>00601     }
<a name="l00602"></a>00602     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>!=1){
<a name="l00603"></a>00603     error(<span class="stringliteral">"Use d2cell2 instead for non vectors\n"</span>);
<a name="l00604"></a>00604     }
<a name="l00605"></a>00605     <span class="keywordflow">if</span>(nx!=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> ){
<a name="l00606"></a>00606     error(<span class="stringliteral">"Shape doesn't agree. nx=%ld, nx=%ld\n"</span>, nx,A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>);
<a name="l00607"></a>00607     }
<a name="l00608"></a>00608     <span class="keywordtype">long</span> kr=0;
<a name="l00609"></a>00609     X(cell) *B=X(cellnew)(ndim,1);
<a name="l00610"></a>00610     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;ndim; ix++){
<a name="l00611"></a>00611     B-&gt;p[ix]=X(new_ref)(A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>+kr,dims[ix],1);<span class="comment">//refrence the data. </span>
<a name="l00612"></a>00612     kr+=dims[ix];
<a name="l00613"></a>00613     }
<a name="l00614"></a>00614     <span class="keywordflow">return</span> B;
<a name="l00615"></a>00615 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bed4b3e507a4bb20689c0fce64de6c0a"></a><!-- doxytag: member="dmat.h::d2cell" ref="bed4b3e507a4bb20689c0fce64de6c0a" args="(dcell **B, const dmat *A, const dcell *ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void d2cell           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>ref</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
make A a cell array using shape information from ref if *B is NULL 
<p>
<div class="fragment"><pre class="fragment"><a name="l00620"></a>00620                                                                {
<a name="l00621"></a>00621     <span class="keywordtype">long</span> nx,ny,*nxs,*nys;
<a name="l00622"></a>00622     <span class="keywordflow">if</span>(*B) ref=*B;<span class="comment">//use B as reference.</span>
<a name="l00623"></a>00623     X(celldim)(ref, &amp;nx, &amp;ny, &amp;nxs, &amp;nys);
<a name="l00624"></a>00624     <span class="keywordflow">if</span>(nx!=A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a> || ny!=A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>){
<a name="l00625"></a>00625     error(<span class="stringliteral">"Shape doesn't agree. Reference is %ldx%ld but input is %ldx%ld\n"</span>,
<a name="l00626"></a>00626           nx,ny,A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>,A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l00627"></a>00627     }
<a name="l00628"></a>00628     <span class="keywordflow">if</span>(!*B){
<a name="l00629"></a>00629     *B=X(cellnew)(ref-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>, ref-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>);
<a name="l00630"></a>00630     PCELL((*B),Bp);
<a name="l00631"></a>00631     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;ref-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; iy++){
<a name="l00632"></a>00632         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;ref-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>; ix++){
<a name="l00633"></a>00633         Bp[iy][ix]=X(<span class="keyword">new</span>)(nxs[ix],nys[iy]);
<a name="l00634"></a>00634         }
<a name="l00635"></a>00635     }
<a name="l00636"></a>00636     }
<a name="l00637"></a>00637     PCELL((*B),Bp);
<a name="l00638"></a>00638     <span class="keywordtype">long</span> jcol=0;
<a name="l00639"></a>00639     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;ref-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; iy++){
<a name="l00640"></a>00640     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;nys[iy]; icol++){
<a name="l00641"></a>00641         <span class="keywordtype">long</span> kr=0;
<a name="l00642"></a>00642         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;ref-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>; ix++){
<a name="l00643"></a>00643         <span class="keywordflow">if</span>(nxs[ix]&gt;0){
<a name="l00644"></a>00644             memcpy(Bp[iy][ix]-&gt;p+icol*Bp[iy][ix]-&gt;nx,
<a name="l00645"></a>00645                A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>+((icol+jcol)*nx+kr),
<a name="l00646"></a>00646                nxs[ix]*<span class="keyword">sizeof</span>(T));
<a name="l00647"></a>00647             kr+=nxs[ix];
<a name="l00648"></a>00648         }
<a name="l00649"></a>00649         }
<a name="l00650"></a>00650     }
<a name="l00651"></a>00651     jcol+=nys[iy];
<a name="l00652"></a>00652     }
<a name="l00653"></a>00653     free(nxs);
<a name="l00654"></a>00654     free(nys);
<a name="l00655"></a>00655 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4e9d5e166621f79342478304769a43fc"></a><!-- doxytag: member="dmat.h::dcelldropzero" ref="4e9d5e166621f79342478304769a43fc" args="(dcell *B, double thres)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcelldropzero           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>thres</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
drop empty blocks (zero). 
<p>
Size of B is not modified. <div class="fragment"><pre class="fragment"><a name="l00660"></a>00660                                               {
<a name="l00661"></a>00661     PCELL(B,Bp);
<a name="l00662"></a>00662     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;B-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; iy++){
<a name="l00663"></a>00663     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;B-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>; ix++){
<a name="l00664"></a>00664         X(mat) *tmp=Bp[iy][ix];
<a name="l00665"></a>00665         <span class="keywordflow">if</span>(!tmp) <span class="keywordflow">continue</span>;
<a name="l00666"></a>00666         <span class="keywordtype">int</span> hasnonzero=0;
<a name="l00667"></a>00667         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ixy=0; ixy&lt;tmp-&gt;nx*tmp-&gt;ny; ixy++){
<a name="l00668"></a>00668         <span class="keywordflow">if</span>(ABS(tmp-&gt;p[ixy])&gt;thres){
<a name="l00669"></a>00669             hasnonzero=1;
<a name="l00670"></a>00670             <span class="keywordflow">break</span>;
<a name="l00671"></a>00671         }
<a name="l00672"></a>00672         }
<a name="l00673"></a>00673         <span class="keywordflow">if</span>(!hasnonzero){
<a name="l00674"></a>00674         X(free)(Bp[iy][ix]);
<a name="l00675"></a>00675         Bp[iy][ix]=NULL;
<a name="l00676"></a>00676         <span class="comment">//warning("Dropped block (%ld, %ld)\n", ix, iy);</span>
<a name="l00677"></a>00677         }
<a name="l00678"></a>00678     }
<a name="l00679"></a>00679     }
<a name="l00680"></a>00680 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ce747978615516a6c46a9dc7b823cdde"></a><!-- doxytag: member="dmat.h::dcelldiff" ref="ce747978615516a6c46a9dc7b823cdde" args="(const dcell *A, const dcell *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dcelldiff           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute ||A-B||/||A|| use mean. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00686"></a>00686                                                       {
<a name="l00687"></a>00687     X(cell) *C=NULL;
<a name="l00688"></a>00688     X(cellcp)(&amp;C,A);
<a name="l00689"></a>00689     X(celladd)(&amp;C,1,B,-1);
<a name="l00690"></a>00690     <span class="keywordtype">double</span> d=sqrt(X(cellnorm2)(C)*2/(X(cellnorm2)(C)+X(cellnorm2)(B)));
<a name="l00691"></a>00691     <span class="keywordflow">return</span> isnan(d)?0:d;
<a name="l00692"></a>00692 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ba0fbb0b2f60c70c1aeff1921ad82b24"></a><!-- doxytag: member="dmat.h::dcellclip" ref="ba0fbb0b2f60c70c1aeff1921ad82b24" args="(dcell *Ac, double min, double max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dcellclip           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>Ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
clip a X(cell) array to max at 'max', min at 'min' 
<p>
<div class="fragment"><pre class="fragment"><a name="l00697"></a>00697                                                     {
<a name="l00698"></a>00698     <span class="keywordflow">if</span>(!Ac || !Ac-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>) <span class="keywordflow">return</span> 0;
<a name="l00699"></a>00699     <span class="keywordflow">if</span>(isinf(min)==-1 &amp;&amp; isinf(max)==1) <span class="keywordflow">return</span> 0;
<a name="l00700"></a>00700     <span class="keywordtype">int</span> nclip=0;
<a name="l00701"></a>00701     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;Ac-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>*Ac-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; i++){
<a name="l00702"></a>00702     nclip+=X(clip)(Ac-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[i],min,max);
<a name="l00703"></a>00703     }
<a name="l00704"></a>00704     <span class="keywordflow">return</span> nclip;
<a name="l00705"></a>00705 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8f5e44c289528e1cfecabe114bf98253"></a><!-- doxytag: member="dmat.h::dcelltikcr" ref="8f5e44c289528e1cfecabe114bf98253" args="(dcell *A, double thres)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcelltikcr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>thres</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply tickholov regularization of relative thres to cell array by converting it to mat. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00711"></a>00711                                            {
<a name="l00712"></a>00712     X(mat) *Ab=X(cell2m)(A);
<a name="l00713"></a>00713     X(tikcr)(Ab,thres);
<a name="l00714"></a>00714     X(2cell)(&amp;A,Ab,NULL);
<a name="l00715"></a>00715     X(free)(Ab);
<a name="l00716"></a>00716 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ed4f051cb2e11032d42d5e91e08f0f99"></a><!-- doxytag: member="dmat.h::dcelladdI" ref="ed4f051cb2e11032d42d5e91e08f0f99" args="(dcell *A, double a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcelladdI           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add a to diagonal elements of A; 
<p>
<div class="fragment"><pre class="fragment"><a name="l00798"></a>00798                                       {
<a name="l00799"></a>00799     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>!=A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>) 
<a name="l00800"></a>00800     error(<span class="stringliteral">"A must be symmetric\n"</span>);
<a name="l00801"></a>00801     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ib=0; ib&lt;A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>; ib++){
<a name="l00802"></a>00802     X(addI)(A-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[ib+ib*A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>], a);
<a name="l00803"></a>00803     }
<a name="l00804"></a>00804 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="68953d78fbcaa6533fdd78b6b6513243"></a><!-- doxytag: member="dmat.h::dcellsvd_pow" ref="68953d78fbcaa6533fdd78b6b6513243" args="(dcell *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellsvd_pow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the power of a block matrix using svd method. 
<p>
First convert it do X(mat), do the power, and convert back to block matrix. <div class="fragment"><pre class="fragment"><a name="l00810"></a>00810                                              {
<a name="l00811"></a>00811     X(mat) *Ac=X(cell2m)(A);
<a name="l00812"></a>00812     X(svd_pow)(Ac, power);
<a name="l00813"></a>00813     X(2cell)(&amp;A, Ac, NULL);
<a name="l00814"></a>00814     X(free)(Ac);
<a name="l00815"></a>00815 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="279fb443e6febe18586edcb53359cf5b"></a><!-- doxytag: member="dmat.h::dcellcwpow" ref="279fb443e6febe18586edcb53359cf5b" args="(dcell *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellcwpow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
raise each cell in the cell array to power of power. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00820"></a>00820                                           {
<a name="l00821"></a>00821     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ib=0; ib&lt;A-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>*A-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>; ib++){
<a name="l00822"></a>00822     X(cwpow)(A-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[ib],power);
<a name="l00823"></a>00823     }
<a name="l00824"></a>00824 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3452afc53eefe2391f8720999be80c19"></a><!-- doxytag: member="dmat.h::dwritedata" ref="3452afc53eefe2391f8720999be80c19" args="(file_t *fp, const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dwritedata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contains routines to write/read dense/sparse matrix into/from file. 
<p>
Function to write dense matrix data into a file pointer. Generally used by library developer <div class="fragment"><pre class="fragment"><a name="l00052"></a>00052                                               {
<a name="l00053"></a>00053     <span class="keywordtype">void</span> *p=NULL;
<a name="l00054"></a>00054     uint64_t nx=0, ny=0;
<a name="l00055"></a>00055     <span class="keywordflow">if</span>(A){
<a name="l00056"></a>00056     p=A-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00057"></a>00057     nx=(uint64_t)A-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l00058"></a>00058     ny=(uint64_t)A-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>;
<a name="l00059"></a>00059     }
<a name="l00060"></a>00060     <a class="code" href="bin_8c.html#1604f7a3a2eb8ec34d8d22c063458613" title="Write an 1-d or 2-d array into the file.">do_write</a>(fp, 0, <span class="keyword">sizeof</span>(T), M_T, p, nx, ny);
<a name="l00061"></a>00061 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9a8e4a59501eeb3bdd87e490ff04d0e7"></a><!-- doxytag: member="dmat.h::dcellwritedata" ref="9a8e4a59501eeb3bdd87e490ff04d0e7" args="(file_t *fp, const dcell *dc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellwritedata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to write cell array of dense matrix data. 
<p>
into a file pointer Generally used by library developer <div class="fragment"><pre class="fragment"><a name="l00066"></a>00066                                                     {
<a name="l00067"></a>00067     uint32_t magic=MC_T;
<a name="l00068"></a>00068     <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(&amp;magic, <span class="keyword">sizeof</span>(uint32_t), 1, fp);
<a name="l00069"></a>00069     <span class="keywordflow">if</span>(!dc){
<a name="l00070"></a>00070     uint64_t zero=0;
<a name="l00071"></a>00071     <a class="code" href="bin_8c.html#661981dba53025cce58eb981094679b7" title="Write multiple long numbers into the file.">zfwritelarr</a>(fp, 2, &amp;zero, &amp;zero);
<a name="l00072"></a>00072     }<span class="keywordflow">else</span>{
<a name="l00073"></a>00073     uint64_t nx=dc-&gt;<a class="code" href="structdcell.html#c88fed44e9f978c6757ec8dfcfb31589" title="number of rows">nx</a>;
<a name="l00074"></a>00074     uint64_t ny=dc-&gt;<a class="code" href="structdcell.html#cd7579d2c13ae676bbfba099ae78b35c" title="number of columns">ny</a>;
<a name="l00075"></a>00075     <a class="code" href="bin_8c.html#661981dba53025cce58eb981094679b7" title="Write multiple long numbers into the file.">zfwritelarr</a>(fp, 2, &amp;nx, &amp;ny);
<a name="l00076"></a>00076     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> iy=0; iy&lt;ny; iy++){
<a name="l00077"></a>00077         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ix=0; ix&lt;nx; ix++){
<a name="l00078"></a>00078         X(writedata)(fp, dc-&gt;<a class="code" href="structdcell.html#c6bfb5d224d69b6fa412f4e84b550d6f" title="Contains an array of pointers to dmat.">p</a>[ix+iy*nx]);
<a name="l00079"></a>00079         }
<a name="l00080"></a>00080     }
<a name="l00081"></a>00081     }
<a name="l00082"></a>00082 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f9c045fc5554493f577bb51a30bd620c"></a><!-- doxytag: member="dmat.h::dreaddata" ref="f9c045fc5554493f577bb51a30bd620c" args="(file_t *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dreaddata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to read dense matrix into memory from file pointer. 
<p>
Generally used by library developer. <div class="fragment"><pre class="fragment"><a name="l00105"></a>00105                                {
<a name="l00106"></a>00106     uint32_t magic;
<a name="l00107"></a>00107     <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(&amp;magic, <span class="keyword">sizeof</span>(uint32_t),1,fp);
<a name="l00108"></a>00108     <span class="keywordflow">if</span>(magic!=M_T)
<a name="l00109"></a>00109     error(<span class="stringliteral">"This is not a X(mat) file\n"</span>);
<a name="l00110"></a>00110     uint64_t nx,ny;
<a name="l00111"></a>00111     <a class="code" href="bin_8c.html#f2343993fa331cbf30672791bdf90e7d" title="Read multiple long numbers from the file.">zfreadlarr</a>(fp, 2, &amp;nx, &amp;ny);
<a name="l00112"></a>00112     X(mat) *out;
<a name="l00113"></a>00113     <span class="keywordflow">if</span>(nx==0 || ny==0)
<a name="l00114"></a>00114     out=NULL;
<a name="l00115"></a>00115     <span class="keywordflow">else</span>{
<a name="l00116"></a>00116     out=X(<span class="keyword">new</span>)((long)nx,(<span class="keywordtype">long</span>)ny);
<a name="l00117"></a>00117     <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(out-&gt;p,<span class="keyword">sizeof</span>(T),nx*ny,fp);
<a name="l00118"></a>00118     }
<a name="l00119"></a>00119     <span class="keywordflow">return</span> out;
<a name="l00120"></a>00120 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f7d37cf8830abee2f6a43a6455e81f86"></a><!-- doxytag: member="dmat.h::dcellreaddata" ref="f7d37cf8830abee2f6a43a6455e81f86" args="(file_t *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellreaddata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to read dense matrix cell array into memory from file pointer. 
<p>
Generally used by library developer. <div class="fragment"><pre class="fragment"><a name="l00124"></a>00124                                     {
<a name="l00125"></a>00125     uint32_t magic;
<a name="l00126"></a>00126     <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(&amp;magic, <span class="keyword">sizeof</span>(uint32_t), 1, fp);
<a name="l00127"></a>00127     <span class="keywordflow">if</span>(magic!=MC_T)
<a name="l00128"></a>00128     error(<span class="stringliteral">"This is is not a X(mat) cell file. want %d, get %d\n"</span>,(<span class="keywordtype">int</span>)MC_T,(<span class="keywordtype">int</span>)magic);
<a name="l00129"></a>00129     uint64_t nx,ny;
<a name="l00130"></a>00130     <a class="code" href="bin_8c.html#f2343993fa331cbf30672791bdf90e7d" title="Read multiple long numbers from the file.">zfreadlarr</a>(fp, 2, &amp;nx, &amp;ny);
<a name="l00131"></a>00131     X(cell) *out;
<a name="l00132"></a>00132     <span class="keywordflow">if</span>(nx==0 || ny==0)
<a name="l00133"></a>00133     out=NULL;
<a name="l00134"></a>00134     <span class="keywordflow">else</span>{
<a name="l00135"></a>00135     out=X(cellnew)((long)nx,(<span class="keywordtype">long</span>)ny);
<a name="l00136"></a>00136     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ix=0; ix&lt;nx*ny; ix++){
<a name="l00137"></a>00137         out-&gt;p[ix]=X(readdata)(fp);
<a name="l00138"></a>00138     }
<a name="l00139"></a>00139     }
<a name="l00140"></a>00140     <span class="keywordflow">return</span> out;
<a name="l00141"></a>00141 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="21964c0cee9cb479b21ad2227a9a60dc"></a><!-- doxytag: member="dmat.h::spwritedata" ref="21964c0cee9cb479b21ad2227a9a60dc" args="(file_t *fp, const dsp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spwritedata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to write sparse matrix data into file pointed using a file pointer. 
<p>
Generally used by library developer. <div class="fragment"><pre class="fragment"><a name="l00169"></a>00169                                                 {
<a name="l00170"></a>00170     uint32_t magic=M_SPT;
<a name="l00171"></a>00171     <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(&amp;magic, <span class="keyword">sizeof</span>(uint32_t),1,fp);
<a name="l00172"></a>00172     <span class="keywordflow">if</span>(sp){
<a name="l00173"></a>00173     uint64_t m,n,nzmax;
<a name="l00174"></a>00174     m=sp-&gt;<a class="code" href="structdsp.html#41a5578612c657ab47e06b921e6b1948" title="number of rows">m</a>;
<a name="l00175"></a>00175     n=sp-&gt;<a class="code" href="structdsp.html#f5ae33e67862e20cfc580ac361ca3e30" title="number of columns">n</a>;
<a name="l00176"></a>00176     nzmax=sp-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[n];<span class="comment">//don't use sp-&gt;nzmax, which maybe larger than actual</span>
<a name="l00177"></a>00177     <a class="code" href="bin_8c.html#661981dba53025cce58eb981094679b7" title="Write multiple long numbers into the file.">zfwritelarr</a>(fp, 3, &amp;m, &amp;n, &amp;nzmax);
<a name="l00178"></a>00178     <span class="keywordflow">if</span>(<span class="keyword">sizeof</span>(*sp-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>)!=<span class="keyword">sizeof</span>(uint64_t)){
<a name="l00179"></a>00179         <span class="comment">//need to convert data</span>
<a name="l00180"></a>00180         warning(<span class="stringliteral">"Converting data in spwritedata\n"</span>);
<a name="l00181"></a>00181         uint64_t *p,*i;
<a name="l00182"></a>00182         p=malloc(<span class="keyword">sizeof</span>(uint64_t)*(n+1));
<a name="l00183"></a>00183         i=malloc(<span class="keyword">sizeof</span>(uint64_t)*(nzmax));
<a name="l00184"></a>00184         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> j=0; j&lt;n+1; j++){
<a name="l00185"></a>00185         p[j]=sp-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a>[j];
<a name="l00186"></a>00186         }
<a name="l00187"></a>00187         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> j=0; j&lt;nzmax; j++){
<a name="l00188"></a>00188         i[j]=sp-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a>[j];
<a name="l00189"></a>00189         }
<a name="l00190"></a>00190         <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(p ,<span class="keyword">sizeof</span>(uint64_t),n+1,fp);
<a name="l00191"></a>00191         <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(i ,<span class="keyword">sizeof</span>(uint64_t),nzmax,fp);
<a name="l00192"></a>00192         free(p); free(i);
<a name="l00193"></a>00193     }<span class="keywordflow">else</span>{
<a name="l00194"></a>00194         <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(sp-&gt;<a class="code" href="structdsp.html#a9f3db1d7c4d321157e4efac11f3351a" title="column pointers (size n+1) or col indlces (size nzmax) when nz!=-1">p</a> ,<span class="keyword">sizeof</span>(uint64_t),n+1,fp);
<a name="l00195"></a>00195         <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(sp-&gt;<a class="code" href="structdsp.html#1d87a5584935632deb8bf23ea8eb46bf" title="row indices, size nzmax">i</a> ,<span class="keyword">sizeof</span>(uint64_t),nzmax,fp);
<a name="l00196"></a>00196     }
<a name="l00197"></a>00197     <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(sp-&gt;<a class="code" href="structdsp.html#72f5e4eabdf69453be2ec0708558f023" title="numerical values, size nzmax">x</a> ,<span class="keyword">sizeof</span>(T),nzmax,fp);  
<a name="l00198"></a>00198     }<span class="keywordflow">else</span>{
<a name="l00199"></a>00199     uint64_t zero=0;
<a name="l00200"></a>00200     <a class="code" href="bin_8c.html#661981dba53025cce58eb981094679b7" title="Write multiple long numbers into the file.">zfwritelarr</a>(fp, 2, &amp;zero, &amp;zero);
<a name="l00201"></a>00201     }
<a name="l00202"></a>00202 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9d9de86adc0703c3b1eeddc552e9b309"></a><!-- doxytag: member="dmat.h::spreaddata" ref="9d9de86adc0703c3b1eeddc552e9b309" args="(file_t *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spreaddata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to read sparse matrix data from file pointer into memory. 
<p>
Used by library developer. <div class="fragment"><pre class="fragment"><a name="l00207"></a>00207                                 {
<a name="l00208"></a>00208     uint32_t magic;
<a name="l00209"></a>00209     <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(&amp;magic, <span class="keyword">sizeof</span>(uint32_t),1,fp);
<a name="l00210"></a>00210     <span class="keywordflow">if</span>(magic!=M_SPT){
<a name="l00211"></a>00211     error(<span class="stringliteral">"This is not a sparse matrix file\n"</span>);
<a name="l00212"></a>00212     }
<a name="l00213"></a>00213     uint64_t m,n,nzmax;
<a name="l00214"></a>00214     <a class="code" href="bin_8c.html#f2343993fa331cbf30672791bdf90e7d" title="Read multiple long numbers from the file.">zfreadlarr</a>(fp, 2, &amp;m, &amp;n);
<a name="l00215"></a>00215     X(sp) *out;
<a name="l00216"></a>00216     <span class="keywordflow">if</span>(m==0 || n==0){
<a name="l00217"></a>00217     out=0;
<a name="l00218"></a>00218     }<span class="keywordflow">else</span>{
<a name="l00219"></a>00219     uint64_t *p;
<a name="l00220"></a>00220     uint64_t *i;
<a name="l00221"></a>00221     <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(&amp;nzmax,<span class="keyword">sizeof</span>(uint64_t),1,fp);
<a name="l00222"></a>00222     out=Y(spnew)(m,n,nzmax);
<a name="l00223"></a>00223     <span class="keywordflow">if</span>(<span class="keyword">sizeof</span>(*out-&gt;p)==<span class="keyword">sizeof</span>(uint64_t)){
<a name="l00224"></a>00224         p=(uint64_t*)out-&gt;p;
<a name="l00225"></a>00225         i=(uint64_t*)out-&gt;i;
<a name="l00226"></a>00226         <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(p, <span class="keyword">sizeof</span>(uint64_t),n+1, fp);
<a name="l00227"></a>00227         <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(i, <span class="keyword">sizeof</span>(uint64_t),nzmax, fp);
<a name="l00228"></a>00228     }<span class="keywordflow">else</span>{
<a name="l00229"></a>00229         p=malloc(<span class="keyword">sizeof</span>(uint64_t)*(n+1));
<a name="l00230"></a>00230         i=malloc(<span class="keyword">sizeof</span>(uint64_t)*(nzmax));
<a name="l00231"></a>00231         <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(p, <span class="keyword">sizeof</span>(uint64_t),n+1, fp);
<a name="l00232"></a>00232         <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(i, <span class="keyword">sizeof</span>(uint64_t),nzmax, fp);
<a name="l00233"></a>00233         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> j=0; j&lt;n+1; j++){
<a name="l00234"></a>00234         out-&gt;p[j]=p[j];
<a name="l00235"></a>00235         }
<a name="l00236"></a>00236         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> j=0; j&lt;nzmax; j++){
<a name="l00237"></a>00237         out-&gt;i[j]=i[j];
<a name="l00238"></a>00238         }
<a name="l00239"></a>00239         free(p);
<a name="l00240"></a>00240         free(i);
<a name="l00241"></a>00241     }
<a name="l00242"></a>00242     <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(out-&gt;x, <span class="keyword">sizeof</span>(T),nzmax, fp);
<a name="l00243"></a>00243     }
<a name="l00244"></a>00244     <span class="keywordflow">return</span> out;
<a name="l00245"></a>00245 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="37ebad9e8c582e694664b562a78114d2"></a><!-- doxytag: member="dmat.h::dwrite" ref="37ebad9e8c582e694664b562a78114d2" args="(const dmat *A, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write dense matrix into a file. 
<p>
Usage: dwrite(A,"A") for double matrix. <div class="fragment"><pre class="fragment"><a name="l00087"></a>00087                                                       {
<a name="l00088"></a>00088     format2fn;
<a name="l00089"></a>00089     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"wb"</span>);
<a name="l00090"></a>00090     X(writedata)(fp, A);
<a name="l00091"></a>00091     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l00092"></a>00092 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="70cd951a3932002ccc9270944d2005ec"></a><!-- doxytag: member="dmat.h::dcellwrite" ref="70cd951a3932002ccc9270944d2005ec" args="(const dcell *dc, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write cell array of dense matrix into a file. 
<p>
Usage: dcellwrite(A,"A.bin.gz") for double matrix cell. <div class="fragment"><pre class="fragment"><a name="l00096"></a>00096                                                             {
<a name="l00097"></a>00097     format2fn;
<a name="l00098"></a>00098     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"wb"</span>);
<a name="l00099"></a>00099     X(cellwritedata)(fp,dc);
<a name="l00100"></a>00100     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l00101"></a>00101 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6406403e91ec976bb0d6c2e12b5d5a0f"></a><!-- doxytag: member="dmat.h::dread" ref="6406403e91ec976bb0d6c2e12b5d5a0f" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read dense matrix into memory from file. 
<p>
Usage: A=dread("A.bin.gz"); for a <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> <div class="fragment"><pre class="fragment"><a name="l00145"></a>00145                                        {
<a name="l00146"></a>00146     format2fn;
<a name="l00147"></a>00147     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"rb"</span>);
<a name="l00148"></a>00148     X(mat) *out=X(readdata)(fp);
<a name="l00149"></a>00149     <a class="code" href="bin_8c.html#fb7723b26befc0c6f2a95a7e1a516201" title="Tell whether we end of file is reached.">zfeof</a>(fp);
<a name="l00150"></a>00150     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l00151"></a>00151     <span class="keywordflow">return</span> out;
<a name="l00152"></a>00152 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dfec4b5637fce6a1cdb10b84d744c8fe"></a><!-- doxytag: member="dmat.h::dcellread" ref="dfec4b5637fce6a1cdb10b84d744c8fe" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read cell array of dense matrix into memory from file. 
<p>
Usage: A=dcellread("A.bin.gz"); for a double <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>. <div class="fragment"><pre class="fragment"><a name="l00157"></a>00157                                             {
<a name="l00158"></a>00158     format2fn;
<a name="l00159"></a>00159     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"rb"</span>);
<a name="l00160"></a>00160     X(cell) *out=X(cellreaddata)(fp);
<a name="l00161"></a>00161     <a class="code" href="bin_8c.html#fb7723b26befc0c6f2a95a7e1a516201" title="Tell whether we end of file is reached.">zfeof</a>(fp);
<a name="l00162"></a>00162     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l00163"></a>00163     <span class="keywordflow">return</span> out;
<a name="l00164"></a>00164 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="779cefb17e24b648212cc59f9324f5ae"></a><!-- doxytag: member="dmat.h::spwrite" ref="779cefb17e24b648212cc59f9324f5ae" args="(const dsp *sp, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write sparse matrix into file. 
<p>
Usage: spwrite(A,"A.bin.gz"); <div class="fragment"><pre class="fragment"><a name="l00252"></a>00252                                                         {
<a name="l00253"></a>00253     format2fn;
<a name="l00254"></a>00254     <span class="comment">//write the sparse matrix to file to later load from matlab</span>
<a name="l00255"></a>00255     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"wb"</span>);
<a name="l00256"></a>00256     Y(spwritedata)(fp, sp);
<a name="l00257"></a>00257     <span class="comment">//don't worry about the warning of 0x401ee45 in valgrind. That is the IO </span>
<a name="l00258"></a>00258     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l00259"></a>00259 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="fa58b8e2aea2a94ae0422ede37957a0f"></a><!-- doxytag: member="dmat.h::spcellwrite" ref="fa58b8e2aea2a94ae0422ede37957a0f" args="(const spcell *spc, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write cell array of sparse matrix into file. 
<p>
Usage: spcellwrite(A,"A.bin.gz"); <div class="fragment"><pre class="fragment"><a name="l00264"></a>00264                                                                  {
<a name="l00265"></a>00265     format2fn;
<a name="l00266"></a>00266     uint32_t magic=MC_SPT;
<a name="l00267"></a>00267     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"wb"</span>);
<a name="l00268"></a>00268     <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(&amp;magic, <span class="keyword">sizeof</span>(uint32_t), 1, fp);
<a name="l00269"></a>00269     <span class="keywordflow">if</span>(spc){
<a name="l00270"></a>00270     uint64_t nx=spc-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>;
<a name="l00271"></a>00271     uint64_t ny=spc-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>;
<a name="l00272"></a>00272     <a class="code" href="bin_8c.html#661981dba53025cce58eb981094679b7" title="Write multiple long numbers into the file.">zfwritelarr</a>(fp, 2, &amp;nx, &amp;ny);
<a name="l00273"></a>00273     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> iy=0; iy&lt;spc-&gt;<a class="code" href="structspcell.html#0758b8001e69d1c246adfbe94bbf101c" title="number of columns">ny</a>; iy++){
<a name="l00274"></a>00274         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ix=0; ix&lt;spc-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>; ix++){
<a name="l00275"></a>00275         Y(spwritedata)(fp, spc-&gt;<a class="code" href="structspcell.html#43b142bc607510084f627498b7b0431b" title="Contains an array of pointers to dsp.">p</a>[ix+iy*spc-&gt;<a class="code" href="structspcell.html#ba098ee8e31aa0222beb2c25c9ab1e3a" title="number of rows">nx</a>]);
<a name="l00276"></a>00276         }
<a name="l00277"></a>00277     }
<a name="l00278"></a>00278     }<span class="keywordflow">else</span>{
<a name="l00279"></a>00279     uint64_t zero=0;
<a name="l00280"></a>00280     <a class="code" href="bin_8c.html#661981dba53025cce58eb981094679b7" title="Write multiple long numbers into the file.">zfwritelarr</a>(fp, 2, &amp;zero, &amp;zero);
<a name="l00281"></a>00281     }
<a name="l00282"></a>00282     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l00283"></a>00283 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="06bbd169953a4a808c647bd0a9e6f0d3"></a><!-- doxytag: member="dmat.h::spread" ref="06bbd169953a4a808c647bd0a9e6f0d3" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read sparse metrix from file. 
<p>
Usage: A=spread("A.bin.gz"); <div class="fragment"><pre class="fragment"><a name="l00288"></a>00288                                         {
<a name="l00289"></a>00289     format2fn;
<a name="l00290"></a>00290     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"rb"</span>);
<a name="l00291"></a>00291     X(sp) *out=Y(spreaddata)(fp);
<a name="l00292"></a>00292     <a class="code" href="bin_8c.html#fb7723b26befc0c6f2a95a7e1a516201" title="Tell whether we end of file is reached.">zfeof</a>(fp);
<a name="l00293"></a>00293     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l00294"></a>00294     <span class="keywordflow">return</span> out;
<a name="l00295"></a>00295 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dda41e6426ecac836fa3dd576f0d2bd9"></a><!-- doxytag: member="dmat.h::spcellread" ref="dda41e6426ecac836fa3dd576f0d2bd9" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspcell.html">spcell</a>* spcellread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read cell array of sparse matrix from file. 
<p>
Usage: A=spcellread("A.bin.gz"); <div class="fragment"><pre class="fragment"><a name="l00300"></a>00300                                                 {
<a name="l00301"></a>00301     format2fn;
<a name="l00302"></a>00302     uint32_t magic;
<a name="l00303"></a>00303     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"rb"</span>);
<a name="l00304"></a>00304     <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(&amp;magic, <span class="keyword">sizeof</span>(uint32_t), 1, fp);
<a name="l00305"></a>00305     <span class="keywordflow">if</span>(magic!=MC_SPT)
<a name="l00306"></a>00306     error(<span class="stringliteral">"%s is not a sparse cell file. want %d, got %u\n"</span>, fn,
<a name="l00307"></a>00307           MC_SPT, magic);
<a name="l00308"></a>00308     uint64_t nx,ny;
<a name="l00309"></a>00309     <a class="code" href="bin_8c.html#f2343993fa331cbf30672791bdf90e7d" title="Read multiple long numbers from the file.">zfreadlarr</a>(fp, 2, &amp;nx, &amp;ny);
<a name="l00310"></a>00310     Y(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>) *out;
<a name="l00311"></a>00311     <span class="keywordflow">if</span>(nx==0 || ny==0)
<a name="l00312"></a>00312     out=NULL;
<a name="l00313"></a>00313     <span class="keywordflow">else</span>{
<a name="l00314"></a>00314     out=Y(spcellnew)(nx,ny);
<a name="l00315"></a>00315     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ix=0; ix&lt;nx*ny; ix++){
<a name="l00316"></a>00316         out-&gt;p[ix]=Y(spreaddata)(fp);
<a name="l00317"></a>00317     }
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319     <a class="code" href="bin_8c.html#fb7723b26befc0c6f2a95a7e1a516201" title="Tell whether we end of file is reached.">zfeof</a>(fp);
<a name="l00320"></a>00320     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l00321"></a>00321     <span class="keywordflow">return</span> out;
<a name="l00322"></a>00322 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="316507e4c46251f724a2c22f1db76353"></a><!-- doxytag: member="dmat.h::dnew_mmap" ref="316507e4c46251f724a2c22f1db76353" args="(long nx, long ny, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dnew_mmap           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(mat) matrix object, mmapped from file. 
<p>
be aware that the data is not 8-byte aligned. The file is truncated if already exists. <div class="fragment"><pre class="fragment"><a name="l00352"></a>00352                                                               {
<a name="l00353"></a>00353     <span class="keywordflow">if</span>(!nx || !ny) <span class="keywordflow">return</span> NULL;
<a name="l00354"></a>00354     format2fn;
<a name="l00355"></a>00355     <span class="keywordtype">int</span> fd=mmap_open(fn);
<a name="l00356"></a>00356     <span class="keywordtype">size_t</span> headersize=2*<span class="keyword">sizeof</span>(long)+<span class="keyword">sizeof</span>(uint32_t);
<a name="l00357"></a>00357     <span class="keywordtype">size_t</span> msize=nx*ny*<span class="keyword">sizeof</span>(T)+headersize;
<a name="l00358"></a>00358     <span class="keywordflow">if</span>(ftruncate(fd, msize)){
<a name="l00359"></a>00359     error(<span class="stringliteral">"Error truncating file\n"</span>);
<a name="l00360"></a>00360     }
<a name="l00361"></a>00361     <span class="keywordtype">char</span> *map=mmap(NULL, msize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
<a name="l00362"></a>00362     memset(map, 0, msize);
<a name="l00363"></a>00363     close(fd);
<a name="l00364"></a>00364     mmap_header(map, M_T, nx, ny);
<a name="l00365"></a>00365     X(mat) *out=X(new_data)((T*)(map+headersize), nx, ny);
<a name="l00366"></a>00366     out-&gt;type=MT_MMAP;
<a name="l00367"></a>00367     <span class="keywordflow">return</span> out;
<a name="l00368"></a>00368 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a3b557cdaaf833c08dba873203894db5"></a><!-- doxytag: member="dmat.h::dcellnew_mmap" ref="a3b557cdaaf833c08dba873203894db5" args="(long nx, long ny, long *nnx, long *nny, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellnew_mmap           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>nnx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>nny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(cell) matrix cell object, mmapped from file. 
<p>
be aware that the data is not 8-byte aligned. The file is truncated if already exists. <div class="fragment"><pre class="fragment"><a name="l00373"></a>00373                                                                                          {
<a name="l00374"></a>00374     <span class="keywordflow">if</span>(!nx || !ny) <span class="keywordflow">return</span> NULL;
<a name="l00375"></a>00375     format2fn;
<a name="l00376"></a>00376     <span class="keywordtype">int</span> fd=mmap_open(fn);
<a name="l00377"></a>00377     <span class="keywordtype">long</span> headersize=<span class="keyword">sizeof</span>(long)*2+<span class="keyword">sizeof</span>(uint32_t);
<a name="l00378"></a>00378     <span class="keywordtype">long</span> msize=headersize;
<a name="l00379"></a>00379     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;nx*ny; ix++){
<a name="l00380"></a>00380     msize+=headersize+nnx[ix]*nny[ix]*<span class="keyword">sizeof</span>(T);
<a name="l00381"></a>00381     }
<a name="l00382"></a>00382     <span class="keywordflow">if</span>(ftruncate(fd, msize)){
<a name="l00383"></a>00383     error(<span class="stringliteral">"Error truncating file\n"</span>);
<a name="l00384"></a>00384     }
<a name="l00385"></a>00385     <span class="keywordtype">char</span> *map=mmap(NULL, msize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
<a name="l00386"></a>00386     memset(map, 0, msize);
<a name="l00387"></a>00387     close(fd);
<a name="l00388"></a>00388     X(cell) *out=X(cellnew)(nx,ny);
<a name="l00389"></a>00389     out-&gt;mmap=map;
<a name="l00390"></a>00390     mmap_header(map, MC_T, nx, ny);
<a name="l00391"></a>00391     map+=headersize;<span class="comment">//header of cell</span>
<a name="l00392"></a>00392     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;nx*ny; ix++){
<a name="l00393"></a>00393     mmap_header(map, M_T, nnx[ix], nny[ix]);
<a name="l00394"></a>00394     out-&gt;p[ix]=X(new_data)((T*)(map+headersize), nnx[ix], nny[ix]);
<a name="l00395"></a>00395     <span class="keywordflow">if</span>(out-&gt;p[ix]) {
<a name="l00396"></a>00396         out-&gt;p[ix]-&gt;type=MT_MMAP;
<a name="l00397"></a>00397     }
<a name="l00398"></a>00398     map+=nnx[ix]*nny[ix]*<span class="keyword">sizeof</span>(T)+headersize;
<a name="l00399"></a>00399     }
<a name="l00400"></a>00400 
<a name="l00401"></a>00401     <span class="keywordflow">return</span> out;
<a name="l00402"></a>00402 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e90d6b50dabcacd842a59ebc2e1326a7"></a><!-- doxytag: member="dmat.h::dcellnewsame_mmap" ref="e90d6b50dabcacd842a59ebc2e1326a7" args="(long nx, long ny, long mx, long my, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellnewsame_mmap           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(cell) matrix cell object, with identical blocks, mmapped from file. 
<p>
be aware that the data is not 8-byte aligned. The file is truncated if already exists. <div class="fragment"><pre class="fragment"><a name="l00407"></a>00407                                                                                          {
<a name="l00408"></a>00408     <span class="keywordflow">if</span>(!nx || !ny) <span class="keywordflow">return</span> NULL;
<a name="l00409"></a>00409     format2fn;
<a name="l00410"></a>00410     <span class="keywordtype">int</span> fd=mmap_open(fn);
<a name="l00411"></a>00411     <span class="keywordtype">long</span> headersize=<span class="keyword">sizeof</span>(long)*2+<span class="keyword">sizeof</span>(uint32_t);
<a name="l00412"></a>00412     <span class="keywordtype">long</span> msize=headersize;
<a name="l00413"></a>00413     msize=headersize+nx*ny*(headersize+mx*my*<span class="keyword">sizeof</span>(T));
<a name="l00414"></a>00414     <span class="keywordflow">if</span>(ftruncate(fd, msize)){
<a name="l00415"></a>00415     error(<span class="stringliteral">"Error truncating file\n"</span>);
<a name="l00416"></a>00416     }
<a name="l00417"></a>00417     <span class="keywordtype">char</span> *map=mmap(NULL, msize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
<a name="l00418"></a>00418     memset(map, 0, msize);
<a name="l00419"></a>00419     close(fd);
<a name="l00420"></a>00420     X(cell) *out=X(cellnew)(nx,ny);
<a name="l00421"></a>00421     out-&gt;mmap=map;
<a name="l00422"></a>00422     mmap_header(map, MC_T, nx, ny);
<a name="l00423"></a>00423     map+=headersize;<span class="comment">//header of cell</span>
<a name="l00424"></a>00424     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;nx*ny; ix++){
<a name="l00425"></a>00425     mmap_header(map, M_T, mx, my);
<a name="l00426"></a>00426     out-&gt;p[ix]=X(new_data)((T*)(map+headersize), mx, my);
<a name="l00427"></a>00427     <span class="keywordflow">if</span>(out-&gt;p[ix]){
<a name="l00428"></a>00428         out-&gt;p[ix]-&gt;type=MT_MMAP;
<a name="l00429"></a>00429     }
<a name="l00430"></a>00430     map+=mx*my*<span class="keyword">sizeof</span>(T)+headersize;
<a name="l00431"></a>00431     }
<a name="l00432"></a>00432     <span class="keywordflow">return</span> out;
<a name="l00433"></a>00433 }
</pre></div>
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 29 14:37:09 2010 for maos-0.6.4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
