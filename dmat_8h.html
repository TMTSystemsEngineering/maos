<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>maos-0.7.5: lib/dmat.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lib/dmat.h File Reference</h1>Contains the mathematically functions regarding to <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> and <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a> object.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#b14d47edec330a505cf684a2b0c4ff9c">dnew_ref</a> (double *p, long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creat a X(mat) object to reference an already existing vector.  <a href="#b14d47edec330a505cf684a2b0c4ff9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#21a7a376c0208121a33994cc82e7e662">dnew_data</a> (double *p, long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creat a X(mat) object with already allocated memory chunk.  <a href="#21a7a376c0208121a33994cc82e7e662"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#0d7497e2dbb79adb228de6bdde4a201e">dnew</a> (long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new T matrix object.  <a href="#0d7497e2dbb79adb228de6bdde4a201e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#d1c7365b3e3f0da49ddbf496bd46514b">dfree_keepdata</a> (<a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the X(mat), but keep the data.  <a href="#d1c7365b3e3f0da49ddbf496bd46514b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#5714a51acdc824562d451b9fde5d5da2">dfree_do</a> (<a class="el" href="structdmat.html">dmat</a> *A, int keepdata)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(mat) object.  <a href="#5714a51acdc824562d451b9fde5d5da2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#301b5a86cec0090378b142a09fb2066a">dresize</a> (<a class="el" href="structdmat.html">dmat</a> *A, long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize a matrix by adding or removing columns or rows.  <a href="#301b5a86cec0090378b142a09fb2066a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#a9c20ae37907780af63d91312d4fea38">dref</a> (<a class="el" href="structdmat.html">dmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creat a X(mat) reference an existing X(mat).  <a href="#a9c20ae37907780af63d91312d4fea38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#9033c130427b2e4cc3eabd68c9630948">dref_reshape</a> (<a class="el" href="structdmat.html">dmat</a> *in, int nx, int ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create an new X(mat) reference another with different shape.  <a href="#9033c130427b2e4cc3eabd68c9630948"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#d0c062d9a51fd5cff9924c066ca0b0bc">drefcols</a> (<a class="el" href="structdmat.html">dmat</a> *in, long icol, long ncol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creat a new X(mat) referencing columns in existing X(mat).  <a href="#d0c062d9a51fd5cff9924c066ca0b0bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#0e149114c808ff424f7fe215ee44d307">dsub</a> (const <a class="el" href="structdmat.html">dmat</a> *in, long sx, long nx, long sy, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new sub matrix of nx*ny starting from(sx,sy).  <a href="#0e149114c808ff424f7fe215ee44d307"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#131e99be189eda7c5b32aba76bcbe8d8">dcat</a> (const <a class="el" href="structdmat.html">dmat</a> *in1, const <a class="el" href="structdmat.html">dmat</a> *in2, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">concatenate two matrixes into 1 along dimension "dim"  <a href="#131e99be189eda7c5b32aba76bcbe8d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#ca6f393efef34132906a9e302e96b978">darrfree</a> (<a class="el" href="structdmat.html">dmat</a> **As, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(mat) array.  <a href="#ca6f393efef34132906a9e302e96b978"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#7ecadca31195b8b40135b7dbeb808906">ddup</a> (const <a class="el" href="structdmat.html">dmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">duplicate a X(mat) array  <a href="#7ecadca31195b8b40135b7dbeb808906"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#b5adc5cd1e79d9a79751ba482728f230">dcp</a> (<a class="el" href="structdmat.html">dmat</a> **out0, const <a class="el" href="structdmat.html">dmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy the values from one X(mat) to another.  <a href="#b5adc5cd1e79d9a79751ba482728f230"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#2ce308cca861c7b07e46fcbe1bedc919">dtrans</a> (const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">transpose a X(mat) object  <a href="#2ce308cca861c7b07e46fcbe1bedc919"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#705d6399ce6e7f7064d12f4eb131d47d">dset</a> (<a class="el" href="structdmat.html">dmat</a> *A, const double val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set values of each element in a X(mat) to val.  <a href="#705d6399ce6e7f7064d12f4eb131d47d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#e98618064b54869b4180d0c7fd895645">dzero</a> (<a class="el" href="structdmat.html">dmat</a> *out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialize all numbers in a X(mat) object to 0  <a href="#e98618064b54869b4180d0c7fd895645"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#abb4fecd296ac9ec19263e0f9d853be7">dmax</a> (const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find the maximum value of a X(mat) object  <a href="#abb4fecd296ac9ec19263e0f9d853be7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#00004b652c3485c94f4f64cfdafe5577">dmin</a> (const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find the minimum value of a X(mat) object  <a href="#00004b652c3485c94f4f64cfdafe5577"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#060e5d00143124ecbad59364c16da459">dnorm2</a> (const <a class="el" href="structdmat.html">dmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the norm2 of A  <a href="#060e5d00143124ecbad59364c16da459"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#091b0d7c934b06328ff775eb2d20d3d2">drandu</a> (<a class="el" href="structdmat.html">dmat</a> *A, const double mean, <a class="el" href="structmt__state.html">rand_t</a> *rstat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill A with random uniform numbers between [0, 1]*max.  <a href="#091b0d7c934b06328ff775eb2d20d3d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#1f835b56e643f7b8dbf36aca05fffd3a">drandn</a> (<a class="el" href="structdmat.html">dmat</a> *A, const double sigma, <a class="el" href="structmt__state.html">rand_t</a> *rstat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill A with random normal distribution numbers with standard deviation of sigma.  <a href="#1f835b56e643f7b8dbf36aca05fffd3a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#657f20445f371c8deaff82a5a052c02f">dshow</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">display a X(mat) matrix.  <a href="#657f20445f371c8deaff82a5a052c02f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#9a9da6ac02ccf42247a8a78a131ca73a">dscale</a> (<a class="el" href="structdmat.html">dmat</a> *A, double w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">scale each element of A by w  <a href="#9a9da6ac02ccf42247a8a78a131ca73a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#176e534c9042ace51d05a620a2294248">dsum</a> (const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create sum of all the elements in A.  <a href="#176e534c9042ace51d05a620a2294248"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#4c4f53dc9572106deb6933eb103bf40b">dadd</a> (<a class="el" href="structdmat.html">dmat</a> **B0, double bc, const <a class="el" href="structdmat.html">dmat</a> *A, const double ac)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute B=bc*B+ac*A behavior changed on 2009-11-02.  <a href="#4c4f53dc9572106deb6933eb103bf40b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#d5e98c2e933c9ca456e3dc1a47b6bea2">dinn</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the inner product of A and B.  <a href="#d5e98c2e933c9ca456e3dc1a47b6bea2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#85aee0e43bf0c24f996b45f3e1d721a6">dwdot</a> (const double *a, const <a class="el" href="structdmat.html">dmat</a> *w, const double *b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute weighted dot product a'*(w*b)  <a href="#85aee0e43bf0c24f996b45f3e1d721a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#ac8016fed8bbcc2a49d5a9ba3b835755">dwdot2</a> (const double *a, const <a class="el" href="structdmat.html">dmat</a> *w, const double *b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">special version of dwdot for just 2 element vectors.  <a href="#ac8016fed8bbcc2a49d5a9ba3b835755"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#2ad0b887d8ae79cd753310e095e2bd07">dwdot3</a> (const double *a, const <a class="el" href="structdmat.html">dmat</a> *w, const double *b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">special version of dwdot for just 3 element vectors.  <a href="#2ad0b887d8ae79cd753310e095e2bd07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#fda5697c36cb1de9790b812d919697c8">dcwm</a> (<a class="el" href="structdmat.html">dmat</a> *B, const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute component wise multiply B=B.  <a href="#fda5697c36cb1de9790b812d919697c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#108a4a2f57a5f271427d7af94a71abd8">dmulvec</a> (double *restrict y, const <a class="el" href="structdmat.html">dmat</a> *restrict A, const double *restrict x, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">multiply a X(mat) matrix with a vector and accumulate to y: y+=A*x*alpha  <a href="#108a4a2f57a5f271427d7af94a71abd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#a9ddb63c56fcc2219955260936ee9e40">dmm</a> (<a class="el" href="structdmat.html">dmat</a> **C0, const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *B, const char trans[2], const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute matrix product using blas dgemm with beta=1; C=beta*C+ alpha *trans(A)*trans(B); if C exist.  <a href="#a9ddb63c56fcc2219955260936ee9e40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#b48bc9b9c8f923e19dafc70b8fff5de2">dinvspd_inplace</a> (<a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace invert a small square SPD matrix using lapack dposv_, usually (A'*w*A).  <a href="#b48bc9b9c8f923e19dafc70b8fff5de2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#30ba84a58a9c9dd2e0a0afb5e389ffad">dinvspd</a> (const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">out of place version of dinvspd_inplace  <a href="#30ba84a58a9c9dd2e0a0afb5e389ffad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#661f5d1ec1bbcf8237c0f99b2b659314">dinv_inplace</a> (<a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace invert a general square matrix using lapack dgesv_  <a href="#661f5d1ec1bbcf8237c0f99b2b659314"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#7a04b161bee57112f209fa41a89c0295">dinv</a> (const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">out of place version of dinv  <a href="#7a04b161bee57112f209fa41a89c0295"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#da3db752eaaa609a7ec31fc98804d996">dmcc</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *wt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute (A'*W*A); where diag(W)=wt  <a href="#da3db752eaaa609a7ec31fc98804d996"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#15b43fafd86e62f49de974bb3da6f51c">dimcc</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *wt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute inv(dmcc(A, wt))  <a href="#15b43fafd86e62f49de974bb3da6f51c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#81d6ed373bf09f884a5114c8b0f543ac">dtmcc</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *wt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute (A*W*A'); where diag(W)=wt  <a href="#81d6ed373bf09f884a5114c8b0f543ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#cac32a8e663201109abf36bd322e9a46">dpinv</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *wt, const <a class="el" href="structdsp.html">dsp</a> *Wsp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the pseudo inverse of matrix A with weigthing of full matrix W or sparse matrix weighting Wsp.  <a href="#cac32a8e663201109abf36bd322e9a46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#a91e97f6979658a32b79a70b748b4810">ddiff</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the relative difference betwee two vectors.  <a href="#a91e97f6979658a32b79a70b748b4810"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#4529479ba036e3aae3b1827f161a7f9b">dcircle</a> (<a class="el" href="structdmat.html">dmat</a> *A, double cx, double cy, double r, double val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a new gray pixel map generation based on bilinear influence functions used in mkw.  <a href="#4529479ba036e3aae3b1827f161a7f9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#bb7ee19f9a9bd8c7d4f3fc680a202601">dcircle_symbolic</a> (<a class="el" href="structdmat.html">dmat</a> *A, double cx, double cy, double r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">similar to X(circle).  <a href="#bb7ee19f9a9bd8c7d4f3fc680a202601"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#9d9ed91255390f1e4649fc623dfa17ce">dfftshift</a> (<a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">shift frequency components by n/2  <a href="#9d9ed91255390f1e4649fc623dfa17ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#9f252bb4fd703109c58f8c330d6f11df">dcpcorner2center</a> (<a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdmat.html">dmat</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reorder B and embed/crop into center of A  <a href="#9f252bb4fd703109c58f8c330d6f11df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#05330b7f5be190a6567ee775e73464c9">dshift</a> (<a class="el" href="structdmat.html">dmat</a> **B0, const <a class="el" href="structdmat.html">dmat</a> *A, int sx, int sy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cyclic shift A by nx and ny to B.  <a href="#05330b7f5be190a6567ee775e73464c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#58ed65327dde1b0410fa992eda632d3b">drotvec</a> (<a class="el" href="structdmat.html">dmat</a> *A, const double theta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">rotate the vectors CCW.  <a href="#58ed65327dde1b0410fa992eda632d3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#b4e3ddd0d5e6249c6d90c26991d8028c">drotvecnn</a> (<a class="el" href="structdmat.html">dmat</a> **B0, const <a class="el" href="structdmat.html">dmat</a> *A, double theta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">rotate a 2x2 covariance matrix A by theta CCW (coordinate rotate -theta CCW) or from ra to xy coordinate.  <a href="#b4e3ddd0d5e6249c6d90c26991d8028c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#e6580138c809e940eb9105b2b3791292">dmulvec3</a> (double *y, const <a class="el" href="structdmat.html">dmat</a> *A, const double *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">T matrix vector multiply optimized for just three values.  <a href="#e6580138c809e940eb9105b2b3791292"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#6531cfb8534d620420fbdf1deffb227c">dcog</a> (double *grad, const <a class="el" href="structdmat.html">dmat</a> *i0, double offsetx, double offsety, double thres, double bkgrnd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute thresholded center of gravity.  <a href="#6531cfb8534d620420fbdf1deffb227c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#96ba5af3d8d18bfdf35cbbb3a49abd0c">dshift2center</a> (<a class="el" href="structdmat.html">dmat</a> *A, double offsetx, double offsety)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift the image in A to center on physical center+[offsetx,offsety] using cog and fft.  <a href="#96ba5af3d8d18bfdf35cbbb3a49abd0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#30e08db08cab036374dc0635df4665d6">dclip</a> (<a class="el" href="structdmat.html">dmat</a> *A, double min, double max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limit numbers in A to within [min, max].  <a href="#30e08db08cab036374dc0635df4665d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#0131ec62b0a77d0df03e71b35f2d7b85">dgramschmidt</a> (<a class="el" href="structdmat.html">dmat</a> *Mod, double *amp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">OrthNormalize column vector in Mod, with weighting from vector amp.  <a href="#0131ec62b0a77d0df03e71b35f2d7b85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#dd22a26474e6e6af8df941a6b25b0f05">dmuldiag</a> (<a class="el" href="structdmat.html">dmat</a> *A, <a class="el" href="structdmat.html">dmat</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A=A*B, where diag(B)=s.  <a href="#dd22a26474e6e6af8df941a6b25b0f05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#b6f63a9e507f7a58e4f1ba98d7bb3288">dcwpow</a> (<a class="el" href="structdmat.html">dmat</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raise all elements to power power.  <a href="#b6f63a9e507f7a58e4f1ba98d7bb3288"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#f6edae64ae92dc140f4a85679d6252ae">dsvd</a> (<a class="el" href="structdmat.html">dmat</a> **Sdiag, <a class="el" href="structdmat.html">dmat</a> **U, <a class="el" href="structdmat.html">dmat</a> **VT, const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SVD of a general matrix.  <a href="#f6edae64ae92dc140f4a85679d6252ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#0063f9a3cde12e2b0977ed7a485fbb2c">dsvd_pow</a> (<a class="el" href="structdmat.html">dmat</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes pow(A,power) using svd  <a href="#0063f9a3cde12e2b0977ed7a485fbb2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#42490ea31b5b30b0b618f417c76bd712">daddI</a> (<a class="el" href="structdmat.html">dmat</a> *A, double val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add val to diagonal values of A.  <a href="#42490ea31b5b30b0b618f417c76bd712"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#a23e8df5aa3152c6f01025e956958e9a">dtikcr</a> (<a class="el" href="structdmat.html">dmat</a> *A, double thres)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply tikhonov regularization to A.  <a href="#a23e8df5aa3152c6f01025e956958e9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#13ed19366b0b57c73f7a0f37bd20dfb4">dmulsp</a> (<a class="el" href="structdmat.html">dmat</a> **yout, const <a class="el" href="structdmat.html">dmat</a> *x, const <a class="el" href="structdsp.html">dsp</a> *A, const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">y=y+alpha*OP(x)*OP(A); implemented by transposing x,y index in sptmulmat implementation TESTED OK.  <a href="#13ed19366b0b57c73f7a0f37bd20dfb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#3d3dc034d88f0a526fe242b1c1d3b1e5">dlogspace</a> (double emin, double emax, long n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create log spaced vector.  <a href="#3d3dc034d88f0a526fe242b1c1d3b1e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#f066671d15c55648b99456c410529e33">dlinspace</a> (double emin, double emax, long n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create linearly spaced vector.  <a href="#f066671d15c55648b99456c410529e33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#139bad85f7f26668a547d3bb581a199c">dinterp1</a> (<a class="el" href="structdmat.html">dmat</a> *xin, <a class="el" href="structdmat.html">dmat</a> *yin, <a class="el" href="structdmat.html">dmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolate using linear interp.  <a href="#139bad85f7f26668a547d3bb581a199c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#50a81407616c0a439e8d95fdc66c28e1">dinterp1log</a> (<a class="el" href="structdmat.html">dmat</a> *xin, <a class="el" href="structdmat.html">dmat</a> *yin, <a class="el" href="structdmat.html">dmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolate using log(xin) and log(xnew) xin is the coordinate of yin.  <a href="#50a81407616c0a439e8d95fdc66c28e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#041003260afdf29166953042ddb51e53">dhistfill</a> (<a class="el" href="structdmat.html">dmat</a> **out, const <a class="el" href="structdmat.html">dmat</a> *A, double center, double spacing, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For each entry in A, call repeatly to collect its histogram, centered at center, spaced by spacing, for n bins in total.  <a href="#041003260afdf29166953042ddb51e53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#c94bb7e7491459eba07f93115ee7d8a1">dspline_prep</a> (<a class="el" href="structdmat.html">dmat</a> *x, <a class="el" href="structdmat.html">dmat</a> *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">1D Cubic spline interpolation preparation.  <a href="#c94bb7e7491459eba07f93115ee7d8a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#d6c71f329b21ee28435a06fd64e828c8">dspline_eval</a> (<a class="el" href="structdmat.html">dmat</a> *coeff, <a class="el" href="structdmat.html">dmat</a> *x, <a class="el" href="structdmat.html">dmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evluate the cubic spline represented by nx5 matrix coeff, at location array xnew.  <a href="#d6c71f329b21ee28435a06fd64e828c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#66dcecfdc833ad4174eec33dafc3b8eb">dspline</a> (<a class="el" href="structdmat.html">dmat</a> *x, <a class="el" href="structdmat.html">dmat</a> *y, <a class="el" href="structdmat.html">dmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do 1D cubic spline all at once by calling X(spline_prep) and X(spline_evald).  <a href="#66dcecfdc833ad4174eec33dafc3b8eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#801f95bc127f94b526980791d71e2bb1">dbspline_prep</a> (<a class="el" href="structdmat.html">dmat</a> *x, <a class="el" href="structdmat.html">dmat</a> *y, <a class="el" href="structdmat.html">dmat</a> *z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2D cubic spline interpolation preparation.  <a href="#801f95bc127f94b526980791d71e2bb1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#88fcc3be27ce68860cc93c2540c363b2">dbspline_eval</a> (<a class="el" href="structdcell.html">dcell</a> *coeff, <a class="el" href="structdmat.html">dmat</a> *x, <a class="el" href="structdmat.html">dmat</a> *y, <a class="el" href="structdmat.html">dmat</a> *xnew, <a class="el" href="structdmat.html">dmat</a> *ynew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate 2D cubic spline at location defined 2-d arrays by xnew, ynew.  <a href="#88fcc3be27ce68860cc93c2540c363b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#86b0f400003435e6813588d09861f438">dcwlog10</a> (<a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do a component wise log10 on each element of A.  <a href="#86b0f400003435e6813588d09861f438"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#abf4cf559f55b2e888fed7dd336f6e07">dcellnew</a> (const long nx, const long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a new block matrix.  <a href="#abf4cf559f55b2e888fed7dd336f6e07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#92bc9490727ab673ba458e0b78b81b05">dcellnew2</a> (const <a class="el" href="structdcell.html">dcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create an new X(cell) similar to A in shape  <a href="#92bc9490727ab673ba458e0b78b81b05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#e385d21eb33f992fd5ff4d3166d929ba">dcellzero</a> (<a class="el" href="structdcell.html">dcell</a> *dc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">setting all elements of a X(cell) to zero.  <a href="#e385d21eb33f992fd5ff4d3166d929ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#a23f0606a6c60596734b1128855dba6d">dcellset</a> (<a class="el" href="structdcell.html">dcell</a> *dc, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">setting all elements of a X(cell) to alpha.  <a href="#a23f0606a6c60596734b1128855dba6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#f306524d189291b53dc6dd8547c4ddf2">dcellfree_do</a> (<a class="el" href="structdcell.html">dcell</a> *dc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a X(cell) object.  <a href="#f306524d189291b53dc6dd8547c4ddf2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#faf442e020aff84b8b1fe1766ab89227">dcelltrans</a> (const <a class="el" href="structdcell.html">dcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">transpose a X(cell) object  <a href="#faf442e020aff84b8b1fe1766ab89227"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#31480c8af50a8adc9182fae5285aaa6e">dcellref</a> (const <a class="el" href="structdcell.html">dcell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creat a X(cell) reference an existing X(cell) by referencing the elements.  <a href="#31480c8af50a8adc9182fae5285aaa6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#dde326a0041feef662127b62b4c37f23">dcelldup</a> (const <a class="el" href="structdcell.html">dcell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">duplicate a X(cell) object.  <a href="#dde326a0041feef662127b62b4c37f23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#104912d02e021b396d29d78bd2249b95">dcellcp</a> (<a class="el" href="structdcell.html">dcell</a> **out0, const <a class="el" href="structdcell.html">dcell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy the values from one X(cell) to another.  <a href="#104912d02e021b396d29d78bd2249b95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#99511eff251a7861181946af30572ef9">dcellnorm2</a> (const <a class="el" href="structdcell.html">dcell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute norm2.  <a href="#99511eff251a7861181946af30572ef9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#ae5e354726e58598c4f9a0ab039f0b67">dcellscale</a> (<a class="el" href="structdcell.html">dcell</a> *A, double w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">scale each element of A.  <a href="#ae5e354726e58598c4f9a0ab039f0b67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#805f88ca094efb27fad5861042f5d4a4">dcellreduce</a> (const <a class="el" href="structdcell.html">dcell</a> *A, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reduce nx*ny cell matrix to 1*ny if dim=1 and nx*11 if dim=2  <a href="#805f88ca094efb27fad5861042f5d4a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#cf4358f31eff9028f0204dfceee00eb9">dcellcat</a> (const <a class="el" href="structdcell.html">dcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">concatenate two cell matrices along dimenstion 'dim'  <a href="#cf4358f31eff9028f0204dfceee00eb9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#fb150ef1f6f90d87d2060922e3a2a9b2">dcellcat_each</a> (const <a class="el" href="structdcell.html">dcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">concatenate coresponding elements of each X(cell).  <a href="#fb150ef1f6f90d87d2060922e3a2a9b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#1e5613fa12d1d0d0b41ff909ac84a33e">dcelldropempty</a> (<a class="el" href="structdcell.html">dcell</a> **A0, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">drop empty rows or columns.  <a href="#1e5613fa12d1d0d0b41ff909ac84a33e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#1c506292c4c46d72e8fd573540839ae7">dcelladd</a> (<a class="el" href="structdcell.html">dcell</a> **B0, double bc, const <a class="el" href="structdcell.html">dcell</a> *A, const double ac)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add one to another.  <a href="#1c506292c4c46d72e8fd573540839ae7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#74eda13294cbbec5c4e93e70d7297301">dcellinn</a> (const <a class="el" href="structdcell.html">dcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the inner produce of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>.  <a href="#74eda13294cbbec5c4e93e70d7297301"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#57b0daa3ccb27a83e4b2235da8eec035">dcellcwm</a> (<a class="el" href="structdcell.html">dcell</a> *B, const <a class="el" href="structdcell.html">dcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Component wise multiply of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a> B=A.  <a href="#57b0daa3ccb27a83e4b2235da8eec035"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#2011d79d74ff15b07162da6f0a28fd97">dcellmm</a> (<a class="el" href="structdcell.html">dcell</a> **C0, const <a class="el" href="structdcell.html">dcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B, const char trans[2], const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute A*B and add to C0.  <a href="#2011d79d74ff15b07162da6f0a28fd97"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#59e3e5c87a7038f6408858c159a166a4">dcellinvspd</a> (<a class="el" href="structdcell.html">dcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Invert a SPD matrix.  <a href="#59e3e5c87a7038f6408858c159a166a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#bdecf8635a39266960e7121b54be57d2">dcellinv</a> (<a class="el" href="structdcell.html">dcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Invert a matrix.  <a href="#bdecf8635a39266960e7121b54be57d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#cc0cce55471ddf4b189b5722f5f93790">dcellinvspd_each</a> (<a class="el" href="structdcell.html">dcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">invert each component of the <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>.  <a href="#cc0cce55471ddf4b189b5722f5f93790"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#02a07132b0fbb4f8fe6afeb3cd55176e">dcell2m</a> (const <a class="el" href="structdcell.html">dcell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a block matrix to a matrix.  <a href="#02a07132b0fbb4f8fe6afeb3cd55176e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#5f5443ca322b4ed2cb65a24e638f928e">d2cellref</a> (const <a class="el" href="structdmat.html">dmat</a> *A, int *dims, int ndim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convert a vector to cell using dimensions specified in dims.  <a href="#5f5443ca322b4ed2cb65a24e638f928e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#bed4b3e507a4bb20689c0fce64de6c0a">d2cell</a> (<a class="el" href="structdcell.html">dcell</a> **B, const <a class="el" href="structdmat.html">dmat</a> *A, const <a class="el" href="structdcell.html">dcell</a> *ref)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">make A a cell array using shape information from ref if *B is NULL  <a href="#bed4b3e507a4bb20689c0fce64de6c0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#4e9d5e166621f79342478304769a43fc">dcelldropzero</a> (<a class="el" href="structdcell.html">dcell</a> *B, double thres)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">drop empty blocks (zero).  <a href="#4e9d5e166621f79342478304769a43fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#ce747978615516a6c46a9dc7b823cdde">dcelldiff</a> (const <a class="el" href="structdcell.html">dcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute ||A-B||/||A|| use mean.  <a href="#ce747978615516a6c46a9dc7b823cdde"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#ba0fbb0b2f60c70c1aeff1921ad82b24">dcellclip</a> (<a class="el" href="structdcell.html">dcell</a> *Ac, double min, double max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">clip a X(cell) array to max at 'max', min at 'min'  <a href="#ba0fbb0b2f60c70c1aeff1921ad82b24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#8f5e44c289528e1cfecabe114bf98253">dcelltikcr</a> (<a class="el" href="structdcell.html">dcell</a> *A, double thres)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply tickholov regularization of relative thres to cell array by converting it to mat.  <a href="#8f5e44c289528e1cfecabe114bf98253"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e84c45e9ca11a75081b360a85051a089"></a><!-- doxytag: member="dmat.h::dcellpinv" ref="e84c45e9ca11a75081b360a85051a089" args="(const dcell *A, const dcell *wt, const spcell *Wsp)" -->
<a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>dcellpinv</b> (const <a class="el" href="structdcell.html">dcell</a> *A, const <a class="el" href="structdcell.html">dcell</a> *wt, const <a class="el" href="structspcell.html">spcell</a> *Wsp)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b0d2599366fb08286561b5000c2edcde"></a><!-- doxytag: member="dmat.h::dcellmulsp" ref="b0d2599366fb08286561b5000c2edcde" args="(dcell **C0, const dcell *A, const spcell *B, double alpha)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>dcellmulsp</b> (<a class="el" href="structdcell.html">dcell</a> **C0, const <a class="el" href="structdcell.html">dcell</a> *A, const <a class="el" href="structspcell.html">spcell</a> *B, double alpha)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#ed4f051cb2e11032d42d5e91e08f0f99">dcelladdI</a> (<a class="el" href="structdcell.html">dcell</a> *A, double a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add a to diagonal elements of A;  <a href="#ed4f051cb2e11032d42d5e91e08f0f99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#68953d78fbcaa6533fdd78b6b6513243">dcellsvd_pow</a> (<a class="el" href="structdcell.html">dcell</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the power of a block matrix using svd method.  <a href="#68953d78fbcaa6533fdd78b6b6513243"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#279fb443e6febe18586edcb53359cf5b">dcellcwpow</a> (<a class="el" href="structdcell.html">dcell</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">raise each cell in the cell array to power of power.  <a href="#279fb443e6febe18586edcb53359cf5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#3452afc53eefe2391f8720999be80c19">dwritedata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp, const <a class="el" href="structdmat.html">dmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains routines to write/read dense/sparse matrix into/from file.  <a href="#3452afc53eefe2391f8720999be80c19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#9a8e4a59501eeb3bdd87e490ff04d0e7">dcellwritedata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp, const <a class="el" href="structdcell.html">dcell</a> *dc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to write cell array of dense matrix data.  <a href="#9a8e4a59501eeb3bdd87e490ff04d0e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#41d92768709ddfc9b8862ae55bd6c97e">dreaddata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp, uint32_t magic)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to read dense matrix into memory from file pointer.  <a href="#41d92768709ddfc9b8862ae55bd6c97e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#47f492f62df187672db653542562827b">dcellreaddata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp, uint32_t magic)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to read dense matrix cell array into memory from file pointer.  <a href="#47f492f62df187672db653542562827b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#21964c0cee9cb479b21ad2227a9a60dc">spwritedata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp, const <a class="el" href="structdsp.html">dsp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to write sparse matrix data into file pointed using a file pointer.  <a href="#21964c0cee9cb479b21ad2227a9a60dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#f7fe3947f9663085c605a784ba991f95">spreaddata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp, uint32_t magic)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to read sparse matrix data from file pointer into memory.  <a href="#f7fe3947f9663085c605a784ba991f95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#37ebad9e8c582e694664b562a78114d2">dwrite</a> (const <a class="el" href="structdmat.html">dmat</a> *A, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write dense matrix into a file.  <a href="#37ebad9e8c582e694664b562a78114d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#70cd951a3932002ccc9270944d2005ec">dcellwrite</a> (const <a class="el" href="structdcell.html">dcell</a> *dc, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write cell array of dense matrix into a file.  <a href="#70cd951a3932002ccc9270944d2005ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#6406403e91ec976bb0d6c2e12b5d5a0f">dread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read dense matrix into memory from file.  <a href="#6406403e91ec976bb0d6c2e12b5d5a0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#dfec4b5637fce6a1cdb10b84d744c8fe">dcellread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read cell array of dense matrix into memory from file.  <a href="#dfec4b5637fce6a1cdb10b84d744c8fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#779cefb17e24b648212cc59f9324f5ae">spwrite</a> (const <a class="el" href="structdsp.html">dsp</a> *sp, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write sparse matrix into file.  <a href="#779cefb17e24b648212cc59f9324f5ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#fa58b8e2aea2a94ae0422ede37957a0f">spcellwrite</a> (const <a class="el" href="structspcell.html">spcell</a> *spc, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write cell array of sparse matrix into file.  <a href="#fa58b8e2aea2a94ae0422ede37957a0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdsp.html">dsp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#06bbd169953a4a808c647bd0a9e6f0d3">spread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read sparse metrix from file.  <a href="#06bbd169953a4a808c647bd0a9e6f0d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structspcell.html">spcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#dda41e6426ecac836fa3dd576f0d2bd9">spcellread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read cell array of sparse matrix from file.  <a href="#dda41e6426ecac836fa3dd576f0d2bd9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#316507e4c46251f724a2c22f1db76353">dnew_mmap</a> (long nx, long ny, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(mat) matrix object, mmapped from file.  <a href="#316507e4c46251f724a2c22f1db76353"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#a3b557cdaaf833c08dba873203894db5">dcellnew_mmap</a> (long nx, long ny, long *nnx, long *nny, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(cell) matrix cell object, mmapped from file.  <a href="#a3b557cdaaf833c08dba873203894db5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dmat_8h.html#e90d6b50dabcacd842a59ebc2e1326a7">dcellnewsame_mmap</a> (long nx, long ny, long mx, long my, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(cell) matrix cell object, with identical blocks, mmapped from file.  <a href="#e90d6b50dabcacd842a59ebc2e1326a7"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Contains the mathematically functions regarding to <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> and <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a> object. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="b14d47edec330a505cf684a2b0c4ff9c"></a><!-- doxytag: member="dmat.h::dnew_ref" ref="b14d47edec330a505cf684a2b0c4ff9c" args="(double *p, long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dnew_ref           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creat a X(mat) object to reference an already existing vector. 
<p>
free the X(mat) object won't free the existing vector. 
</div>
</div><p>
<a class="anchor" name="21a7a376c0208121a33994cc82e7e662"></a><!-- doxytag: member="dmat.h::dnew_data" ref="21a7a376c0208121a33994cc82e7e662" args="(double *p, long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dnew_data           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creat a X(mat) object with already allocated memory chunk. 
<p>
the memory is freed when the memory is freed. 
</div>
</div><p>
<a class="anchor" name="0d7497e2dbb79adb228de6bdde4a201e"></a><!-- doxytag: member="dmat.h::dnew" ref="0d7497e2dbb79adb228de6bdde4a201e" args="(long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dnew           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new T matrix object. 
<p>
initialized all to zero. 
</div>
</div><p>
<a class="anchor" name="d1c7365b3e3f0da49ddbf496bd46514b"></a><!-- doxytag: member="dmat.h::dfree_keepdata" ref="d1c7365b3e3f0da49ddbf496bd46514b" args="(dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dfree_keepdata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free the X(mat), but keep the data. 
<p>

</div>
</div><p>
<a class="anchor" name="5714a51acdc824562d451b9fde5d5da2"></a><!-- doxytag: member="dmat.h::dfree_do" ref="5714a51acdc824562d451b9fde5d5da2" args="(dmat *A, int keepdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>keepdata</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(mat) object. 
<p>
if keepdata!=0, will not free A-&gt;p. 
</div>
</div><p>
<a class="anchor" name="301b5a86cec0090378b142a09fb2066a"></a><!-- doxytag: member="dmat.h::dresize" ref="301b5a86cec0090378b142a09fb2066a" args="(dmat *A, long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dresize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resize a matrix by adding or removing columns or rows. 
<p>
Data is kept whever possible. Not used as of 2010-09-07. 
</div>
</div><p>
<a class="anchor" name="a9c20ae37907780af63d91312d4fea38"></a><!-- doxytag: member="dmat.h::dref" ref="a9c20ae37907780af63d91312d4fea38" args="(dmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dref           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creat a X(mat) reference an existing X(mat). 
<p>
Use the reference carefully. 
</div>
</div><p>
<a class="anchor" name="9033c130427b2e4cc3eabd68c9630948"></a><!-- doxytag: member="dmat.h::dref_reshape" ref="9033c130427b2e4cc3eabd68c9630948" args="(dmat *in, int nx, int ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dref_reshape           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create an new X(mat) reference another with different shape. 
<p>

</div>
</div><p>
<a class="anchor" name="d0c062d9a51fd5cff9924c066ca0b0bc"></a><!-- doxytag: member="dmat.h::drefcols" ref="d0c062d9a51fd5cff9924c066ca0b0bc" args="(dmat *in, long icol, long ncol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* drefcols           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>icol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ncol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creat a new X(mat) referencing columns in existing X(mat). 
<p>
reference counted. not used 
</div>
</div><p>
<a class="anchor" name="0e149114c808ff424f7fe215ee44d307"></a><!-- doxytag: member="dmat.h::dsub" ref="0e149114c808ff424f7fe215ee44d307" args="(const dmat *in, long sx, long nx, long sy, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dsub           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new sub matrix of nx*ny starting from(sx,sy). 
<p>

</div>
</div><p>
<a class="anchor" name="131e99be189eda7c5b32aba76bcbe8d8"></a><!-- doxytag: member="dmat.h::dcat" ref="131e99be189eda7c5b32aba76bcbe8d8" args="(const dmat *in1, const dmat *in2, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dcat           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
concatenate two matrixes into 1 along dimension "dim" 
<p>

</div>
</div><p>
<a class="anchor" name="ca6f393efef34132906a9e302e96b978"></a><!-- doxytag: member="dmat.h::darrfree" ref="ca6f393efef34132906a9e302e96b978" args="(dmat **As, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void darrfree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>As</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(mat) array. 
<p>

</div>
</div><p>
<a class="anchor" name="7ecadca31195b8b40135b7dbeb808906"></a><!-- doxytag: member="dmat.h::ddup" ref="7ecadca31195b8b40135b7dbeb808906" args="(const dmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* ddup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
duplicate a X(mat) array 
<p>

</div>
</div><p>
<a class="anchor" name="b5adc5cd1e79d9a79751ba482728f230"></a><!-- doxytag: member="dmat.h::dcp" ref="b5adc5cd1e79d9a79751ba482728f230" args="(dmat **out0, const dmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy the values from one X(mat) to another. 
<p>

</div>
</div><p>
<a class="anchor" name="2ce308cca861c7b07e46fcbe1bedc919"></a><!-- doxytag: member="dmat.h::dtrans" ref="2ce308cca861c7b07e46fcbe1bedc919" args="(const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dtrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
transpose a X(mat) object 
<p>

</div>
</div><p>
<a class="anchor" name="705d6399ce6e7f7064d12f4eb131d47d"></a><!-- doxytag: member="dmat.h::dset" ref="705d6399ce6e7f7064d12f4eb131d47d" args="(dmat *A, const double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set values of each element in a X(mat) to val. 
<p>

</div>
</div><p>
<a class="anchor" name="e98618064b54869b4180d0c7fd895645"></a><!-- doxytag: member="dmat.h::dzero" ref="e98618064b54869b4180d0c7fd895645" args="(dmat *out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dzero           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>out</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
initialize all numbers in a X(mat) object to 0 
<p>

</div>
</div><p>
<a class="anchor" name="abb4fecd296ac9ec19263e0f9d853be7"></a><!-- doxytag: member="dmat.h::dmax" ref="abb4fecd296ac9ec19263e0f9d853be7" args="(const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dmax           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find the maximum value of a X(mat) object 
<p>

</div>
</div><p>
<a class="anchor" name="00004b652c3485c94f4f64cfdafe5577"></a><!-- doxytag: member="dmat.h::dmin" ref="00004b652c3485c94f4f64cfdafe5577" args="(const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dmin           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find the minimum value of a X(mat) object 
<p>

</div>
</div><p>
<a class="anchor" name="060e5d00143124ecbad59364c16da459"></a><!-- doxytag: member="dmat.h::dnorm2" ref="060e5d00143124ecbad59364c16da459" args="(const dmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dnorm2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the norm2 of A 
<p>

</div>
</div><p>
<a class="anchor" name="091b0d7c934b06328ff775eb2d20d3d2"></a><!-- doxytag: member="dmat.h::drandu" ref="091b0d7c934b06328ff775eb2d20d3d2" args="(dmat *A, const double mean, rand_t *rstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drandu           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmt__state.html">rand_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rstat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill A with random uniform numbers between [0, 1]*max. 
<p>

</div>
</div><p>
<a class="anchor" name="1f835b56e643f7b8dbf36aca05fffd3a"></a><!-- doxytag: member="dmat.h::drandn" ref="1f835b56e643f7b8dbf36aca05fffd3a" args="(dmat *A, const double sigma, rand_t *rstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drandn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmt__state.html">rand_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rstat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill A with random normal distribution numbers with standard deviation of sigma. 
<p>

</div>
</div><p>
<a class="anchor" name="657f20445f371c8deaff82a5a052c02f"></a><!-- doxytag: member="dmat.h::dshow" ref="657f20445f371c8deaff82a5a052c02f" args="(const dmat *A, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dshow           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
display a X(mat) matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="9a9da6ac02ccf42247a8a78a131ca73a"></a><!-- doxytag: member="dmat.h::dscale" ref="9a9da6ac02ccf42247a8a78a131ca73a" args="(dmat *A, double w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>w</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
scale each element of A by w 
<p>

</div>
</div><p>
<a class="anchor" name="176e534c9042ace51d05a620a2294248"></a><!-- doxytag: member="dmat.h::dsum" ref="176e534c9042ace51d05a620a2294248" args="(const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dsum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create sum of all the elements in A. 
<p>

</div>
</div><p>
<a class="anchor" name="4c4f53dc9572106deb6933eb103bf40b"></a><!-- doxytag: member="dmat.h::dadd" ref="4c4f53dc9572106deb6933eb103bf40b" args="(dmat **B0, double bc, const dmat *A, const double ac)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dadd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>ac</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute B=bc*B+ac*A behavior changed on 2009-11-02. 
<p>
if A is NULL, don't do anything. 
</div>
</div><p>
<a class="anchor" name="d5e98c2e933c9ca456e3dc1a47b6bea2"></a><!-- doxytag: member="dmat.h::dinn" ref="d5e98c2e933c9ca456e3dc1a47b6bea2" args="(const dmat *A, const dmat *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the inner product of A and B. 
<p>
(inner product) 
</div>
</div><p>
<a class="anchor" name="85aee0e43bf0c24f996b45f3e1d721a6"></a><!-- doxytag: member="dmat.h::dwdot" ref="85aee0e43bf0c24f996b45f3e1d721a6" args="(const double *a, const dmat *w, const double *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dwdot           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute weighted dot product a'*(w*b) 
<p>

</div>
</div><p>
<a class="anchor" name="ac8016fed8bbcc2a49d5a9ba3b835755"></a><!-- doxytag: member="dmat.h::dwdot2" ref="ac8016fed8bbcc2a49d5a9ba3b835755" args="(const double *a, const dmat *w, const double *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dwdot2           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
special version of dwdot for just 2 element vectors. 
<p>

</div>
</div><p>
<a class="anchor" name="2ad0b887d8ae79cd753310e095e2bd07"></a><!-- doxytag: member="dmat.h::dwdot3" ref="2ad0b887d8ae79cd753310e095e2bd07" args="(const double *a, const dmat *w, const double *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dwdot3           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
special version of dwdot for just 3 element vectors. 
<p>

</div>
</div><p>
<a class="anchor" name="fda5697c36cb1de9790b812d919697c8"></a><!-- doxytag: member="dmat.h::dcwm" ref="fda5697c36cb1de9790b812d919697c8" args="(dmat *B, const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcwm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute component wise multiply B=B. 
<p>
*A 
</div>
</div><p>
<a class="anchor" name="108a4a2f57a5f271427d7af94a71abd8"></a><!-- doxytag: member="dmat.h::dmulvec" ref="108a4a2f57a5f271427d7af94a71abd8" args="(double *restrict y, const dmat *restrict A, const double *restrict x, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dmulvec           </td>
          <td>(</td>
          <td class="paramtype">double *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
multiply a X(mat) matrix with a vector and accumulate to y: y+=A*x*alpha 
<p>

</div>
</div><p>
<a class="anchor" name="a9ddb63c56fcc2219955260936ee9e40"></a><!-- doxytag: member="dmat.h::dmm" ref="a9ddb63c56fcc2219955260936ee9e40" args="(dmat **C0, const dmat *A, const dmat *B, const char trans[2], const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dmm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>trans</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute matrix product using blas dgemm with beta=1; C=beta*C+ alpha *trans(A)*trans(B); if C exist. 
<p>

</div>
</div><p>
<a class="anchor" name="b48bc9b9c8f923e19dafc70b8fff5de2"></a><!-- doxytag: member="dmat.h::dinvspd_inplace" ref="b48bc9b9c8f923e19dafc70b8fff5de2" args="(dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dinvspd_inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace invert a small square SPD matrix using lapack dposv_, usually (A'*w*A). 
<p>
by solving Ax=I; copy x to A. dposv_ modifies A also. be careful 
</div>
</div><p>
<a class="anchor" name="30ba84a58a9c9dd2e0a0afb5e389ffad"></a><!-- doxytag: member="dmat.h::dinvspd" ref="30ba84a58a9c9dd2e0a0afb5e389ffad" args="(const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dinvspd           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
out of place version of dinvspd_inplace 
<p>

</div>
</div><p>
<a class="anchor" name="661f5d1ec1bbcf8237c0f99b2b659314"></a><!-- doxytag: member="dmat.h::dinv_inplace" ref="661f5d1ec1bbcf8237c0f99b2b659314" args="(dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dinv_inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace invert a general square matrix using lapack dgesv_ 
<p>

</div>
</div><p>
<a class="anchor" name="7a04b161bee57112f209fa41a89c0295"></a><!-- doxytag: member="dmat.h::dinv" ref="7a04b161bee57112f209fa41a89c0295" args="(const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dinv           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
out of place version of dinv 
<p>

</div>
</div><p>
<a class="anchor" name="da3db752eaaa609a7ec31fc98804d996"></a><!-- doxytag: member="dmat.h::dmcc" ref="da3db752eaaa609a7ec31fc98804d996" args="(const dmat *A, const dmat *wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dmcc           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute (A'*W*A); where diag(W)=wt 
<p>

</div>
</div><p>
<a class="anchor" name="15b43fafd86e62f49de974bb3da6f51c"></a><!-- doxytag: member="dmat.h::dimcc" ref="15b43fafd86e62f49de974bb3da6f51c" args="(const dmat *A, const dmat *wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dimcc           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute inv(dmcc(A, wt)) 
<p>

</div>
</div><p>
<a class="anchor" name="81d6ed373bf09f884a5114c8b0f543ac"></a><!-- doxytag: member="dmat.h::dtmcc" ref="81d6ed373bf09f884a5114c8b0f543ac" args="(const dmat *A, const dmat *wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dtmcc           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute (A*W*A'); where diag(W)=wt 
<p>

</div>
</div><p>
<a class="anchor" name="cac32a8e663201109abf36bd322e9a46"></a><!-- doxytag: member="dmat.h::dpinv" ref="cac32a8e663201109abf36bd322e9a46" args="(const dmat *A, const dmat *wt, const dsp *Wsp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dpinv           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>Wsp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the pseudo inverse of matrix A with weigthing of full matrix W or sparse matrix weighting Wsp. 
<p>
For full matrix, wt can be either W or diag (W) for diagonal weighting. B=inv(A'*W*A)*A'*W; 
</div>
</div><p>
<a class="anchor" name="a91e97f6979658a32b79a70b748b4810"></a><!-- doxytag: member="dmat.h::ddiff" ref="a91e97f6979658a32b79a70b748b4810" args="(const dmat *A, const dmat *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ddiff           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the relative difference betwee two vectors. 
<p>
||A-B||/||A|| using norm2. for debugging purpose. 
</div>
</div><p>
<a class="anchor" name="4529479ba036e3aae3b1827f161a7f9b"></a><!-- doxytag: member="dmat.h::dcircle" ref="4529479ba036e3aae3b1827f161a7f9b" args="(dmat *A, double cx, double cy, double r, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcircle           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
a new gray pixel map generation based on bilinear influence functions used in mkw. 
<p>
creates slightly larger map. add an filled circle. cx,cy,r are in unit of pixels 
</div>
</div><p>
<a class="anchor" name="bb7ee19f9a9bd8c7d4f3fc680a202601"></a><!-- doxytag: member="dmat.h::dcircle_symbolic" ref="bb7ee19f9a9bd8c7d4f3fc680a202601" args="(dmat *A, double cx, double cy, double r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcircle_symbolic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
similar to X(circle). 
<p>
but don't actually compute the weights. just test the corners; 
</div>
</div><p>
<a class="anchor" name="9d9ed91255390f1e4649fc623dfa17ce"></a><!-- doxytag: member="dmat.h::dfftshift" ref="9d9ed91255390f1e4649fc623dfa17ce" args="(dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dfftshift           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
shift frequency components by n/2 
<p>

</div>
</div><p>
<a class="anchor" name="9f252bb4fd703109c58f8c330d6f11df"></a><!-- doxytag: member="dmat.h::dcpcorner2center" ref="9f252bb4fd703109c58f8c330d6f11df" args="(dmat *A, const dmat *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcpcorner2center           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reorder B and embed/crop into center of A 
<p>
<div class="fragment"><pre class="fragment">
   4 * * 3
   * * * *
   * * * *
   2 * * 1
   </pre></div> to <div class="fragment"><pre class="fragment">
   1 2 
   3 4
   </pre></div> 
</div>
</div><p>
<a class="anchor" name="05330b7f5be190a6567ee775e73464c9"></a><!-- doxytag: member="dmat.h::dshift" ref="05330b7f5be190a6567ee775e73464c9" args="(dmat **B0, const dmat *A, int sx, int sy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dshift           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
cyclic shift A by nx and ny to B. 
<p>
<div class="fragment"><pre class="fragment">
   4   3     1   2 
      
   2   1 to  3   4
   </pre></div> 
</div>
</div><p>
<a class="anchor" name="58ed65327dde1b0410fa992eda632d3b"></a><!-- doxytag: member="dmat.h::drotvec" ref="58ed65327dde1b0410fa992eda632d3b" args="(dmat *A, const double theta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drotvec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>theta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
rotate the vectors CCW. 
<p>
same as rotate coordinate theta CW. A(:,1) is x, A(:,2) is y. 
</div>
</div><p>
<a class="anchor" name="b4e3ddd0d5e6249c6d90c26991d8028c"></a><!-- doxytag: member="dmat.h::drotvecnn" ref="b4e3ddd0d5e6249c6d90c26991d8028c" args="(dmat **B0, const dmat *A, double theta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drotvecnn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>theta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
rotate a 2x2 covariance matrix A by theta CCW (coordinate rotate -theta CCW) or from ra to xy coordinate. 
<p>
R*A*R'; 
</div>
</div><p>
<a class="anchor" name="e6580138c809e940eb9105b2b3791292"></a><!-- doxytag: member="dmat.h::dmulvec3" ref="e6580138c809e940eb9105b2b3791292" args="(double *y, const dmat *A, const double *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dmulvec3           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
T matrix vector multiply optimized for just three values. 
<p>
y=A*x; 
</div>
</div><p>
<a class="anchor" name="6531cfb8534d620420fbdf1deffb227c"></a><!-- doxytag: member="dmat.h::dcog" ref="6531cfb8534d620420fbdf1deffb227c" args="(double *grad, const dmat *i0, double offsetx, double offsety, double thres, double bkgrnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcog           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsetx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsety</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>thres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>bkgrnd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute thresholded center of gravity. 
<p>
The threshold is absolute value. bkgrnd is removed from i0 when computing cog. offset is the offset of the reference point (cog=0) from the physical center. all length are given in terms of pixel. 
</div>
</div><p>
<a class="anchor" name="96ba5af3d8d18bfdf35cbbb3a49abd0c"></a><!-- doxytag: member="dmat.h::dshift2center" ref="96ba5af3d8d18bfdf35cbbb3a49abd0c" args="(dmat *A, double offsetx, double offsety)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dshift2center           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsetx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsety</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shift the image in A to center on physical center+[offsetx,offsety] using cog and fft. 
<p>

</div>
</div><p>
<a class="anchor" name="30e08db08cab036374dc0635df4665d6"></a><!-- doxytag: member="dmat.h::dclip" ref="30e08db08cab036374dc0635df4665d6" args="(dmat *A, double min, double max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dclip           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Limit numbers in A to within [min, max]. 
<p>
used for DM clipping. 
</div>
</div><p>
<a class="anchor" name="0131ec62b0a77d0df03e71b35f2d7b85"></a><!-- doxytag: member="dmat.h::dgramschmidt" ref="0131ec62b0a77d0df03e71b35f2d7b85" args="(dmat *Mod, double *amp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dgramschmidt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>amp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
OrthNormalize column vector in Mod, with weighting from vector amp. 
<p>
&lt;Mod|wt|Mod&gt; is equal to sum(wt). 2010-07-21: Bug found: The result is not orthonormal. cause: nonvalid is not initialized to 0. 
</div>
</div><p>
<a class="anchor" name="dd22a26474e6e6af8df941a6b25b0f05"></a><!-- doxytag: member="dmat.h::dmuldiag" ref="dd22a26474e6e6af8df941a6b25b0f05" args="(dmat *A, dmat *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dmuldiag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A=A*B, where diag(B)=s. 
<p>

</div>
</div><p>
<a class="anchor" name="b6f63a9e507f7a58e4f1ba98d7bb3288"></a><!-- doxytag: member="dmat.h::dcwpow" ref="b6f63a9e507f7a58e4f1ba98d7bb3288" args="(dmat *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcwpow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Raise all elements to power power. 
<p>

</div>
</div><p>
<a class="anchor" name="f6edae64ae92dc140f4a85679d6252ae"></a><!-- doxytag: member="dmat.h::dsvd" ref="f6edae64ae92dc140f4a85679d6252ae" args="(dmat **Sdiag, dmat **U, dmat **VT, const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dsvd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>Sdiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
SVD of a general matrix. 
<p>
A=U*diag(S)*V'; diag(S) is returned. 
</div>
</div><p>
<a class="anchor" name="0063f9a3cde12e2b0977ed7a485fbb2c"></a><!-- doxytag: member="dmat.h::dsvd_pow" ref="0063f9a3cde12e2b0977ed7a485fbb2c" args="(dmat *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dsvd_pow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
computes pow(A,power) using svd 
<p>

</div>
</div><p>
<a class="anchor" name="42490ea31b5b30b0b618f417c76bd712"></a><!-- doxytag: member="dmat.h::daddI" ref="42490ea31b5b30b0b618f417c76bd712" args="(dmat *A, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void daddI           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add val to diagonal values of A. 
<p>

</div>
</div><p>
<a class="anchor" name="a23e8df5aa3152c6f01025e956958e9a"></a><!-- doxytag: member="dmat.h::dtikcr" ref="a23e8df5aa3152c6f01025e956958e9a" args="(dmat *A, double thres)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dtikcr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>thres</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply tikhonov regularization to A. 
<p>

</div>
</div><p>
<a class="anchor" name="13ed19366b0b57c73f7a0f37bd20dfb4"></a><!-- doxytag: member="dmat.h::dmulsp" ref="13ed19366b0b57c73f7a0f37bd20dfb4" args="(dmat **yout, const dmat *x, const dsp *A, const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dmulsp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
y=y+alpha*OP(x)*OP(A); implemented by transposing x,y index in sptmulmat implementation TESTED OK. 
<p>

</div>
</div><p>
<a class="anchor" name="3d3dc034d88f0a526fe242b1c1d3b1e5"></a><!-- doxytag: member="dmat.h::dlogspace" ref="3d3dc034d88f0a526fe242b1c1d3b1e5" args="(double emin, double emax, long n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dlogspace           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create log spaced vector. 
<p>

</div>
</div><p>
<a class="anchor" name="f066671d15c55648b99456c410529e33"></a><!-- doxytag: member="dmat.h::dlinspace" ref="f066671d15c55648b99456c410529e33" args="(double emin, double emax, long n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dlinspace           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create linearly spaced vector. 
<p>

</div>
</div><p>
<a class="anchor" name="139bad85f7f26668a547d3bb581a199c"></a><!-- doxytag: member="dmat.h::dinterp1" ref="139bad85f7f26668a547d3bb581a199c" args="(dmat *xin, dmat *yin, dmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dinterp1           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>yin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpolate using linear interp. 
<p>
xin is the coordinate of yin. xnew is the coordinate of the output. 
</div>
</div><p>
<a class="anchor" name="50a81407616c0a439e8d95fdc66c28e1"></a><!-- doxytag: member="dmat.h::dinterp1log" ref="50a81407616c0a439e8d95fdc66c28e1" args="(dmat *xin, dmat *yin, dmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dinterp1log           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>yin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpolate using log(xin) and log(xnew) xin is the coordinate of yin. 
<p>
xnew is the coordinate of the output. 
</div>
</div><p>
<a class="anchor" name="041003260afdf29166953042ddb51e53"></a><!-- doxytag: member="dmat.h::dhistfill" ref="041003260afdf29166953042ddb51e53" args="(dmat **out, const dmat *A, double center, double spacing, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dhistfill           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For each entry in A, call repeatly to collect its histogram, centered at center, spaced by spacing, for n bins in total. 
<p>
center if at bin n/2. 
</div>
</div><p>
<a class="anchor" name="c94bb7e7491459eba07f93115ee7d8a1"></a><!-- doxytag: member="dmat.h::dspline_prep" ref="c94bb7e7491459eba07f93115ee7d8a1" args="(dmat *x, dmat *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dspline_prep           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
1D Cubic spline interpolation preparation. 
<p>
if x has only 1 column: x is the coordinate. y is the function value. if x has two columns: first column is the coordinate, y is null.<p>
It is upto the user to make sure that the coordinate is increasingly ordered and evenly spaced .<p>
If the values of a function <img class="formulaInl" alt="$f(x)$" src="form_6.png"> and its derivative are know at x=0, and x=1 (normalized coordinate), then the function can be interpolated on the interval [0,1] using a third degree polynomial. This is called cubic interpolation. The formula of this polynomial can be easily derived.<p>
A third degree polynomial and its derivative: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x)=ax^3+bx^2+cx+d \]" src="form_7.png">
<p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x)=3ax^3+2bx+c \]" src="form_8.png">
<p>
 The coefficients can be derived from the value and derivatives: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} a&amp;=&amp;2f(0)-2f(1)+f^\prime (0)+f^\prime(1)\\ b&amp;=&amp;-3f(0)+3f(1)-2f^\prime(0)-f^\prime(0)\\ c&amp;=&amp;f^\prime(0)\\ d&amp;=&amp;f(0)\\ \end{eqnarray*}" src="form_9.png">
<p>
 the derivatives can be computed as <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} f^\prime(0)&amp;=&amp;\frac{f(1)-f(-1)}{2}\\ f^\prime(1)&amp;=&amp;\frac{f(2)-f(0)}{2}\\ \end{eqnarray*}" src="form_10.png">
<p>
 so we have the formula <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} a&amp;=&amp;-0.5 f(-1) + 1.5 f(0) - 1.5 f(1) + 0.5 f(2)\\ b&amp;=&amp; f(-1) - 2.5 f(0) + 2 f(1) - 0.5 f(2)\\ c&amp;=&amp;-0.5 f(-1) + 0.5 f(1) \\ d&amp;=&amp; f(0) \\ \end{eqnarray*}" src="form_11.png">
<p>
<p>
for the boundary pints, replace <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(-1))/2\]" src="form_12.png">
<p>
 by <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(0))\]" src="form_13.png">
<p>
 Otehr type of boundaries are handled in the same way.<p>
see <a href="http://www.paulinternet.nl/?page=bicubicx">http://www.paulinternet.nl/?page=bicubicx</a> 
</div>
</div><p>
<a class="anchor" name="d6c71f329b21ee28435a06fd64e828c8"></a><!-- doxytag: member="dmat.h::dspline_eval" ref="d6c71f329b21ee28435a06fd64e828c8" args="(dmat *coeff, dmat *x, dmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dspline_eval           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evluate the cubic spline represented by nx5 matrix coeff, at location array xnew. 
<p>

</div>
</div><p>
<a class="anchor" name="66dcecfdc833ad4174eec33dafc3b8eb"></a><!-- doxytag: member="dmat.h::dspline" ref="66dcecfdc833ad4174eec33dafc3b8eb" args="(dmat *x, dmat *y, dmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dspline           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Do 1D cubic spline all at once by calling X(spline_prep) and X(spline_evald). 
<p>

</div>
</div><p>
<a class="anchor" name="801f95bc127f94b526980791d71e2bb1"></a><!-- doxytag: member="dmat.h::dbspline_prep" ref="801f95bc127f94b526980791d71e2bb1" args="(dmat *x, dmat *y, dmat *z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dbspline_prep           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
2D cubic spline interpolation preparation. 
<p>
x is the x coordinate vector of the 2-d grid. y is the y coordinate vector of the 2-d grid. z is defined on the 2-d grid. It is upto the user to make sure that the coordinate is increasingly ordered and evenly spaced .<p>
The boundaries are handled in the same way is X(spline). i.e. replace <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(-1))/2\]" src="form_12.png">
<p>
 by <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(0))\]" src="form_13.png">
<p>
 Otehr type of boundaries are handled in the same way. 
</div>
</div><p>
<a class="anchor" name="88fcc3be27ce68860cc93c2540c363b2"></a><!-- doxytag: member="dmat.h::dbspline_eval" ref="88fcc3be27ce68860cc93c2540c363b2" args="(dcell *coeff, dmat *x, dmat *y, dmat *xnew, dmat *ynew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dbspline_eval           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>ynew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evaluate 2D cubic spline at location defined 2-d arrays by xnew, ynew. 
<p>

</div>
</div><p>
<a class="anchor" name="86b0f400003435e6813588d09861f438"></a><!-- doxytag: member="dmat.h::dcwlog10" ref="86b0f400003435e6813588d09861f438" args="(dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcwlog10           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Do a component wise log10 on each element of A. 
<p>

</div>
</div><p>
<a class="anchor" name="abf4cf559f55b2e888fed7dd336f6e07"></a><!-- doxytag: member="dmat.h::dcellnew" ref="abf4cf559f55b2e888fed7dd336f6e07" args="(const long nx, const long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellnew           </td>
          <td>(</td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create a new block matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="92bc9490727ab673ba458e0b78b81b05"></a><!-- doxytag: member="dmat.h::dcellnew2" ref="92bc9490727ab673ba458e0b78b81b05" args="(const dcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellnew2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create an new X(cell) similar to A in shape 
<p>

</div>
</div><p>
<a class="anchor" name="e385d21eb33f992fd5ff4d3166d929ba"></a><!-- doxytag: member="dmat.h::dcellzero" ref="e385d21eb33f992fd5ff4d3166d929ba" args="(dcell *dc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellzero           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
setting all elements of a X(cell) to zero. 
<p>

</div>
</div><p>
<a class="anchor" name="a23f0606a6c60596734b1128855dba6d"></a><!-- doxytag: member="dmat.h::dcellset" ref="a23f0606a6c60596734b1128855dba6d" args="(dcell *dc, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
setting all elements of a X(cell) to alpha. 
<p>

</div>
</div><p>
<a class="anchor" name="f306524d189291b53dc6dd8547c4ddf2"></a><!-- doxytag: member="dmat.h::dcellfree_do" ref="f306524d189291b53dc6dd8547c4ddf2" args="(dcell *dc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a X(cell) object. 
<p>

</div>
</div><p>
<a class="anchor" name="faf442e020aff84b8b1fe1766ab89227"></a><!-- doxytag: member="dmat.h::dcelltrans" ref="faf442e020aff84b8b1fe1766ab89227" args="(const dcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcelltrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
transpose a X(cell) object 
<p>

</div>
</div><p>
<a class="anchor" name="31480c8af50a8adc9182fae5285aaa6e"></a><!-- doxytag: member="dmat.h::dcellref" ref="31480c8af50a8adc9182fae5285aaa6e" args="(const dcell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellref           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creat a X(cell) reference an existing X(cell) by referencing the elements. 
<p>

</div>
</div><p>
<a class="anchor" name="dde326a0041feef662127b62b4c37f23"></a><!-- doxytag: member="dmat.h::dcelldup" ref="dde326a0041feef662127b62b4c37f23" args="(const dcell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcelldup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
duplicate a X(cell) object. 
<p>

</div>
</div><p>
<a class="anchor" name="104912d02e021b396d29d78bd2249b95"></a><!-- doxytag: member="dmat.h::dcellcp" ref="104912d02e021b396d29d78bd2249b95" args="(dcell **out0, const dcell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellcp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy the values from one X(cell) to another. 
<p>

</div>
</div><p>
<a class="anchor" name="99511eff251a7861181946af30572ef9"></a><!-- doxytag: member="dmat.h::dcellnorm2" ref="99511eff251a7861181946af30572ef9" args="(const dcell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dcellnorm2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute norm2. 
<p>

</div>
</div><p>
<a class="anchor" name="ae5e354726e58598c4f9a0ab039f0b67"></a><!-- doxytag: member="dmat.h::dcellscale" ref="ae5e354726e58598c4f9a0ab039f0b67" args="(dcell *A, double w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>w</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
scale each element of A. 
<p>

</div>
</div><p>
<a class="anchor" name="805f88ca094efb27fad5861042f5d4a4"></a><!-- doxytag: member="dmat.h::dcellreduce" ref="805f88ca094efb27fad5861042f5d4a4" args="(const dcell *A, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellreduce           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reduce nx*ny cell matrix to 1*ny if dim=1 and nx*11 if dim=2 
<p>

</div>
</div><p>
<a class="anchor" name="cf4358f31eff9028f0204dfceee00eb9"></a><!-- doxytag: member="dmat.h::dcellcat" ref="cf4358f31eff9028f0204dfceee00eb9" args="(const dcell *A, const dcell *B, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellcat           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
concatenate two cell matrices along dimenstion 'dim' 
<p>

</div>
</div><p>
<a class="anchor" name="fb150ef1f6f90d87d2060922e3a2a9b2"></a><!-- doxytag: member="dmat.h::dcellcat_each" ref="fb150ef1f6f90d87d2060922e3a2a9b2" args="(const dcell *A, const dcell *B, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellcat_each           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
concatenate coresponding elements of each X(cell). 
<p>
They must have the same shape. 
</div>
</div><p>
<a class="anchor" name="1e5613fa12d1d0d0b41ff909ac84a33e"></a><!-- doxytag: member="dmat.h::dcelldropempty" ref="1e5613fa12d1d0d0b41ff909ac84a33e" args="(dcell **A0, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcelldropempty           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
drop empty rows or columns. 
<p>
(size of *A0 is changed. 
</div>
</div><p>
<a class="anchor" name="1c506292c4c46d72e8fd573540839ae7"></a><!-- doxytag: member="dmat.h::dcelladd" ref="1c506292c4c46d72e8fd573540839ae7" args="(dcell **B0, double bc, const dcell *A, const double ac)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcelladd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>ac</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add one to another. 
<p>
B=B*bc+A*ac 
</div>
</div><p>
<a class="anchor" name="74eda13294cbbec5c4e93e70d7297301"></a><!-- doxytag: member="dmat.h::dcellinn" ref="74eda13294cbbec5c4e93e70d7297301" args="(const dcell *A, const dcell *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dcellinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the inner produce of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="57b0daa3ccb27a83e4b2235da8eec035"></a><!-- doxytag: member="dmat.h::dcellcwm" ref="57b0daa3ccb27a83e4b2235da8eec035" args="(dcell *B, const dcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellcwm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Component wise multiply of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a> B=A. 
<p>
*B*alpha 
</div>
</div><p>
<a class="anchor" name="2011d79d74ff15b07162da6f0a28fd97"></a><!-- doxytag: member="dmat.h::dcellmm" ref="2011d79d74ff15b07162da6f0a28fd97" args="(dcell **C0, const dcell *A, const dcell *B, const char trans[2], const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellmm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>trans</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute A*B and add to C0. 
<p>
C=C+trans(A)*trans(B)*alpha<p>
2009-11-09: There was initially a beta parameter It was implemented wrongly for beta!=1 because for every call to dmm, the already accumulated ones are scaled. removed beta. 
</div>
</div><p>
<a class="anchor" name="59e3e5c87a7038f6408858c159a166a4"></a><!-- doxytag: member="dmat.h::dcellinvspd" ref="59e3e5c87a7038f6408858c159a166a4" args="(dcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellinvspd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inplace Invert a SPD matrix. 
<p>
It is treated as a block matrix 
</div>
</div><p>
<a class="anchor" name="bdecf8635a39266960e7121b54be57d2"></a><!-- doxytag: member="dmat.h::dcellinv" ref="bdecf8635a39266960e7121b54be57d2" args="(dcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellinv           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inplace Invert a matrix. 
<p>
It is treated as a block matrix. 
</div>
</div><p>
<a class="anchor" name="cc0cce55471ddf4b189b5722f5f93790"></a><!-- doxytag: member="dmat.h::dcellinvspd_each" ref="cc0cce55471ddf4b189b5722f5f93790" args="(dcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellinvspd_each           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
invert each component of the <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>. 
<p>
Each cell is treated as an individual matrix. 
</div>
</div><p>
<a class="anchor" name="02a07132b0fbb4f8fe6afeb3cd55176e"></a><!-- doxytag: member="dmat.h::dcell2m" ref="02a07132b0fbb4f8fe6afeb3cd55176e" args="(const dcell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dcell2m           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a block matrix to a matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="5f5443ca322b4ed2cb65a24e638f928e"></a><!-- doxytag: member="dmat.h::d2cellref" ref="5f5443ca322b4ed2cb65a24e638f928e" args="(const dmat *A, int *dims, int ndim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* d2cellref           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
convert a vector to cell using dimensions specified in dims. 
<p>
Reference the vector 
</div>
</div><p>
<a class="anchor" name="bed4b3e507a4bb20689c0fce64de6c0a"></a><!-- doxytag: member="dmat.h::d2cell" ref="bed4b3e507a4bb20689c0fce64de6c0a" args="(dcell **B, const dmat *A, const dcell *ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void d2cell           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> **&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>ref</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
make A a cell array using shape information from ref if *B is NULL 
<p>

</div>
</div><p>
<a class="anchor" name="4e9d5e166621f79342478304769a43fc"></a><!-- doxytag: member="dmat.h::dcelldropzero" ref="4e9d5e166621f79342478304769a43fc" args="(dcell *B, double thres)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcelldropzero           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>thres</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
drop empty blocks (zero). 
<p>
Size of B is not modified. 
</div>
</div><p>
<a class="anchor" name="ce747978615516a6c46a9dc7b823cdde"></a><!-- doxytag: member="dmat.h::dcelldiff" ref="ce747978615516a6c46a9dc7b823cdde" args="(const dcell *A, const dcell *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dcelldiff           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute ||A-B||/||A|| use mean. 
<p>

</div>
</div><p>
<a class="anchor" name="ba0fbb0b2f60c70c1aeff1921ad82b24"></a><!-- doxytag: member="dmat.h::dcellclip" ref="ba0fbb0b2f60c70c1aeff1921ad82b24" args="(dcell *Ac, double min, double max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dcellclip           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>Ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
clip a X(cell) array to max at 'max', min at 'min' 
<p>

</div>
</div><p>
<a class="anchor" name="8f5e44c289528e1cfecabe114bf98253"></a><!-- doxytag: member="dmat.h::dcelltikcr" ref="8f5e44c289528e1cfecabe114bf98253" args="(dcell *A, double thres)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcelltikcr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>thres</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply tickholov regularization of relative thres to cell array by converting it to mat. 
<p>

</div>
</div><p>
<a class="anchor" name="ed4f051cb2e11032d42d5e91e08f0f99"></a><!-- doxytag: member="dmat.h::dcelladdI" ref="ed4f051cb2e11032d42d5e91e08f0f99" args="(dcell *A, double a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcelladdI           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add a to diagonal elements of A; 
<p>

</div>
</div><p>
<a class="anchor" name="68953d78fbcaa6533fdd78b6b6513243"></a><!-- doxytag: member="dmat.h::dcellsvd_pow" ref="68953d78fbcaa6533fdd78b6b6513243" args="(dcell *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellsvd_pow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the power of a block matrix using svd method. 
<p>
First convert it do X(mat), do the power, and convert back to block matrix. 
</div>
</div><p>
<a class="anchor" name="279fb443e6febe18586edcb53359cf5b"></a><!-- doxytag: member="dmat.h::dcellcwpow" ref="279fb443e6febe18586edcb53359cf5b" args="(dcell *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellcwpow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
raise each cell in the cell array to power of power. 
<p>

</div>
</div><p>
<a class="anchor" name="3452afc53eefe2391f8720999be80c19"></a><!-- doxytag: member="dmat.h::dwritedata" ref="3452afc53eefe2391f8720999be80c19" args="(file_t *fp, const dmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dwritedata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contains routines to write/read dense/sparse matrix into/from file. 
<p>
Function to write dense matrix data into a file pointer. Generally used by library developer 
</div>
</div><p>
<a class="anchor" name="9a8e4a59501eeb3bdd87e490ff04d0e7"></a><!-- doxytag: member="dmat.h::dcellwritedata" ref="9a8e4a59501eeb3bdd87e490ff04d0e7" args="(file_t *fp, const dcell *dc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellwritedata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to write cell array of dense matrix data. 
<p>
into a file pointer Generally used by library developer 
</div>
</div><p>
<a class="anchor" name="41d92768709ddfc9b8862ae55bd6c97e"></a><!-- doxytag: member="dmat.h::dreaddata" ref="41d92768709ddfc9b8862ae55bd6c97e" args="(file_t *fp, uint32_t magic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dreaddata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>magic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to read dense matrix into memory from file pointer. 
<p>
Generally used by library developer. 
</div>
</div><p>
<a class="anchor" name="47f492f62df187672db653542562827b"></a><!-- doxytag: member="dmat.h::dcellreaddata" ref="47f492f62df187672db653542562827b" args="(file_t *fp, uint32_t magic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellreaddata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>magic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to read dense matrix cell array into memory from file pointer. 
<p>
Generally used by library developer. 
</div>
</div><p>
<a class="anchor" name="21964c0cee9cb479b21ad2227a9a60dc"></a><!-- doxytag: member="dmat.h::spwritedata" ref="21964c0cee9cb479b21ad2227a9a60dc" args="(file_t *fp, const dsp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spwritedata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to write sparse matrix data into file pointed using a file pointer. 
<p>
Generally used by library developer. We do not convert data during saving, but rather do the conversion during reading. 
</div>
</div><p>
<a class="anchor" name="f7fe3947f9663085c605a784ba991f95"></a><!-- doxytag: member="dmat.h::spreaddata" ref="f7fe3947f9663085c605a784ba991f95" args="(file_t *fp, uint32_t magic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spreaddata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>magic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to read sparse matrix data from file pointer into memory. 
<p>
Used by library developer. 
</div>
</div><p>
<a class="anchor" name="37ebad9e8c582e694664b562a78114d2"></a><!-- doxytag: member="dmat.h::dwrite" ref="37ebad9e8c582e694664b562a78114d2" args="(const dmat *A, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write dense matrix into a file. 
<p>
Usage: dwrite(A,"A") for double matrix. 
</div>
</div><p>
<a class="anchor" name="70cd951a3932002ccc9270944d2005ec"></a><!-- doxytag: member="dmat.h::dcellwrite" ref="70cd951a3932002ccc9270944d2005ec" args="(const dcell *dc, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcellwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdcell.html">dcell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write cell array of dense matrix into a file. 
<p>
Usage: dcellwrite(A,"A.bin.gz") for double matrix cell. 
</div>
</div><p>
<a class="anchor" name="6406403e91ec976bb0d6c2e12b5d5a0f"></a><!-- doxytag: member="dmat.h::dread" ref="6406403e91ec976bb0d6c2e12b5d5a0f" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read dense matrix into memory from file. 
<p>
Usage: A=dread("A.bin.gz"); for a <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> 
</div>
</div><p>
<a class="anchor" name="dfec4b5637fce6a1cdb10b84d744c8fe"></a><!-- doxytag: member="dmat.h::dcellread" ref="dfec4b5637fce6a1cdb10b84d744c8fe" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read cell array of dense matrix into memory from file. 
<p>
Usage: A=dcellread("A.bin.gz"); for a double <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>. 
</div>
</div><p>
<a class="anchor" name="779cefb17e24b648212cc59f9324f5ae"></a><!-- doxytag: member="dmat.h::spwrite" ref="779cefb17e24b648212cc59f9324f5ae" args="(const dsp *sp, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdsp.html">dsp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write sparse matrix into file. 
<p>
Usage: spwrite(A,"A.bin.gz"); 
</div>
</div><p>
<a class="anchor" name="fa58b8e2aea2a94ae0422ede37957a0f"></a><!-- doxytag: member="dmat.h::spcellwrite" ref="fa58b8e2aea2a94ae0422ede37957a0f" args="(const spcell *spc, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spcellwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structspcell.html">spcell</a> *&nbsp;</td>
          <td class="paramname"> <em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write cell array of sparse matrix into file. 
<p>
Usage: spcellwrite(A,"A.bin.gz"); 
</div>
</div><p>
<a class="anchor" name="06bbd169953a4a808c647bd0a9e6f0d3"></a><!-- doxytag: member="dmat.h::spread" ref="06bbd169953a4a808c647bd0a9e6f0d3" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdsp.html">dsp</a>* spread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read sparse metrix from file. 
<p>
Usage: A=spread("A.bin.gz"); 
</div>
</div><p>
<a class="anchor" name="dda41e6426ecac836fa3dd576f0d2bd9"></a><!-- doxytag: member="dmat.h::spcellread" ref="dda41e6426ecac836fa3dd576f0d2bd9" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structspcell.html">spcell</a>* spcellread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read cell array of sparse matrix from file. 
<p>
Usage: A=spcellread("A.bin.gz"); 
</div>
</div><p>
<a class="anchor" name="316507e4c46251f724a2c22f1db76353"></a><!-- doxytag: member="dmat.h::dnew_mmap" ref="316507e4c46251f724a2c22f1db76353" args="(long nx, long ny, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdmat.html">dmat</a>* dnew_mmap           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(mat) matrix object, mmapped from file. 
<p>
be aware that the data is not 8-byte aligned. The file is truncated if already exists. 
</div>
</div><p>
<a class="anchor" name="a3b557cdaaf833c08dba873203894db5"></a><!-- doxytag: member="dmat.h::dcellnew_mmap" ref="a3b557cdaaf833c08dba873203894db5" args="(long nx, long ny, long *nnx, long *nny, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellnew_mmap           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>nnx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>nny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(cell) matrix cell object, mmapped from file. 
<p>
be aware that the data is not 8-byte aligned. The file is truncated if already exists. 
</div>
</div><p>
<a class="anchor" name="e90d6b50dabcacd842a59ebc2e1326a7"></a><!-- doxytag: member="dmat.h::dcellnewsame_mmap" ref="e90d6b50dabcacd842a59ebc2e1326a7" args="(long nx, long ny, long mx, long my, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdcell.html">dcell</a>* dcellnewsame_mmap           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(cell) matrix cell object, with identical blocks, mmapped from file. 
<p>
be aware that the data is not 8-byte aligned. The file is truncated if already exists. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Nov 24 14:46:54 2010 for maos-0.7.5 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
