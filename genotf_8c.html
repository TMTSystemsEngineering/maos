<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>maos-0.6.4: lib/genotf.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lib/genotf.c File Reference</h1>Routines to generate short exposure OTFs of an aperture in present of atmosphere turbulence.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="genotf_8c.html#fbc4765fbfb746cf0dc53dc620183c16">pttr_B</a> (const double *B0, <a class="el" href="structLOC__T.html">LOC_T</a> *loc, const double *amp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove tip/tilt from the B matrix.  <a href="#fbc4765fbfb746cf0dc53dc620183c16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="genotf_8c.html#74ec534a9a8447da62e0abdd42ea3c94">genotf_do</a> (<a class="el" href="structcmat.html">cmat</a> **otf, int pttr, long notfx, long notfy, <a class="el" href="structLOC__T.html">LOC_T</a> *loc, const double *amp, const double *opdbias, double wvl, const double *B, const T_VALID *pval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate OTF from the B or tip/tilted removed B matrix.  <a href="#74ec534a9a8447da62e0abdd42ea3c94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="genotf_8c.html#4165951e706b75fa2a3f90d72996b2e4">genotf_wrap</a> (GENOTF_T *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A wrapper to execute pttr parallel in pthreads.  <a href="#4165951e706b75fa2a3f90d72996b2e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static T_VALID *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="genotf_8c.html#1740b401e693aa77a65982687cbdec3f">gen_pval</a> (int notfx, int notfy, <a class="el" href="structLOC__T.html">LOC_T</a> *loc, const double *amp, double dtheta, double wvl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate pairs of overlapping points for structure function.  <a href="#1740b401e693aa77a65982687cbdec3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="genotf_8c.html#5b7b07df48f5eb9a640711209f3f49c5">genotfB</a> (<a class="el" href="structLOC__T.html">LOC_T</a> *loc, double wvl, double r0, double L0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the B matrix.  <a href="#5b7b07df48f5eb9a640711209f3f49c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="genotf_8c.html#89fc70b255c4873d8149b93cd5395dc2">genotf</a> (<a class="el" href="structcmat.html">cmat</a> **otf, <a class="el" href="structLOC__T.html">LOC_T</a> *loc, const double *amp, const double *opdbias, const double *area, double thres, double wvl, double dtheta, double r0, double l0, long ncompx, long ncompy, long nsa, long pttr, long nthread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate OTFs for multiple (sub)apertures.  <a href="#89fc70b255c4873d8149b93cd5395dc2"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Routines to generate short exposure OTFs of an aperture in present of atmosphere turbulence. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="fbc4765fbfb746cf0dc53dc620183c16"></a><!-- doxytag: member="genotf.c::pttr_B" ref="fbc4765fbfb746cf0dc53dc620183c16" args="(const double *B0, LOC_T *loc, const double *amp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double* pttr_B           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLOC__T.html">LOC_T</a> *&nbsp;</td>
          <td class="paramname"> <em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>amp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove tip/tilt from the B matrix. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>B0</em>&nbsp;</td><td>The B matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>loc</em>&nbsp;</td><td>The aperture grid </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>amp</em>&nbsp;</td><td>The amplitude map </td></tr>
  </table>
</dl>
<div class="fragment"><pre class="fragment"><a name="l00048"></a>00048             {
<a name="l00049"></a>00049     <span class="keywordtype">double</span> *locx=loc-&gt;<a class="code" href="structLOC__T.html#ed5d420f317a8b4d3f723c02d66a81d4" title="x coordinates of each point">locx</a>;
<a name="l00050"></a>00050     <span class="keywordtype">double</span> *locy=loc-&gt;<a class="code" href="structLOC__T.html#a265d16ab090298e35c3315fcb8daf59" title="y coordinates of each point">locy</a>;
<a name="l00051"></a>00051     <span class="keywordtype">int</span> nloc=loc-&gt;<a class="code" href="structLOC__T.html#fa098eeedb2e665fdd77526f1ff2ca8a" title="number of points">nloc</a>;
<a name="l00052"></a>00052     double (*B)[nloc]=(double(*)[nloc]) B0;
<a name="l00053"></a>00053   
<a name="l00054"></a>00054     <span class="keywordtype">char</span> transn=<span class="charliteral">'N'</span>;
<a name="l00055"></a>00055     <span class="keywordtype">char</span> transt=<span class="charliteral">'T'</span>;
<a name="l00056"></a>00056     <span class="keywordtype">int</span> nmod=3;
<a name="l00057"></a>00057     <span class="keywordtype">double</span> *mod[3];
<a name="l00058"></a>00058     <a class="code" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> *mcc=<a class="code" href="dmat_8h.html#0d7497e2dbb79adb228de6bdde4a201e" title="Create a new T matrix object.">dnew</a>(3,3);
<a name="l00059"></a>00059     double (*cc)[3]=(double(*)[3])mcc-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>;
<a name="l00060"></a>00060     double (*restrict BP)[nloc]=malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*nloc*nloc);
<a name="l00061"></a>00061     
<a name="l00062"></a>00062     <span class="keywordtype">double</span> *restrict M, * restrict MW;
<a name="l00063"></a>00063     double (*restrict MCCT)[3],(*restrict Mtmp)[3];
<a name="l00064"></a>00064     <span class="keywordtype">double</span> dpone=1;
<a name="l00065"></a>00065     <span class="keywordtype">double</span> dpnone=-1;
<a name="l00066"></a>00066     <span class="keywordtype">double</span> dpzero=0;
<a name="l00067"></a>00067     mod[0]=NULL;
<a name="l00068"></a>00068     mod[1]=locx;
<a name="l00069"></a>00069     mod[2]=locy;
<a name="l00070"></a>00070     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> im=0; im&lt;3;im++){
<a name="l00071"></a>00071     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jm=im;jm&lt;3;jm++){
<a name="l00072"></a>00072         cc[jm][im]=<a class="code" href="mathmisc_8c.html#1642051eb049131a4dd20a4585f80d98" title="compute sum(p1.">dotdbl</a>(mod[im], mod[jm], amp, nloc);
<a name="l00073"></a>00073         <span class="keywordflow">if</span>(im!=jm)
<a name="l00074"></a>00074         cc[im][jm]=cc[jm][im];
<a name="l00075"></a>00075     }
<a name="l00076"></a>00076     }
<a name="l00077"></a>00077     <a class="code" href="dmat_8h.html#b48bc9b9c8f923e19dafc70b8fff5de2" title="inplace invert a small square SPD matrix using lapack dposv_, usually (A&amp;#39;*w*A)...">dinvspd_inplace</a>(mcc);
<a name="l00078"></a>00078     M   = malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*nloc*3);
<a name="l00079"></a>00079     MW  = malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*nloc*3);
<a name="l00080"></a>00080     MCCT= malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*nloc*3);
<a name="l00081"></a>00081     Mtmp= malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*nloc*3);
<a name="l00082"></a>00082     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iloc=0; iloc&lt;nloc; iloc++){
<a name="l00083"></a>00083     M[iloc]=1;
<a name="l00084"></a>00084     }
<a name="l00085"></a>00085     memcpy(M+nloc, locx, nloc*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00086"></a>00086     memcpy(M+nloc*2, locy, nloc*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00087"></a>00087     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iloc=0; iloc&lt;nloc; iloc++){
<a name="l00088"></a>00088     MW[iloc]=amp[iloc];
<a name="l00089"></a>00089     MW[iloc+nloc]=amp[iloc]*locx[iloc];
<a name="l00090"></a>00090     MW[iloc+nloc*2]=amp[iloc]*locy[iloc];
<a name="l00091"></a>00091     }
<a name="l00092"></a>00092     <span class="comment">/* MCCT = - cci'*M' */</span>
<a name="l00093"></a>00093     dgemm_(&amp;transt, &amp;transt, 
<a name="l00094"></a>00094        &amp;nmod, &amp;nloc, &amp;nmod, 
<a name="l00095"></a>00095        &amp;dpnone, 
<a name="l00096"></a>00096        (<span class="keywordtype">double</span>*)cc,&amp;nmod,
<a name="l00097"></a>00097        M, &amp;nloc, 
<a name="l00098"></a>00098        &amp;dpzero,
<a name="l00099"></a>00099        (<span class="keywordtype">double</span>*)MCCT,&amp;nmod);
<a name="l00100"></a>00100     <span class="comment">/* Mtmp = MW'*B */</span>
<a name="l00101"></a>00101     dgemm_(&amp;transt, &amp;transn,
<a name="l00102"></a>00102        &amp;nmod, &amp;nloc, &amp;nloc,
<a name="l00103"></a>00103        &amp;dpone, 
<a name="l00104"></a>00104        MW, &amp;nloc,
<a name="l00105"></a>00105        (<span class="keywordtype">double</span>*)B, &amp;nloc,
<a name="l00106"></a>00106        &amp;dpzero, 
<a name="l00107"></a>00107        (<span class="keywordtype">double</span>*)Mtmp, &amp;nmod);
<a name="l00108"></a>00108     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iloc=0; iloc&lt;nloc; iloc++){
<a name="l00109"></a>00109     <span class="keywordtype">double</span> tmp1=Mtmp[iloc][0];
<a name="l00110"></a>00110     <span class="keywordtype">double</span> tmp2=Mtmp[iloc][1];
<a name="l00111"></a>00111     <span class="keywordtype">double</span> tmp3=Mtmp[iloc][2];
<a name="l00112"></a>00112     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> im=0; im&lt;nloc; im++){
<a name="l00113"></a>00113         BP[iloc][im]=B[iloc][im]+
<a name="l00114"></a>00114         (MCCT[im][0]*tmp1+MCCT[im][1]*tmp2+MCCT[im][2]*tmp3);
<a name="l00115"></a>00115     }
<a name="l00116"></a>00116     }
<a name="l00117"></a>00117     <span class="comment">/* Mtmp = MW'*BP' */</span>
<a name="l00118"></a>00118     dgemm_(&amp;transt, &amp;transt,
<a name="l00119"></a>00119        &amp;nmod, &amp;nloc, &amp;nloc,
<a name="l00120"></a>00120        &amp;dpone, 
<a name="l00121"></a>00121        MW, &amp;nloc,
<a name="l00122"></a>00122        (<span class="keywordtype">double</span>*)BP, &amp;nloc,
<a name="l00123"></a>00123        &amp;dpzero, 
<a name="l00124"></a>00124        (<span class="keywordtype">double</span>*)Mtmp, &amp;nmod);
<a name="l00125"></a>00125 
<a name="l00126"></a>00126     <span class="comment">//double *restrict BPD=malloc(sizeof(double)*nloc);</span>
<a name="l00127"></a>00127     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iloc=0; iloc&lt;nloc; iloc++){
<a name="l00128"></a>00128     <span class="keywordtype">double</span> tmp1=MCCT[iloc][0];
<a name="l00129"></a>00129     <span class="keywordtype">double</span> tmp2=MCCT[iloc][1];
<a name="l00130"></a>00130     <span class="keywordtype">double</span> tmp3=MCCT[iloc][2];
<a name="l00131"></a>00131     <span class="comment">/*BPD[iloc]=exp(BP[iloc][iloc]</span>
<a name="l00132"></a>00132 <span class="comment">              +tmp1*Mtmp[iloc][0]</span>
<a name="l00133"></a>00133 <span class="comment">              +tmp2*Mtmp[iloc][1]</span>
<a name="l00134"></a>00134 <span class="comment">              +tmp3*Mtmp[iloc][2]);*/</span>
<a name="l00135"></a>00135     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jloc=0; jloc&lt;nloc; jloc++){
<a name="l00136"></a>00136         <span class="keywordtype">double</span> tmp=BP[iloc][jloc]+tmp1*Mtmp[jloc][0]
<a name="l00137"></a>00137         +tmp2*Mtmp[jloc][1]+tmp3*Mtmp[jloc][2];
<a name="l00138"></a>00138         BP[iloc][jloc]=exp(-2.*tmp);
<a name="l00139"></a>00139     }
<a name="l00140"></a>00140     }
<a name="l00141"></a>00141     dfree(mcc);
<a name="l00142"></a>00142     free(M);
<a name="l00143"></a>00143     free(MW);
<a name="l00144"></a>00144     free(MCCT);
<a name="l00145"></a>00145     free(Mtmp);
<a name="l00146"></a>00146     <span class="keywordflow">return</span> (<span class="keywordtype">double</span>*)BP;
<a name="l00147"></a>00147 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="74ec534a9a8447da62e0abdd42ea3c94"></a><!-- doxytag: member="genotf.c::genotf_do" ref="74ec534a9a8447da62e0abdd42ea3c94" args="(cmat **otf, int pttr, long notfx, long notfy, LOC_T *loc, const double *amp, const double *opdbias, double wvl, const double *B, const T_VALID *pval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void genotf_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>otf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>notfx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>notfy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLOC__T.html">LOC_T</a> *&nbsp;</td>
          <td class="paramname"> <em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>amp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>opdbias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>wvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_VALID *&nbsp;</td>
          <td class="paramname"> <em>pval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate OTF from the B or tip/tilted removed B matrix. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00153"></a>00153                                                     {
<a name="l00154"></a>00154     <span class="keywordtype">int</span> nloc=loc-&gt;<a class="code" href="structLOC__T.html#fa098eeedb2e665fdd77526f1ff2ca8a" title="number of points">nloc</a>;
<a name="l00155"></a>00155     double (*BP)[nloc];
<a name="l00156"></a>00156     <span class="keywordflow">if</span>(pttr){<span class="comment">//remove p/t/t from the B matrix</span>
<a name="l00157"></a>00157     BP=(<span class="keywordtype">void</span>*)<a class="code" href="genotf_8c.html#fbc4765fbfb746cf0dc53dc620183c16" title="Remove tip/tilt from the B matrix.">pttr_B</a>(B,loc,amp);
<a name="l00158"></a>00158     }<span class="keywordflow">else</span>{
<a name="l00159"></a>00159     BP=(<span class="keywordtype">void</span>*)B;
<a name="l00160"></a>00160     }
<a name="l00161"></a>00161    
<a name="l00162"></a>00162     <span class="keywordflow">if</span>(!*otf){
<a name="l00163"></a>00163     *otf=<a class="code" href="cmat_8h.html#bb2b86ffc48237c760e652708aaf1415" title="Create a new T matrix object.">cnew</a>(notfx,notfy);
<a name="l00164"></a>00164     }
<a name="l00165"></a>00165  
<a name="l00166"></a>00166     PCMAT(*otf,OTF);
<a name="l00167"></a>00167  
<a name="l00168"></a>00168 
<a name="l00169"></a>00169     <span class="keywordtype">double</span> *restrict BPD=malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*nloc);
<a name="l00170"></a>00170     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iloc=0; iloc&lt;nloc; iloc++){
<a name="l00171"></a>00171     BPD[iloc]=pow(BP[iloc][iloc],-0.5);
<a name="l00172"></a>00172     }
<a name="l00173"></a>00173     <span class="keywordtype">double</span> otfnorm;
<a name="l00174"></a>00174     otfnorm=0;
<a name="l00175"></a>00175     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iloc=0; iloc&lt;nloc; iloc++){
<a name="l00176"></a>00176     otfnorm+=amp[iloc]*amp[iloc];
<a name="l00177"></a>00177     }
<a name="l00178"></a>00178     otfnorm=1./otfnorm;
<a name="l00179"></a>00179     <span class="keyword">struct </span>T_VALID (*qval)[notfx]=(<span class="keyword">struct</span> T_VALID (*)[notfx])pval;
<a name="l00180"></a>00180     <span class="keywordflow">if</span>(opdbias){
<a name="l00181"></a>00181     dcomplex wvk=2.*M_PI/wvl*I;
<a name="l00182"></a>00182     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jm=0; jm&lt;notfy; jm++){
<a name="l00183"></a>00183         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> im=0; im&lt;notfx; im++){
<a name="l00184"></a>00184         int (*jloc)[2]=qval[jm][im].loc;
<a name="l00185"></a>00185         dcomplex tmp1,tmp2;
<a name="l00186"></a>00186         <span class="keyword">register</span> dcomplex tmp=0.;
<a name="l00187"></a>00187         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iloc=0; iloc&lt;qval[jm][im].n; iloc++){
<a name="l00188"></a>00188             <span class="keywordtype">int</span> iloc1=jloc[iloc][0];<span class="comment">//iloc1 is continuous.</span>
<a name="l00189"></a>00189             <span class="keywordtype">int</span> iloc2=jloc[iloc][1];<span class="comment">//iloc2 is not continuous.</span>
<a name="l00190"></a>00190             tmp1=amp[iloc1]*cexp(wvk*opdbias[iloc1])*BPD[iloc1]*BP[iloc1][iloc2];
<a name="l00191"></a>00191             tmp2=amp[iloc2]*cexp(-wvk*opdbias[iloc2])*BPD[iloc2];
<a name="l00192"></a>00192             tmp+=tmp1*tmp2;
<a name="l00193"></a>00193         }
<a name="l00194"></a>00194         OTF[jm][im]=tmp*otfnorm;
<a name="l00195"></a>00195         }
<a name="l00196"></a>00196     }
<a name="l00197"></a>00197     }<span class="keywordflow">else</span>{
<a name="l00198"></a>00198     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jm=0; jm&lt;notfy; jm++){
<a name="l00199"></a>00199         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> im=0; im&lt;notfx; im++){
<a name="l00200"></a>00200         int (*jloc)[2]=qval[jm][im].loc;
<a name="l00201"></a>00201         <span class="keywordtype">double</span> tmp1,tmp2;
<a name="l00202"></a>00202         <span class="keyword">register</span> <span class="keywordtype">double</span> tmp=0.;
<a name="l00203"></a>00203         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iloc=0; iloc&lt;qval[jm][im].n; iloc++){
<a name="l00204"></a>00204             <span class="keywordtype">int</span> iloc1=jloc[iloc][0];<span class="comment">//iloc1 is continuous.</span>
<a name="l00205"></a>00205             <span class="keywordtype">int</span> iloc2=jloc[iloc][1];<span class="comment">//iloc2 is not continuous.</span>
<a name="l00206"></a>00206             tmp1=amp[iloc1]*BPD[iloc1]*BP[iloc1][iloc2];
<a name="l00207"></a>00207             tmp2=amp[iloc2]*BPD[iloc2];
<a name="l00208"></a>00208             tmp+=tmp1*tmp2;
<a name="l00209"></a>00209         }
<a name="l00210"></a>00210         OTF[jm][im]=tmp*otfnorm;
<a name="l00211"></a>00211         }
<a name="l00212"></a>00212     }
<a name="l00213"></a>00213     }
<a name="l00214"></a>00214     free(BPD);
<a name="l00215"></a>00215     <span class="keywordflow">if</span>((<span class="keywordtype">void</span>*)BP!=(<span class="keywordtype">void</span>*)B){
<a name="l00216"></a>00216     free(BP);
<a name="l00217"></a>00217     }
<a name="l00218"></a>00218 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4165951e706b75fa2a3f90d72996b2e4"></a><!-- doxytag: member="genotf.c::genotf_wrap" ref="4165951e706b75fa2a3f90d72996b2e4" args="(GENOTF_T *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* genotf_wrap           </td>
          <td>(</td>
          <td class="paramtype">GENOTF_T *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A wrapper to execute pttr parallel in pthreads. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00222"></a>00222                                         {
<a name="l00223"></a>00223     <span class="keywordtype">long</span> isa=0;
<a name="l00224"></a>00224     <span class="keyword">const</span> <span class="keywordtype">long</span> nsa=data-&gt;nsa;
<a name="l00225"></a>00225     <a class="code" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a>**otf=(<a class="code" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a>**)data-&gt;otf;
<a name="l00226"></a>00226     <a class="code" href="structLOC__T.html" title="Struct for loc like plocs, xloc, aloc etc.">LOC_T</a> *loc=data-&gt;loc;
<a name="l00227"></a>00227     <span class="keyword">const</span> <span class="keywordtype">long</span> nxsa=loc-&gt;nloc;
<a name="l00228"></a>00228     <span class="keyword">const</span> <span class="keywordtype">double</span> wvl=data-&gt;wvl;
<a name="l00229"></a>00229     <span class="keyword">const</span> <span class="keywordtype">long</span> ncompx=data-&gt;ncompx;
<a name="l00230"></a>00230     <span class="keyword">const</span> <span class="keywordtype">long</span> ncompy=data-&gt;ncompy;
<a name="l00231"></a>00231     <span class="keyword">const</span> <span class="keywordtype">double</span> *area=data-&gt;area;
<a name="l00232"></a>00232     <span class="keyword">const</span> <span class="keywordtype">double</span> thres=data-&gt;thres;
<a name="l00233"></a>00233     <span class="keyword">const</span> <a class="code" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a> *otffull=data-&gt;otffull;
<a name="l00234"></a>00234     <span class="keyword">const</span> <span class="keywordtype">double</span> *amp=data-&gt;amp;
<a name="l00235"></a>00235     <span class="keywordtype">double</span> *B=data-&gt;B;
<a name="l00236"></a>00236     <span class="keyword">const</span> T_VALID *pval=data-&gt;pval;
<a name="l00237"></a>00237     <span class="keywordflow">while</span>(LOCK(data-&gt;mutex_isa),isa=data-&gt;isa++,UNLOCK(data-&gt;mutex_isa),isa&lt;nsa){
<a name="l00238"></a>00238     fprintf(stderr,<span class="stringliteral">"%4ld of %4ld\b\b\b\b\b\b\b\b\b\b\b\b"</span>, isa,nsa);
<a name="l00239"></a>00239     <span class="keyword">const</span> <span class="keywordtype">double</span> *opdbiasi=NULL;
<a name="l00240"></a>00240     <span class="keywordflow">if</span>(data-&gt;opdbias){
<a name="l00241"></a>00241         opdbiasi=data-&gt;opdbias+isa*nxsa;
<a name="l00242"></a>00242     }<span class="keywordflow">else</span>{
<a name="l00243"></a>00243         opdbiasi=NULL;
<a name="l00244"></a>00244     }
<a name="l00245"></a>00245     <span class="keywordflow">if</span>(otffull &amp;&amp; area[isa]&gt;thres){
<a name="l00246"></a>00246         <a class="code" href="cmat_8h.html#db3c55ee96a9e7249403f738d251688c" title="copy the values from one X(mat) to another.">ccp</a>(&amp;otf[isa],otffull);<span class="comment">//just copy the full array</span>
<a name="l00247"></a>00247     }<span class="keywordflow">else</span>{ 
<a name="l00248"></a>00248         <a class="code" href="genotf_8c.html#74ec534a9a8447da62e0abdd42ea3c94" title="Generate OTF from the B or tip/tilted removed B matrix.">genotf_do</a>(&amp;otf[isa],1,ncompx,ncompy,loc,amp+isa*nxsa,opdbiasi,wvl,B,pval);
<a name="l00249"></a>00249     }
<a name="l00250"></a>00250     }
<a name="l00251"></a>00251     <span class="keywordflow">return</span> NULL;
<a name="l00252"></a>00252 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1740b401e693aa77a65982687cbdec3f"></a><!-- doxytag: member="genotf.c::gen_pval" ref="1740b401e693aa77a65982687cbdec3f" args="(int notfx, int notfy, LOC_T *loc, const double *amp, double dtheta, double wvl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static T_VALID* gen_pval           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>notfx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>notfy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLOC__T.html">LOC_T</a> *&nbsp;</td>
          <td class="paramname"> <em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>amp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dtheta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>wvl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate pairs of overlapping points for structure function. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00257"></a>00257                                        {
<a name="l00258"></a>00258     <span class="keywordtype">double</span> dux=1./(dtheta*notfx);
<a name="l00259"></a>00259     <span class="keywordtype">double</span> duy=1./(dtheta*notfy);
<a name="l00260"></a>00260     <span class="keywordtype">int</span> nloc=loc-&gt;<a class="code" href="structLOC__T.html#fa098eeedb2e665fdd77526f1ff2ca8a" title="number of points">nloc</a>;
<a name="l00261"></a>00261     <span class="keywordtype">double</span> *locx=loc-&gt;<a class="code" href="structLOC__T.html#ed5d420f317a8b4d3f723c02d66a81d4" title="x coordinates of each point">locx</a>;
<a name="l00262"></a>00262     <span class="keywordtype">double</span> *locy=loc-&gt;<a class="code" href="structLOC__T.html#a265d16ab090298e35c3315fcb8daf59" title="y coordinates of each point">locy</a>;
<a name="l00263"></a>00263     <span class="keyword">const</span> <span class="keywordtype">int</span> pvaltot=notfx*notfy*nloc*2;
<a name="l00264"></a>00264     int (*pval0)[2]=malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)*pvaltot);
<a name="l00265"></a>00265     T_VALID *pval=malloc(<span class="keyword">sizeof</span>(T_VALID)*notfx*notfy);
<a name="l00266"></a>00266     T_VALID (*restrict qval)[notfx]=(T_VALID (*)[notfx])(pval);
<a name="l00267"></a>00267     <span class="keywordtype">int</span> count=0,count2;
<a name="l00268"></a>00268     <a class="code" href="loc_8c.html#6d3ba3927af00f9e95812485b8cca6dd" title="Create a map for loc with padding of 1.">loc_create_map</a>(loc);
<a name="l00269"></a>00269     <a class="code" href="structLOCMAP__T.html" title="map of locs">LOCMAP_T</a> *map=loc-&gt;<a class="code" href="structLOC__T.html#72938c54993e6e9d0b00bb211d66f2d1" title="point to the map used for identifying neihboring points.">map</a>;
<a name="l00270"></a>00270     <span class="keywordtype">int</span> notfx2=notfx/2;
<a name="l00271"></a>00271     <span class="keywordtype">int</span> notfy2=notfy/2;
<a name="l00272"></a>00272     <span class="keywordtype">double</span> duxwvl=dux*wvl;
<a name="l00273"></a>00273     <span class="keywordtype">double</span> duywvl=duy*wvl;
<a name="l00274"></a>00274     <span class="keywordtype">double</span> dx1=1./loc-&gt;<a class="code" href="structLOC__T.html#ae9e38522a793c7d018028a38fc34ce0" title="Sampling.">dx</a>;
<a name="l00275"></a>00275     <span class="keywordtype">double</span> ampth=1.e-10*<a class="code" href="mathmisc_8c.html#4743ee7b6e7e84249f13db0a14e88063" title="compute the maximum of double vector">maxdbl</a>(amp, nloc);
<a name="l00276"></a>00276     long (*mapp)[map-&gt;<a class="code" href="structLOCMAP__T.html#a53b9f6a08b042a3aa5333de8ff4598d" title="Number of points along x.">nx</a>]=(long(*)[map-&gt;<a class="code" href="structLOCMAP__T.html#a53b9f6a08b042a3aa5333de8ff4598d" title="Number of points along x.">nx</a>])map-&gt;<a class="code" href="structLOCMAP__T.html#a6884f997b7bf3fc1406b6fe4e6ff44b" title="The map, of size nx*ny.">p</a>;
<a name="l00277"></a>00277     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jm=0; jm&lt;notfy; jm++){
<a name="l00278"></a>00278     <span class="keywordtype">int</span> jm2=(jm-notfy2);<span class="comment">//peak in the center</span>
<a name="l00279"></a>00279     <span class="comment">//int jm2=jm&lt;notfy2?jm:jm-notfy;//peak in the corner</span>
<a name="l00280"></a>00280     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> im=0; im&lt;notfx; im++){
<a name="l00281"></a>00281         <span class="keywordtype">int</span> im2=(im-notfx2);
<a name="l00282"></a>00282         <span class="comment">//int im2=im&lt;notfx2?im:im-notfx;</span>
<a name="l00283"></a>00283         count2=count;
<a name="l00284"></a>00284         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iloc=0; iloc&lt;loc-&gt;<a class="code" href="structLOC__T.html#fa098eeedb2e665fdd77526f1ff2ca8a" title="number of points">nloc</a>; iloc++){
<a name="l00285"></a>00285         <span class="keywordtype">int</span> iy=(int)round((locy[iloc]+jm2*duywvl-map-&gt;<a class="code" href="structLOCMAP__T.html#0a28d333e471c48f6955517e9106fb49" title="Origin of the map along y.">oy</a>)*dx1);
<a name="l00286"></a>00286         <span class="keywordtype">int</span> ix=(int)round((locx[iloc]+im2*duxwvl-map-&gt;<a class="code" href="structLOCMAP__T.html#a035d06a3ddd28ba504f54434970d471" title="Origin of the map along x.">ox</a>)*dx1);
<a name="l00287"></a>00287         <span class="keywordflow">if</span> (ix&gt;=0 &amp;&amp; ix&lt;map-&gt;nx &amp;&amp; iy&gt;=0 &amp;&amp; iy&lt;map-&gt;ny) {
<a name="l00288"></a>00288             <span class="keywordtype">long</span> iloc2=mapp[iy][ix];
<a name="l00289"></a>00289             <span class="keywordflow">if</span>(iloc2-- &amp;&amp; amp[iloc]&gt;ampth &amp;&amp; amp[iloc2]&gt;ampth){
<a name="l00290"></a>00290             pval0[count][0]=iloc;
<a name="l00291"></a>00291             pval0[count][1]=iloc2;
<a name="l00292"></a>00292             count++;
<a name="l00293"></a>00293             }
<a name="l00294"></a>00294         }
<a name="l00295"></a>00295         }
<a name="l00296"></a>00296         qval[jm][im].loc=pval0+count2;
<a name="l00297"></a>00297         qval[jm][im].n=count-count2;
<a name="l00298"></a>00298     }
<a name="l00299"></a>00299     }
<a name="l00300"></a>00300     <a class="code" href="loc_8c.html#b4bdd0977410c63912eb4dd14c241f7e" title="Free the MAP in LOC_T.">loc_free_map</a>(loc);
<a name="l00301"></a>00301     <span class="comment">//pval0=realloc(pval0, sizeof(int)*count*2);</span>
<a name="l00302"></a>00302     <span class="comment">//can not realloc. will change position.</span>
<a name="l00303"></a>00303     <span class="keywordflow">return</span> pval;
<a name="l00304"></a>00304 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5b7b07df48f5eb9a640711209f3f49c5"></a><!-- doxytag: member="genotf.c::genotfB" ref="5b7b07df48f5eb9a640711209f3f49c5" args="(LOC_T *loc, double wvl, double r0, double L0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double* genotfB           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLOC__T.html">LOC_T</a> *&nbsp;</td>
          <td class="paramname"> <em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>wvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>L0</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate the B matrix. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00308"></a>00308                                                                     {
<a name="l00309"></a>00309     (void)L0;
<a name="l00310"></a>00310     <span class="keywordtype">long</span> nloc=loc-&gt;<a class="code" href="structLOC__T.html#fa098eeedb2e665fdd77526f1ff2ca8a" title="number of points">nloc</a>;
<a name="l00311"></a>00311     <span class="keywordtype">double</span> *locx=loc-&gt;<a class="code" href="structLOC__T.html#ed5d420f317a8b4d3f723c02d66a81d4" title="x coordinates of each point">locx</a>;
<a name="l00312"></a>00312     <span class="keywordtype">double</span> *locy=loc-&gt;<a class="code" href="structLOC__T.html#a265d16ab090298e35c3315fcb8daf59" title="y coordinates of each point">locy</a>;
<a name="l00313"></a>00313     double(*B)[nloc]=(double(*)[nloc])malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*nloc*nloc);
<a name="l00314"></a>00314     <span class="keyword">const</span> <span class="keywordtype">double</span> coeff=6.88*pow(0.5e-6/wvl,2)*pow(r0,-5./3.)*0.25;
<a name="l00315"></a>00315     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nloc; i++){
<a name="l00316"></a>00316     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=i; j&lt;nloc; j++){
<a name="l00317"></a>00317         <span class="keywordtype">double</span> rdiff2=pow(locx[i]-locx[j],2)+pow(locy[i]-locy[j],2);
<a name="l00318"></a>00318         B[j][i]=B[i][j]=coeff*pow(rdiff2,5./6.);
<a name="l00319"></a>00319     }
<a name="l00320"></a>00320     }
<a name="l00321"></a>00321     <span class="keywordflow">return</span> (<span class="keywordtype">double</span>*)B;
<a name="l00322"></a>00322 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="89fc70b255c4873d8149b93cd5395dc2"></a><!-- doxytag: member="genotf.c::genotf" ref="89fc70b255c4873d8149b93cd5395dc2" args="(cmat **otf, LOC_T *loc, const double *amp, const double *opdbias, const double *area, double thres, double wvl, double dtheta, double r0, double l0, long ncompx, long ncompy, long nsa, long pttr, long nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void genotf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>otf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLOC__T.html">LOC_T</a> *&nbsp;</td>
          <td class="paramname"> <em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>amp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>opdbias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>thres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>wvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dtheta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>l0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ncompx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ncompy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>pttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nthread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate OTFs for multiple (sub)apertures. 
<p>
ALl these apertures must share the same geometry, but may come with different amplitude map and OPD biasas. if pttr is 1, the OTF will have tip/tilt removed. make r0 to infinity to build diffraction limited OTF. make r0 to infinity and opdbias to none null to build OTF for a static map. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>otf</em>&nbsp;</td><td>The otf array for output </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>loc</em>&nbsp;</td><td>the aperture grid (same for all apertures) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>amp</em>&nbsp;</td><td>The amplitude map of all the (sub)apertures </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opdbias</em>&nbsp;</td><td>The static OPD bias. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>area</em>&nbsp;</td><td>normalized area of the (sub)apertures </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thres</em>&nbsp;</td><td>The threshold to consider a (sub)aperture as full </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wvl</em>&nbsp;</td><td>The wavelength. only needef if opdbias is not null </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dtheta</em>&nbsp;</td><td>Sampling of PSF. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r0</em>&nbsp;</td><td>Fried parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l0</em>&nbsp;</td><td>Outer scale </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ncompx</em>&nbsp;</td><td>Size of OTF </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ncompy</em>&nbsp;</td><td>Size of OTF </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nsa</em>&nbsp;</td><td>Number of (sub)apertures </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pttr</em>&nbsp;</td><td>Remove piston/tip/tilt </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nthread</em>&nbsp;</td><td>Number of threads </td></tr>
  </table>
</dl>
<div class="fragment"><pre class="fragment"><a name="l00344"></a>00344           {
<a name="l00345"></a>00345    <span class="comment">/*creating pairs of points that both exist with given separation for</span>
<a name="l00346"></a>00346 <span class="comment">      computing structure function*/</span>
<a name="l00347"></a>00347     T_VALID *pval=<a class="code" href="genotf_8c.html#1740b401e693aa77a65982687cbdec3f" title="Generate pairs of overlapping points for structure function.">gen_pval</a>(ncompx, ncompy, loc, amp, dtheta, wvl);<span class="comment">//returns T_VALID array.</span>
<a name="l00348"></a>00348     <span class="comment">/* Generate the B matrix. */</span>
<a name="l00349"></a>00349     <span class="keywordtype">double</span> *B=<a class="code" href="genotf_8c.html#5b7b07df48f5eb9a640711209f3f49c5" title="Generate the B matrix.">genotfB</a>(loc, wvl, r0, l0);
<a name="l00350"></a>00350     <a class="code" href="bin_8c.html#07e8fcd0256fd8377d0bb0d86bfd3c53" title="Write a double array of size nx*ny to file.">writedbl</a>(B,loc-&gt;<a class="code" href="structLOC__T.html#fa098eeedb2e665fdd77526f1ff2ca8a" title="number of points">nloc</a>,loc-&gt;<a class="code" href="structLOC__T.html#fa098eeedb2e665fdd77526f1ff2ca8a" title="number of points">nloc</a>,<span class="stringliteral">"B"</span>);
<a name="l00351"></a>00351     <a class="code" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a> *otffull=NULL;
<a name="l00352"></a>00352     <span class="keyword">const</span> <span class="keywordtype">long</span> nloc=loc-&gt;<a class="code" href="structLOC__T.html#fa098eeedb2e665fdd77526f1ff2ca8a" title="number of points">nloc</a>;
<a name="l00353"></a>00353     <span class="keywordtype">int</span> isafull=-1;
<a name="l00354"></a>00354     <span class="keywordflow">if</span>(!opdbias &amp;&amp; nsa&gt;1){
<a name="l00355"></a>00355     <span class="keywordtype">double</span> maxarea=0;
<a name="l00356"></a>00356     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> isa=0; isa&lt;nsa; isa++){
<a name="l00357"></a>00357         <span class="keywordflow">if</span>(area[isa]&gt;maxarea){
<a name="l00358"></a>00358         maxarea=area[isa];
<a name="l00359"></a>00359         isafull=isa;
<a name="l00360"></a>00360         }
<a name="l00361"></a>00361     }
<a name="l00362"></a>00362     <span class="keywordflow">if</span>(isafull&gt;0){
<a name="l00363"></a>00363         <a class="code" href="genotf_8c.html#74ec534a9a8447da62e0abdd42ea3c94" title="Generate OTF from the B or tip/tilted removed B matrix.">genotf_do</a>(&amp;otffull,pttr,ncompx,ncompy,loc,amp+isafull*nloc,NULL,wvl,B,pval);
<a name="l00364"></a>00364     }
<a name="l00365"></a>00365     }
<a name="l00366"></a>00366     
<a name="l00367"></a>00367     GENOTF_T data;
<a name="l00368"></a>00368     memset(&amp;data, 0, <span class="keyword">sizeof</span>(GENOTF_T));
<a name="l00369"></a>00369     data.isa=0;
<a name="l00370"></a>00370     data.nsa=nsa;
<a name="l00371"></a>00371     PINIT(data.mutex_isa);
<a name="l00372"></a>00372     data.otf=otf;
<a name="l00373"></a>00373     data.ncompx=ncompx;
<a name="l00374"></a>00374     data.ncompy=ncompy;
<a name="l00375"></a>00375     data.loc=loc;
<a name="l00376"></a>00376     data.amp=amp;
<a name="l00377"></a>00377     data.opdbias=opdbias;
<a name="l00378"></a>00378     data.wvl=wvl;
<a name="l00379"></a>00379     data.B=B;
<a name="l00380"></a>00380     data.pval=pval;
<a name="l00381"></a>00381     data.isafull=isafull;
<a name="l00382"></a>00382     data.otffull=otffull;
<a name="l00383"></a>00383     data.thres=thres;
<a name="l00384"></a>00384     data.area=area;
<a name="l00385"></a>00385     CALL(<a class="code" href="genotf_8c.html#4165951e706b75fa2a3f90d72996b2e4" title="A wrapper to execute pttr parallel in pthreads.">genotf_wrap</a>, &amp;data, nthread);
<a name="l00386"></a>00386     cfree(otffull);
<a name="l00387"></a>00387     free(B);
<a name="l00388"></a>00388     free(pval[0].loc);
<a name="l00389"></a>00389     free(pval);
<a name="l00390"></a>00390 }
</pre></div>
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 29 14:37:09 2010 for maos-0.6.4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
