<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>maos-0.7.1: lib/cmat.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lib/cmat.h File Reference</h1>Contains the mathematically functions regarding to <a class="el" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a> and <a class="el" href="structccell.html" title="an 2-d block matrix of cmat.">ccell</a> object.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#52711a0852dba5f35bab3591c8b2ec09">cnew_ref</a> (dcomplex *p, long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creat a X(mat) object to reference an already existing vector.  <a href="#52711a0852dba5f35bab3591c8b2ec09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0e9274761076691022cbd210922e2107">cnew_data</a> (dcomplex *p, long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creat a X(mat) object with already allocated memory chunk.  <a href="#0e9274761076691022cbd210922e2107"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#bb2b86ffc48237c760e652708aaf1415">cnew</a> (long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new T matrix object.  <a href="#bb2b86ffc48237c760e652708aaf1415"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#856b68d7f24f9f844306dc5580808e9e">cfree_keepdata</a> (<a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the X(mat), but keep the data.  <a href="#856b68d7f24f9f844306dc5580808e9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#275de6db48fa66bf5228f89005903839">cfree_do</a> (<a class="el" href="structcmat.html">cmat</a> *A, int keepdata)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(mat) object.  <a href="#275de6db48fa66bf5228f89005903839"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#35b15d57f984dca577d67bc75fd1cf75">cresize</a> (<a class="el" href="structcmat.html">cmat</a> *A, long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize a matrix by adding or removing columns or rows.  <a href="#35b15d57f984dca577d67bc75fd1cf75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#3f2400e9e770c0f2b7ea98c103cc5c10">cref</a> (<a class="el" href="structcmat.html">cmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creat a X(mat) reference an existing X(mat).  <a href="#3f2400e9e770c0f2b7ea98c103cc5c10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#68a7e2a1455ebc1f35863ea9724d0643">cref_reshape</a> (<a class="el" href="structcmat.html">cmat</a> *in, int nx, int ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create an new X(mat) reference another with different shape.  <a href="#68a7e2a1455ebc1f35863ea9724d0643"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#16a273177027c4134922936b2440c72e">crefcols</a> (<a class="el" href="structcmat.html">cmat</a> *in, long icol, long ncol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creat a new X(mat) referencing columns in existing X(mat).  <a href="#16a273177027c4134922936b2440c72e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#c82f2f9e84a8c582dfa64b207036fab9">csub</a> (const <a class="el" href="structcmat.html">cmat</a> *in, long sx, long nx, long sy, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new sub matrix of nx*ny starting from(sx,sy).  <a href="#c82f2f9e84a8c582dfa64b207036fab9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#a599a4058986f102d01ddcb6723af232">ccat</a> (const <a class="el" href="structcmat.html">cmat</a> *in1, const <a class="el" href="structcmat.html">cmat</a> *in2, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">concatenate two matrixes into 1 along dimension "dim"  <a href="#a599a4058986f102d01ddcb6723af232"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#6018457a413452c4e0fbce6a80da6b4b">carrfree</a> (<a class="el" href="structcmat.html">cmat</a> **As, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(mat) array.  <a href="#6018457a413452c4e0fbce6a80da6b4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#66d5a6e5e44f4035aa069d75c47eaf84">cdup</a> (const <a class="el" href="structcmat.html">cmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">duplicate a X(mat) array  <a href="#66d5a6e5e44f4035aa069d75c47eaf84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#db3c55ee96a9e7249403f738d251688c">ccp</a> (<a class="el" href="structcmat.html">cmat</a> **out0, const <a class="el" href="structcmat.html">cmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy the values from one X(mat) to another.  <a href="#db3c55ee96a9e7249403f738d251688c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#79a7b4a12c6fe0066453af5aac05197e">ctrans</a> (const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">transpose a X(mat) object  <a href="#79a7b4a12c6fe0066453af5aac05197e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#aa3be1e7b9926d4753d27b833b4735aa">cset</a> (<a class="el" href="structcmat.html">cmat</a> *A, const dcomplex val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set values of each element in a X(mat) to val.  <a href="#aa3be1e7b9926d4753d27b833b4735aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#5f6b5be2adda9848d051174da45fc340">czero</a> (<a class="el" href="structcmat.html">cmat</a> *out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialize all numbers in a X(mat) object to 0  <a href="#5f6b5be2adda9848d051174da45fc340"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#917d70d3162af1387e34ab3bd76b14fd">cmax</a> (const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find the maximum value of a X(mat) object  <a href="#917d70d3162af1387e34ab3bd76b14fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#638c8d3934ebd94ceaf7394966ce86f7">cmin</a> (const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find the minimum value of a X(mat) object  <a href="#638c8d3934ebd94ceaf7394966ce86f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#b53df31a0c2920c26bd6a58d1d76e967">cnorm2</a> (const <a class="el" href="structcmat.html">cmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the norm2 of A  <a href="#b53df31a0c2920c26bd6a58d1d76e967"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#c3c96d46d8b041763eb81436fd31ae60">crandu</a> (<a class="el" href="structcmat.html">cmat</a> *A, const dcomplex mean, <a class="el" href="structmt__state.html">rand_t</a> *rstat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill A with random uniform numbers between [0, 1]*max.  <a href="#c3c96d46d8b041763eb81436fd31ae60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#87d59b705aa5c40cb2fdee249053aab2">crandn</a> (<a class="el" href="structcmat.html">cmat</a> *A, const dcomplex sigma, <a class="el" href="structmt__state.html">rand_t</a> *rstat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill A with random normal distribution numbers with standard deviation of sigma.  <a href="#87d59b705aa5c40cb2fdee249053aab2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#c0f00cb8f71b144c21627d1da2dcfb3f">cshow</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">display a X(mat) matrix.  <a href="#c0f00cb8f71b144c21627d1da2dcfb3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#204751357459432e00c5f5ee8d261f56">cscale</a> (<a class="el" href="structcmat.html">cmat</a> *A, dcomplex w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">scale each element of A by w  <a href="#204751357459432e00c5f5ee8d261f56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#cf3340d336a63035bc4aacd6fb03fd87">csum</a> (const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create sum of all the elements in A.  <a href="#cf3340d336a63035bc4aacd6fb03fd87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#8b4328dbfb8ced02b3ef2f523d4e37f5">cadd</a> (<a class="el" href="structcmat.html">cmat</a> **B0, dcomplex bc, const <a class="el" href="structcmat.html">cmat</a> *A, const dcomplex ac)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute B=bc*B+ac*A behavior changed on 2009-11-02.  <a href="#8b4328dbfb8ced02b3ef2f523d4e37f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#a5c02f882f7897bcafa6e65cf8a13c28">cinn</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the inner product of A and B.  <a href="#a5c02f882f7897bcafa6e65cf8a13c28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#8c64a290f550b8e43a6a100d216de986">cwdot</a> (const dcomplex *a, const <a class="el" href="structcmat.html">cmat</a> *w, const dcomplex *b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute weighted dot product a'*(w*b)  <a href="#8c64a290f550b8e43a6a100d216de986"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#c8a9b196602cd2b72cae912c49e4b504">cwdot2</a> (const dcomplex *a, const <a class="el" href="structcmat.html">cmat</a> *w, const dcomplex *b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">special version of dwdot for just 2 element vectors.  <a href="#c8a9b196602cd2b72cae912c49e4b504"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#94c0d4a66c6d83215f077cffcba34146">cwdot3</a> (const dcomplex *a, const <a class="el" href="structcmat.html">cmat</a> *w, const dcomplex *b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">special version of dwdot for just 3 element vectors.  <a href="#94c0d4a66c6d83215f077cffcba34146"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#2417a6c93f1245cf129586dce262aba3">ccwm</a> (<a class="el" href="structcmat.html">cmat</a> *B, const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute component wise multiply B=B.  <a href="#2417a6c93f1245cf129586dce262aba3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#5012aabec0611cd938b01765c892f6b3">cmulvec</a> (dcomplex *restrict y, const <a class="el" href="structcmat.html">cmat</a> *restrict A, const dcomplex *restrict x, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">multiply a X(mat) matrix with a vector and accumulate to y: y+=A*x*alpha  <a href="#5012aabec0611cd938b01765c892f6b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#da9977993e68f94425418b2c68d1789d">cmm</a> (<a class="el" href="structcmat.html">cmat</a> **C0, const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *B, const char trans[2], const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute matrix product using blas dgemm with beta=1; C=beta*C+ alpha *trans(A)*trans(B); if C exist.  <a href="#da9977993e68f94425418b2c68d1789d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#16f114b8d7e5173d9928b3dbb3f268a5">cinvspd_inplace</a> (<a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace invert a small square SPD matrix using lapack dposv_, usually (A'*w*A).  <a href="#16f114b8d7e5173d9928b3dbb3f268a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#d2251ee97ee6cd88196f8fb03f4ac880">cinvspd</a> (const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">out of place version of dinvspd_inplace  <a href="#d2251ee97ee6cd88196f8fb03f4ac880"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#fe6927dc25de67288c63961b3340f69c">cinv_inplace</a> (<a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace invert a general square matrix using lapack dgesv_  <a href="#fe6927dc25de67288c63961b3340f69c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#aad7fd796188a37ff988b75286ff1906">cinv</a> (const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">out of place version of dinv  <a href="#aad7fd796188a37ff988b75286ff1906"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#63f8f6199cd41366c1fdd40717c6b3c3">cmcc</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *wt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute (A'*W*A); where diag(W)=wt  <a href="#63f8f6199cd41366c1fdd40717c6b3c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#4a8db9c35e106c64a679ae96beb61b66">cimcc</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *wt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute inv(dmcc(A, wt))  <a href="#4a8db9c35e106c64a679ae96beb61b66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#364b9a68838d38ae710f3ade6e5e5820">ctmcc</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *wt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute (A*W*A'); where diag(W)=wt  <a href="#364b9a68838d38ae710f3ade6e5e5820"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#862a7aa868fe53404dc29d060b5f044d">cpinv</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *wt, const <a class="el" href="structcsp.html">csp</a> *Wsp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the pseudo inverse of matrix A with weigthing of full matrix W or sparse matrix weighting Wsp.  <a href="#862a7aa868fe53404dc29d060b5f044d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#77dbd9fcfc2e3185fc072bd6bec5e5e5">cdiff</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the relative difference betwee two vectors.  <a href="#77dbd9fcfc2e3185fc072bd6bec5e5e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#f962ae5334dec4a29e6626bc0be8b19b">ccircle</a> (<a class="el" href="structcmat.html">cmat</a> *A, double cx, double cy, double r, dcomplex val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a new gray pixel map generation based on bilinear influence functions used in mkw.  <a href="#f962ae5334dec4a29e6626bc0be8b19b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#779b108bf238d17187f25d3eee0f3fe9">ccircle_symbolic</a> (<a class="el" href="structcmat.html">cmat</a> *A, double cx, double cy, double r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">similar to X(circle).  <a href="#779b108bf238d17187f25d3eee0f3fe9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#2e68e24dcc5d7ffd8d9b2c575e0830b9">cfftshift</a> (<a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">shift frequency components by n/2  <a href="#2e68e24dcc5d7ffd8d9b2c575e0830b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#72f5647463dae0b89a5c8e444f580de0">ccpcorner2center</a> (<a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reorder B and embed/crop into center of A  <a href="#72f5647463dae0b89a5c8e444f580de0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#834e5e2f254160faa414569a60282089">cshift</a> (<a class="el" href="structcmat.html">cmat</a> **B0, const <a class="el" href="structcmat.html">cmat</a> *A, int sx, int sy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cyclic shift A by nx and ny to B.  <a href="#834e5e2f254160faa414569a60282089"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#1cccdaf44daa400ae770f49e5dc91771">crotvec</a> (<a class="el" href="structcmat.html">cmat</a> *A, const double theta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">rotate the vectors CCW.  <a href="#1cccdaf44daa400ae770f49e5dc91771"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#39e013291512a0930b8e18ba7efd9071">crotvecnn</a> (<a class="el" href="structcmat.html">cmat</a> **B0, const <a class="el" href="structcmat.html">cmat</a> *A, double theta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">rotate a 2x2 covariance matrix A by theta CCW (coordinate rotate -theta CCW) or from ra to xy coordinate.  <a href="#39e013291512a0930b8e18ba7efd9071"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#b7184001fed6ff87e17292e2092ee4b8">cmulvec3</a> (dcomplex *y, const <a class="el" href="structcmat.html">cmat</a> *A, const dcomplex *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">T matrix vector multiply optimized for just three values.  <a href="#b7184001fed6ff87e17292e2092ee4b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#689ab6d12867fee7225a83f93f1a0a9d">ccog</a> (double *grad, const <a class="el" href="structcmat.html">cmat</a> *i0, double offsetx, double offsety, double thres, double bkgrnd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute thresholded center of gravity.  <a href="#689ab6d12867fee7225a83f93f1a0a9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#47b5130ae904c436b75d6699abf025c6">cshift2center</a> (<a class="el" href="structcmat.html">cmat</a> *A, double offsetx, double offsety)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift the image in A to center on physical center+[offsetx,offsety] using cog and fft.  <a href="#47b5130ae904c436b75d6699abf025c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#66f7b38cee9d08a96f2b6e4b5c971fa4">cclip</a> (<a class="el" href="structcmat.html">cmat</a> *A, double min, double max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limit numbers in A to within [min, max].  <a href="#66f7b38cee9d08a96f2b6e4b5c971fa4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#77fc55aade8619fa7fab51a2887f0535">cgramschmidt</a> (<a class="el" href="structcmat.html">cmat</a> *Mod, double *amp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">OrthNormalize column vector in Mod, with weighting from vector amp.  <a href="#77fc55aade8619fa7fab51a2887f0535"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#8d75289b919758fc3d3919b6026ba406">cmuldiag</a> (<a class="el" href="structcmat.html">cmat</a> *A, <a class="el" href="structcmat.html">cmat</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A=A*B, where diag(B)=s.  <a href="#8d75289b919758fc3d3919b6026ba406"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#dd74de8c67cb4e5f897778c0268d7744">ccwpow</a> (<a class="el" href="structcmat.html">cmat</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raise all elements to power power.  <a href="#dd74de8c67cb4e5f897778c0268d7744"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#ea36bb01ebe29d23687c2d6738080de1">csvd</a> (<a class="el" href="structdmat.html">dmat</a> **Sdiag, <a class="el" href="structcmat.html">cmat</a> **U, <a class="el" href="structcmat.html">cmat</a> **VT, const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SVD of a general matrix.  <a href="#ea36bb01ebe29d23687c2d6738080de1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#e3d755e9c6714e93a155d710b421dd06">csvd_pow</a> (<a class="el" href="structcmat.html">cmat</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes pow(A,power) using svd  <a href="#e3d755e9c6714e93a155d710b421dd06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#2289f10c6693d6253721db413bb7d61f">caddI</a> (<a class="el" href="structcmat.html">cmat</a> *A, dcomplex val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add val to diagonal values of A.  <a href="#2289f10c6693d6253721db413bb7d61f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#d39a391d8bbcc4b7576df57820fc8eb7">ctikcr</a> (<a class="el" href="structcmat.html">cmat</a> *A, dcomplex thres)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply tikhonov regularization to A.  <a href="#d39a391d8bbcc4b7576df57820fc8eb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#d1f4093f58b84b2e125919868b103a88">cmulsp</a> (<a class="el" href="structcmat.html">cmat</a> **yout, const <a class="el" href="structcmat.html">cmat</a> *x, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">y=y+alpha*OP(x)*OP(A); implemented by transposing x,y index in sptmulmat implementation TESTED OK.  <a href="#d1f4093f58b84b2e125919868b103a88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#071ca1c1e64bb1ae6b9ca352a69a31b0">clogspace</a> (double emin, double emax, long n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create log spaced vector.  <a href="#071ca1c1e64bb1ae6b9ca352a69a31b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#5d357153670b6ce7f3eb9b7dee553912">clinspace</a> (double emin, double emax, long n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create linearly spaced vector.  <a href="#5d357153670b6ce7f3eb9b7dee553912"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#e546d587249af8bbb4c09a03ff2cb9fd">cinterp1</a> (<a class="el" href="structdmat.html">dmat</a> *xin, <a class="el" href="structdmat.html">dmat</a> *yin, <a class="el" href="structdmat.html">dmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolate using linear interp.  <a href="#e546d587249af8bbb4c09a03ff2cb9fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0fcc7887067339b812f96bc684f47f4c">cinterp1log</a> (<a class="el" href="structdmat.html">dmat</a> *xin, <a class="el" href="structdmat.html">dmat</a> *yin, <a class="el" href="structdmat.html">dmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolate using log(xin) and log(xnew) xin is the coordinate of yin.  <a href="#0fcc7887067339b812f96bc684f47f4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#10d49d59390d39b5398979a55f90441a">chistfill</a> (<a class="el" href="structdmat.html">dmat</a> **out, const <a class="el" href="structcmat.html">cmat</a> *A, double center, double spacing, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For each entry in A, call repeatly to collect its histogram, centered at center, spaced by spacing, for n bins in total.  <a href="#10d49d59390d39b5398979a55f90441a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#1f6ecbeecb56f05d855f3e1f21342dc2">cspline_prep</a> (<a class="el" href="structcmat.html">cmat</a> *x, <a class="el" href="structcmat.html">cmat</a> *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">1D Cubic spline interpolation preparation.  <a href="#1f6ecbeecb56f05d855f3e1f21342dc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#105e0e17a7f377c30b63ff9bc5f002e1">cspline_eval</a> (<a class="el" href="structcmat.html">cmat</a> *coeff, <a class="el" href="structcmat.html">cmat</a> *x, <a class="el" href="structcmat.html">cmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evluate the cubic spline represented by nx5 matrix coeff, at location array xnew.  <a href="#105e0e17a7f377c30b63ff9bc5f002e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#6dc13156073384a5722fcf7fd5f0833a">cspline</a> (<a class="el" href="structcmat.html">cmat</a> *x, <a class="el" href="structcmat.html">cmat</a> *y, <a class="el" href="structcmat.html">cmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do 1D cubic spline all at once by calling X(spline_prep) and X(spline_evald).  <a href="#6dc13156073384a5722fcf7fd5f0833a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#6d44ad8fe4da7595e7b54ac85015cfaa">cbspline_prep</a> (<a class="el" href="structcmat.html">cmat</a> *x, <a class="el" href="structcmat.html">cmat</a> *y, <a class="el" href="structcmat.html">cmat</a> *z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2D cubic spline interpolation preparation.  <a href="#6d44ad8fe4da7595e7b54ac85015cfaa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#ee339b2c28b3fcf24144233e6b078002">cbspline_eval</a> (<a class="el" href="structccell.html">ccell</a> *coeff, <a class="el" href="structcmat.html">cmat</a> *x, <a class="el" href="structcmat.html">cmat</a> *y, <a class="el" href="structcmat.html">cmat</a> *xnew, <a class="el" href="structcmat.html">cmat</a> *ynew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate 2D cubic spline at location defined 2-d arrays by xnew, ynew.  <a href="#ee339b2c28b3fcf24144233e6b078002"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#cdcbda2dbd5dfec8344b8bada36a0a35">ccellnew</a> (const long nx, const long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a new block matrix.  <a href="#cdcbda2dbd5dfec8344b8bada36a0a35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#3e751c651d80acbebc93a7536bfd4e65">ccellnew2</a> (const <a class="el" href="structccell.html">ccell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create an new X(cell) similar to A in shape  <a href="#3e751c651d80acbebc93a7536bfd4e65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#193a03f98ee7128386819d9821ceb859">ccellzero</a> (<a class="el" href="structccell.html">ccell</a> *dc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">setting all elements of a X(cell) to zero.  <a href="#193a03f98ee7128386819d9821ceb859"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#d9128f3e7703bfc29bb33d37397cf5c6">ccellset</a> (<a class="el" href="structccell.html">ccell</a> *dc, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">setting all elements of a X(cell) to alpha.  <a href="#d9128f3e7703bfc29bb33d37397cf5c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#6631a2e1f0b26b3b14723cb8e127ab11">ccellfree_do</a> (<a class="el" href="structccell.html">ccell</a> *dc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a X(cell) object.  <a href="#6631a2e1f0b26b3b14723cb8e127ab11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#db8e69bbe2c05a039f236fbb2eae12de">ccelltrans</a> (const <a class="el" href="structccell.html">ccell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">transpose a X(cell) object  <a href="#db8e69bbe2c05a039f236fbb2eae12de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#1f870a53b480b1477c2bc30e0178a516">ccellref</a> (const <a class="el" href="structccell.html">ccell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creat a X(cell) reference an existing X(cell) by referencing the elements.  <a href="#1f870a53b480b1477c2bc30e0178a516"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0ed077f33b1a869fd6154ded4b557a4b">ccelldup</a> (const <a class="el" href="structccell.html">ccell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">duplicate a X(cell) object.  <a href="#0ed077f33b1a869fd6154ded4b557a4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#84b4ddc50d2114e9be97128fdf424e07">ccellcp</a> (<a class="el" href="structccell.html">ccell</a> **out0, const <a class="el" href="structccell.html">ccell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy the values from one X(cell) to another.  <a href="#84b4ddc50d2114e9be97128fdf424e07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#83dd0483ef61373a16ee4c5478a919d1">ccellnorm2</a> (const <a class="el" href="structccell.html">ccell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute norm2.  <a href="#83dd0483ef61373a16ee4c5478a919d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0f63e81c5c497006f9f355a1f288cf91">ccellscale</a> (<a class="el" href="structccell.html">ccell</a> *A, double w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">scale each element of A.  <a href="#0f63e81c5c497006f9f355a1f288cf91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#00c2da2fc7f3d49037226159745c2378">ccellreduce</a> (const <a class="el" href="structccell.html">ccell</a> *A, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reduce nx*ny cell matrix to 1*ny if dim=1 and nx*11 if dim=2  <a href="#00c2da2fc7f3d49037226159745c2378"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#6bc29f4fe8fda3c3a1ca2fe3ac56b126">ccellcat</a> (const <a class="el" href="structccell.html">ccell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">concatenate two cell matrices along dimenstion 'dim'  <a href="#6bc29f4fe8fda3c3a1ca2fe3ac56b126"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#46bafd0a0ab7198be7c8c7ad4c42f88b">ccellcat_each</a> (const <a class="el" href="structccell.html">ccell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">concatenate coresponding elements of each X(cell).  <a href="#46bafd0a0ab7198be7c8c7ad4c42f88b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#d65426e91446c2e95481a47fc9e8716a">ccelldropempty</a> (<a class="el" href="structccell.html">ccell</a> **A0, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">drop empty rows or columns.  <a href="#d65426e91446c2e95481a47fc9e8716a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#e52c5a573fcaa559847488c664365e62">ccelladd</a> (<a class="el" href="structccell.html">ccell</a> **B0, double bc, const <a class="el" href="structccell.html">ccell</a> *A, const double ac)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add one to another.  <a href="#e52c5a573fcaa559847488c664365e62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#df204a1a88694e37365a17488d1e12c8">ccellinn</a> (const <a class="el" href="structccell.html">ccell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the inner produce of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>.  <a href="#df204a1a88694e37365a17488d1e12c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#92110ce17c83d4a1f68d856ec32a90cd">ccellcwm</a> (<a class="el" href="structccell.html">ccell</a> *B, const <a class="el" href="structccell.html">ccell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Component wise multiply of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a> B=A.  <a href="#92110ce17c83d4a1f68d856ec32a90cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#afe341e06821b09968d37a530a3adc3e">ccellmm</a> (<a class="el" href="structccell.html">ccell</a> **C0, const <a class="el" href="structccell.html">ccell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, const char trans[2], const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute A*B and add to C0.  <a href="#afe341e06821b09968d37a530a3adc3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#99b65983778109d4aa815d3ea5db9414">ccellinvspd</a> (<a class="el" href="structccell.html">ccell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Invert a SPD matrix.  <a href="#99b65983778109d4aa815d3ea5db9414"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#ddb2ebf6b55726391b1ea6be0e210e2e">ccellinv</a> (<a class="el" href="structccell.html">ccell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Invert a matrix.  <a href="#ddb2ebf6b55726391b1ea6be0e210e2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#72a43514eb1abfbe161f74f5a223f2f5">ccellinvspd_each</a> (<a class="el" href="structccell.html">ccell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">invert each component of the <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>.  <a href="#72a43514eb1abfbe161f74f5a223f2f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#2c8c0809e00fd5d528cbb31048f3c52a">ccell2m</a> (const <a class="el" href="structccell.html">ccell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a block matrix to a matrix.  <a href="#2c8c0809e00fd5d528cbb31048f3c52a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#1545f84a1ac4226ce43fbfc8ba0af5db">c2cellref</a> (const <a class="el" href="structcmat.html">cmat</a> *A, int *dims, int ndim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convert a vector to cell using dimensions specified in dims.  <a href="#1545f84a1ac4226ce43fbfc8ba0af5db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#a5983177f2055cae1bb16f5a53e3f4aa">c2cell</a> (<a class="el" href="structccell.html">ccell</a> **B, const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structccell.html">ccell</a> *ref)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">make A a cell array using shape information from ref if *B is NULL  <a href="#a5983177f2055cae1bb16f5a53e3f4aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#b0d7e1c7d7eb2810eff34b04111129c8">ccelldropzero</a> (<a class="el" href="structccell.html">ccell</a> *B, double thres)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">drop empty blocks (zero).  <a href="#b0d7e1c7d7eb2810eff34b04111129c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#2fd83c2f600649a6205e8c62547f6e8d">ccelldiff</a> (const <a class="el" href="structccell.html">ccell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute ||A-B||/||A|| use mean.  <a href="#2fd83c2f600649a6205e8c62547f6e8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#fdb96e19ff1dfea164570fc47815a2ab">ccellclip</a> (<a class="el" href="structccell.html">ccell</a> *Ac, double min, double max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">clip a X(cell) array to max at 'max', min at 'min'  <a href="#fdb96e19ff1dfea164570fc47815a2ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#6e30556d58339cea7a00a4b163822af4">ccelltikcr</a> (<a class="el" href="structccell.html">ccell</a> *A, double thres)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply tickholov regularization of relative thres to cell array by converting it to mat.  <a href="#6e30556d58339cea7a00a4b163822af4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0a9902ff737584f210c3730f430b1599">ccellpinv</a> (const <a class="el" href="structccell.html">ccell</a> *A, const <a class="el" href="structccell.html">ccell</a> *wt, const <a class="el" href="structcspcell.html">cspcell</a> *Wsp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the pseudo inverse of block matrix A.  <a href="#0a9902ff737584f210c3730f430b1599"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#611ce556f87c2ac01da0b00b717cd964">ccellmulsp</a> (<a class="el" href="structccell.html">ccell</a> **C0, const <a class="el" href="structccell.html">ccell</a> *A, const <a class="el" href="structcspcell.html">cspcell</a> *B, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a cell with a sparse cell.  <a href="#611ce556f87c2ac01da0b00b717cd964"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#35a0966fdc0e65bdcf290c75e0404713">ccelladdI</a> (<a class="el" href="structccell.html">ccell</a> *A, double a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add a to diagonal elements of A;  <a href="#35a0966fdc0e65bdcf290c75e0404713"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#d7eece0d6b59dbc7d2e98d5ce866b21b">ccellsvd_pow</a> (<a class="el" href="structccell.html">ccell</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the power of a block matrix using svd method.  <a href="#d7eece0d6b59dbc7d2e98d5ce866b21b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#92d8633d3243ae2a95e43d6b41c4a2cb">ccellcwpow</a> (<a class="el" href="structccell.html">ccell</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">raise each cell in the cell array to power of power.  <a href="#92d8633d3243ae2a95e43d6b41c4a2cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#28f2c1a91c80f5dc8c951f875d79f2de">cwritedata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp, const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains routines to write/read dense/sparse matrix into/from file.  <a href="#28f2c1a91c80f5dc8c951f875d79f2de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#5fc25bdbb6758549b60bc4b9c34a9bef">ccellwritedata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp, const <a class="el" href="structccell.html">ccell</a> *dc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to write cell array of dense matrix data.  <a href="#5fc25bdbb6758549b60bc4b9c34a9bef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#e9df93488639190f0b09a837ba21fd3e">creaddata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to read dense matrix into memory from file pointer.  <a href="#e9df93488639190f0b09a837ba21fd3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#41b9a0829de990592462d11aedcb2fa5">ccellreaddata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to read dense matrix cell array into memory from file pointer.  <a href="#41b9a0829de990592462d11aedcb2fa5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#c856ab97d0032304beb9cb4fe0465528">cspwritedata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp, const <a class="el" href="structcsp.html">csp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to write sparse matrix data into file pointed using a file pointer.  <a href="#c856ab97d0032304beb9cb4fe0465528"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#c52d1399af426794abf242869a2ec077">cspreaddata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to read sparse matrix data from file pointer into memory.  <a href="#c52d1399af426794abf242869a2ec077"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#9593e890699be4f48e826d9048018c04">cwrite</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write dense matrix into a file.  <a href="#9593e890699be4f48e826d9048018c04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#e75214457fa1e5c394d311b307a7f5e4">ccellwrite</a> (const <a class="el" href="structccell.html">ccell</a> *dc, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write cell array of dense matrix into a file.  <a href="#e75214457fa1e5c394d311b307a7f5e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#d68739105dfbaca4f86b98fe0666f259">cread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read dense matrix into memory from file.  <a href="#d68739105dfbaca4f86b98fe0666f259"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0a22a48812769ec4f65d0cc94b727059">ccellread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read cell array of dense matrix into memory from file.  <a href="#0a22a48812769ec4f65d0cc94b727059"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#ffeec010de1565a36f9d12612f9fae2f">cspwrite</a> (const <a class="el" href="structcsp.html">csp</a> *sp, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write sparse matrix into file.  <a href="#ffeec010de1565a36f9d12612f9fae2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0b8af4e4788bab83b6a9ed7a70017066">cspcellwrite</a> (const <a class="el" href="structcspcell.html">cspcell</a> *spc, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write cell array of sparse matrix into file.  <a href="#0b8af4e4788bab83b6a9ed7a70017066"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#65b955d360ccf1d72c40d93d9b6e077e">cspread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read sparse metrix from file.  <a href="#65b955d360ccf1d72c40d93d9b6e077e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#1e52a56ac12aa2823536f0c9e4c20584">cspcellread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read cell array of sparse matrix from file.  <a href="#1e52a56ac12aa2823536f0c9e4c20584"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#ac8504a7fc144e552e678c6543c34e8c">cnew_mmap</a> (long nx, long ny, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(mat) matrix object, mmapped from file.  <a href="#ac8504a7fc144e552e678c6543c34e8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0ad4e8669ecf08ee0f0811d9eb24544d">ccellnew_mmap</a> (long nx, long ny, long *nnx, long *nny, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(cell) matrix cell object, mmapped from file.  <a href="#0ad4e8669ecf08ee0f0811d9eb24544d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#2c1c6578e7f7960142a73e928f6cd192">ccellnewsame_mmap</a> (long nx, long ny, long mx, long my, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(cell) matrix cell object, with identical blocks, mmapped from file.  <a href="#2c1c6578e7f7960142a73e928f6cd192"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Contains the mathematically functions regarding to <a class="el" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a> and <a class="el" href="structccell.html" title="an 2-d block matrix of cmat.">ccell</a> object. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="52711a0852dba5f35bab3591c8b2ec09"></a><!-- doxytag: member="cmat.h::cnew_ref" ref="52711a0852dba5f35bab3591c8b2ec09" args="(dcomplex *p, long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cnew_ref           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creat a X(mat) object to reference an already existing vector. 
<p>
free the X(mat) object won't free the existing vector. 
</div>
</div><p>
<a class="anchor" name="0e9274761076691022cbd210922e2107"></a><!-- doxytag: member="cmat.h::cnew_data" ref="0e9274761076691022cbd210922e2107" args="(dcomplex *p, long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cnew_data           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creat a X(mat) object with already allocated memory chunk. 
<p>
the memory is freed when the memory is freed. 
</div>
</div><p>
<a class="anchor" name="bb2b86ffc48237c760e652708aaf1415"></a><!-- doxytag: member="cmat.h::cnew" ref="bb2b86ffc48237c760e652708aaf1415" args="(long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cnew           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new T matrix object. 
<p>
initialized all to zero. 
</div>
</div><p>
<a class="anchor" name="856b68d7f24f9f844306dc5580808e9e"></a><!-- doxytag: member="cmat.h::cfree_keepdata" ref="856b68d7f24f9f844306dc5580808e9e" args="(cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cfree_keepdata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free the X(mat), but keep the data. 
<p>

</div>
</div><p>
<a class="anchor" name="275de6db48fa66bf5228f89005903839"></a><!-- doxytag: member="cmat.h::cfree_do" ref="275de6db48fa66bf5228f89005903839" args="(cmat *A, int keepdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>keepdata</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(mat) object. 
<p>
if keepdata!=0, will not free A-&gt;p. 
</div>
</div><p>
<a class="anchor" name="35b15d57f984dca577d67bc75fd1cf75"></a><!-- doxytag: member="cmat.h::cresize" ref="35b15d57f984dca577d67bc75fd1cf75" args="(cmat *A, long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cresize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resize a matrix by adding or removing columns or rows. 
<p>
Data is kept whever possible. Not used as of 2010-09-07. 
</div>
</div><p>
<a class="anchor" name="3f2400e9e770c0f2b7ea98c103cc5c10"></a><!-- doxytag: member="cmat.h::cref" ref="3f2400e9e770c0f2b7ea98c103cc5c10" args="(cmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cref           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creat a X(mat) reference an existing X(mat). 
<p>
Use the reference carefully. 
</div>
</div><p>
<a class="anchor" name="68a7e2a1455ebc1f35863ea9724d0643"></a><!-- doxytag: member="cmat.h::cref_reshape" ref="68a7e2a1455ebc1f35863ea9724d0643" args="(cmat *in, int nx, int ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cref_reshape           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create an new X(mat) reference another with different shape. 
<p>

</div>
</div><p>
<a class="anchor" name="16a273177027c4134922936b2440c72e"></a><!-- doxytag: member="cmat.h::crefcols" ref="16a273177027c4134922936b2440c72e" args="(cmat *in, long icol, long ncol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* crefcols           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>icol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ncol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creat a new X(mat) referencing columns in existing X(mat). 
<p>
reference counted. not used 
</div>
</div><p>
<a class="anchor" name="c82f2f9e84a8c582dfa64b207036fab9"></a><!-- doxytag: member="cmat.h::csub" ref="c82f2f9e84a8c582dfa64b207036fab9" args="(const cmat *in, long sx, long nx, long sy, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* csub           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new sub matrix of nx*ny starting from(sx,sy). 
<p>

</div>
</div><p>
<a class="anchor" name="a599a4058986f102d01ddcb6723af232"></a><!-- doxytag: member="cmat.h::ccat" ref="a599a4058986f102d01ddcb6723af232" args="(const cmat *in1, const cmat *in2, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* ccat           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
concatenate two matrixes into 1 along dimension "dim" 
<p>

</div>
</div><p>
<a class="anchor" name="6018457a413452c4e0fbce6a80da6b4b"></a><!-- doxytag: member="cmat.h::carrfree" ref="6018457a413452c4e0fbce6a80da6b4b" args="(cmat **As, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void carrfree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>As</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(mat) array. 
<p>

</div>
</div><p>
<a class="anchor" name="66d5a6e5e44f4035aa069d75c47eaf84"></a><!-- doxytag: member="cmat.h::cdup" ref="66d5a6e5e44f4035aa069d75c47eaf84" args="(const cmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cdup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
duplicate a X(mat) array 
<p>

</div>
</div><p>
<a class="anchor" name="db3c55ee96a9e7249403f738d251688c"></a><!-- doxytag: member="cmat.h::ccp" ref="db3c55ee96a9e7249403f738d251688c" args="(cmat **out0, const cmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy the values from one X(mat) to another. 
<p>

</div>
</div><p>
<a class="anchor" name="79a7b4a12c6fe0066453af5aac05197e"></a><!-- doxytag: member="cmat.h::ctrans" ref="79a7b4a12c6fe0066453af5aac05197e" args="(const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* ctrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
transpose a X(mat) object 
<p>

</div>
</div><p>
<a class="anchor" name="aa3be1e7b9926d4753d27b833b4735aa"></a><!-- doxytag: member="cmat.h::cset" ref="aa3be1e7b9926d4753d27b833b4735aa" args="(cmat *A, const dcomplex val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set values of each element in a X(mat) to val. 
<p>

</div>
</div><p>
<a class="anchor" name="5f6b5be2adda9848d051174da45fc340"></a><!-- doxytag: member="cmat.h::czero" ref="5f6b5be2adda9848d051174da45fc340" args="(cmat *out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void czero           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>out</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
initialize all numbers in a X(mat) object to 0 
<p>

</div>
</div><p>
<a class="anchor" name="917d70d3162af1387e34ab3bd76b14fd"></a><!-- doxytag: member="cmat.h::cmax" ref="917d70d3162af1387e34ab3bd76b14fd" args="(const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cmax           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find the maximum value of a X(mat) object 
<p>

</div>
</div><p>
<a class="anchor" name="638c8d3934ebd94ceaf7394966ce86f7"></a><!-- doxytag: member="cmat.h::cmin" ref="638c8d3934ebd94ceaf7394966ce86f7" args="(const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cmin           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find the minimum value of a X(mat) object 
<p>

</div>
</div><p>
<a class="anchor" name="b53df31a0c2920c26bd6a58d1d76e967"></a><!-- doxytag: member="cmat.h::cnorm2" ref="b53df31a0c2920c26bd6a58d1d76e967" args="(const cmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cnorm2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the norm2 of A 
<p>

</div>
</div><p>
<a class="anchor" name="c3c96d46d8b041763eb81436fd31ae60"></a><!-- doxytag: member="cmat.h::crandu" ref="c3c96d46d8b041763eb81436fd31ae60" args="(cmat *A, const dcomplex mean, rand_t *rstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crandu           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmt__state.html">rand_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rstat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill A with random uniform numbers between [0, 1]*max. 
<p>

</div>
</div><p>
<a class="anchor" name="87d59b705aa5c40cb2fdee249053aab2"></a><!-- doxytag: member="cmat.h::crandn" ref="87d59b705aa5c40cb2fdee249053aab2" args="(cmat *A, const dcomplex sigma, rand_t *rstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crandn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmt__state.html">rand_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rstat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill A with random normal distribution numbers with standard deviation of sigma. 
<p>

</div>
</div><p>
<a class="anchor" name="c0f00cb8f71b144c21627d1da2dcfb3f"></a><!-- doxytag: member="cmat.h::cshow" ref="c0f00cb8f71b144c21627d1da2dcfb3f" args="(const cmat *A, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cshow           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
display a X(mat) matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="204751357459432e00c5f5ee8d261f56"></a><!-- doxytag: member="cmat.h::cscale" ref="204751357459432e00c5f5ee8d261f56" args="(cmat *A, dcomplex w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>w</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
scale each element of A by w 
<p>

</div>
</div><p>
<a class="anchor" name="cf3340d336a63035bc4aacd6fb03fd87"></a><!-- doxytag: member="cmat.h::csum" ref="cf3340d336a63035bc4aacd6fb03fd87" args="(const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex csum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create sum of all the elements in A. 
<p>

</div>
</div><p>
<a class="anchor" name="8b4328dbfb8ced02b3ef2f523d4e37f5"></a><!-- doxytag: member="cmat.h::cadd" ref="8b4328dbfb8ced02b3ef2f523d4e37f5" args="(cmat **B0, dcomplex bc, const cmat *A, const dcomplex ac)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cadd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>ac</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute B=bc*B+ac*A behavior changed on 2009-11-02. 
<p>
if A is NULL, don't do anything. 
</div>
</div><p>
<a class="anchor" name="a5c02f882f7897bcafa6e65cf8a13c28"></a><!-- doxytag: member="cmat.h::cinn" ref="a5c02f882f7897bcafa6e65cf8a13c28" args="(const cmat *A, const cmat *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the inner product of A and B. 
<p>
(inner product) 
</div>
</div><p>
<a class="anchor" name="8c64a290f550b8e43a6a100d216de986"></a><!-- doxytag: member="cmat.h::cwdot" ref="8c64a290f550b8e43a6a100d216de986" args="(const dcomplex *a, const cmat *w, const dcomplex *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cwdot           </td>
          <td>(</td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute weighted dot product a'*(w*b) 
<p>

</div>
</div><p>
<a class="anchor" name="c8a9b196602cd2b72cae912c49e4b504"></a><!-- doxytag: member="cmat.h::cwdot2" ref="c8a9b196602cd2b72cae912c49e4b504" args="(const dcomplex *a, const cmat *w, const dcomplex *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cwdot2           </td>
          <td>(</td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
special version of dwdot for just 2 element vectors. 
<p>

</div>
</div><p>
<a class="anchor" name="94c0d4a66c6d83215f077cffcba34146"></a><!-- doxytag: member="cmat.h::cwdot3" ref="94c0d4a66c6d83215f077cffcba34146" args="(const dcomplex *a, const cmat *w, const dcomplex *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cwdot3           </td>
          <td>(</td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
special version of dwdot for just 3 element vectors. 
<p>

</div>
</div><p>
<a class="anchor" name="2417a6c93f1245cf129586dce262aba3"></a><!-- doxytag: member="cmat.h::ccwm" ref="2417a6c93f1245cf129586dce262aba3" args="(cmat *B, const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccwm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute component wise multiply B=B. 
<p>
*A 
</div>
</div><p>
<a class="anchor" name="5012aabec0611cd938b01765c892f6b3"></a><!-- doxytag: member="cmat.h::cmulvec" ref="5012aabec0611cd938b01765c892f6b3" args="(dcomplex *restrict y, const cmat *restrict A, const dcomplex *restrict x, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmulvec           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
multiply a X(mat) matrix with a vector and accumulate to y: y+=A*x*alpha 
<p>

</div>
</div><p>
<a class="anchor" name="da9977993e68f94425418b2c68d1789d"></a><!-- doxytag: member="cmat.h::cmm" ref="da9977993e68f94425418b2c68d1789d" args="(cmat **C0, const cmat *A, const cmat *B, const char trans[2], const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>trans</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute matrix product using blas dgemm with beta=1; C=beta*C+ alpha *trans(A)*trans(B); if C exist. 
<p>

</div>
</div><p>
<a class="anchor" name="16f114b8d7e5173d9928b3dbb3f268a5"></a><!-- doxytag: member="cmat.h::cinvspd_inplace" ref="16f114b8d7e5173d9928b3dbb3f268a5" args="(cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cinvspd_inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace invert a small square SPD matrix using lapack dposv_, usually (A'*w*A). 
<p>
by solving Ax=I; copy x to A. dposv_ modifies A also. be careful 
</div>
</div><p>
<a class="anchor" name="d2251ee97ee6cd88196f8fb03f4ac880"></a><!-- doxytag: member="cmat.h::cinvspd" ref="d2251ee97ee6cd88196f8fb03f4ac880" args="(const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cinvspd           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
out of place version of dinvspd_inplace 
<p>

</div>
</div><p>
<a class="anchor" name="fe6927dc25de67288c63961b3340f69c"></a><!-- doxytag: member="cmat.h::cinv_inplace" ref="fe6927dc25de67288c63961b3340f69c" args="(cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cinv_inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace invert a general square matrix using lapack dgesv_ 
<p>

</div>
</div><p>
<a class="anchor" name="aad7fd796188a37ff988b75286ff1906"></a><!-- doxytag: member="cmat.h::cinv" ref="aad7fd796188a37ff988b75286ff1906" args="(const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cinv           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
out of place version of dinv 
<p>

</div>
</div><p>
<a class="anchor" name="63f8f6199cd41366c1fdd40717c6b3c3"></a><!-- doxytag: member="cmat.h::cmcc" ref="63f8f6199cd41366c1fdd40717c6b3c3" args="(const cmat *A, const cmat *wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cmcc           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute (A'*W*A); where diag(W)=wt 
<p>

</div>
</div><p>
<a class="anchor" name="4a8db9c35e106c64a679ae96beb61b66"></a><!-- doxytag: member="cmat.h::cimcc" ref="4a8db9c35e106c64a679ae96beb61b66" args="(const cmat *A, const cmat *wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cimcc           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute inv(dmcc(A, wt)) 
<p>

</div>
</div><p>
<a class="anchor" name="364b9a68838d38ae710f3ade6e5e5820"></a><!-- doxytag: member="cmat.h::ctmcc" ref="364b9a68838d38ae710f3ade6e5e5820" args="(const cmat *A, const cmat *wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* ctmcc           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute (A*W*A'); where diag(W)=wt 
<p>

</div>
</div><p>
<a class="anchor" name="862a7aa868fe53404dc29d060b5f044d"></a><!-- doxytag: member="cmat.h::cpinv" ref="862a7aa868fe53404dc29d060b5f044d" args="(const cmat *A, const cmat *wt, const csp *Wsp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cpinv           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>Wsp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the pseudo inverse of matrix A with weigthing of full matrix W or sparse matrix weighting Wsp. 
<p>
For full matrix, wt can be either W or diag (W) for diagonal weighting. B=inv(A'*W*A)*A'*W; 
</div>
</div><p>
<a class="anchor" name="77dbd9fcfc2e3185fc072bd6bec5e5e5"></a><!-- doxytag: member="cmat.h::cdiff" ref="77dbd9fcfc2e3185fc072bd6bec5e5e5" args="(const cmat *A, const cmat *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cdiff           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the relative difference betwee two vectors. 
<p>
||A-B||/||A|| using norm2. for debugging purpose. 
</div>
</div><p>
<a class="anchor" name="f962ae5334dec4a29e6626bc0be8b19b"></a><!-- doxytag: member="cmat.h::ccircle" ref="f962ae5334dec4a29e6626bc0be8b19b" args="(cmat *A, double cx, double cy, double r, dcomplex val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccircle           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
a new gray pixel map generation based on bilinear influence functions used in mkw. 
<p>
creates slightly larger map. add an filled circle. cx,cy,r are in unit of pixels 
</div>
</div><p>
<a class="anchor" name="779b108bf238d17187f25d3eee0f3fe9"></a><!-- doxytag: member="cmat.h::ccircle_symbolic" ref="779b108bf238d17187f25d3eee0f3fe9" args="(cmat *A, double cx, double cy, double r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccircle_symbolic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
similar to X(circle). 
<p>
but don't actually compute the weights. just test the corners; 
</div>
</div><p>
<a class="anchor" name="2e68e24dcc5d7ffd8d9b2c575e0830b9"></a><!-- doxytag: member="cmat.h::cfftshift" ref="2e68e24dcc5d7ffd8d9b2c575e0830b9" args="(cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cfftshift           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
shift frequency components by n/2 
<p>

</div>
</div><p>
<a class="anchor" name="72f5647463dae0b89a5c8e444f580de0"></a><!-- doxytag: member="cmat.h::ccpcorner2center" ref="72f5647463dae0b89a5c8e444f580de0" args="(cmat *A, const cmat *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccpcorner2center           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reorder B and embed/crop into center of A 
<p>
<div class="fragment"><pre class="fragment">
   4 * * 3
   * * * *
   * * * *
   2 * * 1
   </pre></div> to <div class="fragment"><pre class="fragment">
   1 2 
   3 4
   </pre></div> 
</div>
</div><p>
<a class="anchor" name="834e5e2f254160faa414569a60282089"></a><!-- doxytag: member="cmat.h::cshift" ref="834e5e2f254160faa414569a60282089" args="(cmat **B0, const cmat *A, int sx, int sy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cshift           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
cyclic shift A by nx and ny to B. 
<p>
<div class="fragment"><pre class="fragment">
   4   3     1   2 
      
   2   1 to  3   4
   </pre></div> 
</div>
</div><p>
<a class="anchor" name="1cccdaf44daa400ae770f49e5dc91771"></a><!-- doxytag: member="cmat.h::crotvec" ref="1cccdaf44daa400ae770f49e5dc91771" args="(cmat *A, const double theta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crotvec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>theta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
rotate the vectors CCW. 
<p>
same as rotate coordinate theta CW. A(:,1) is x, A(:,2) is y. 
</div>
</div><p>
<a class="anchor" name="39e013291512a0930b8e18ba7efd9071"></a><!-- doxytag: member="cmat.h::crotvecnn" ref="39e013291512a0930b8e18ba7efd9071" args="(cmat **B0, const cmat *A, double theta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crotvecnn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>theta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
rotate a 2x2 covariance matrix A by theta CCW (coordinate rotate -theta CCW) or from ra to xy coordinate. 
<p>
R*A*R'; 
</div>
</div><p>
<a class="anchor" name="b7184001fed6ff87e17292e2092ee4b8"></a><!-- doxytag: member="cmat.h::cmulvec3" ref="b7184001fed6ff87e17292e2092ee4b8" args="(dcomplex *y, const cmat *A, const dcomplex *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmulvec3           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
T matrix vector multiply optimized for just three values. 
<p>
y=A*x; 
</div>
</div><p>
<a class="anchor" name="689ab6d12867fee7225a83f93f1a0a9d"></a><!-- doxytag: member="cmat.h::ccog" ref="689ab6d12867fee7225a83f93f1a0a9d" args="(double *grad, const cmat *i0, double offsetx, double offsety, double thres, double bkgrnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccog           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsetx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsety</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>thres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>bkgrnd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute thresholded center of gravity. 
<p>
The threshold is absolute value. bkgrnd is removed from i0 when computing cog. offset is the offset of the reference point (cog=0) from the physical center. all length are given in terms of pixel. 
</div>
</div><p>
<a class="anchor" name="47b5130ae904c436b75d6699abf025c6"></a><!-- doxytag: member="cmat.h::cshift2center" ref="47b5130ae904c436b75d6699abf025c6" args="(cmat *A, double offsetx, double offsety)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cshift2center           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsetx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsety</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shift the image in A to center on physical center+[offsetx,offsety] using cog and fft. 
<p>

</div>
</div><p>
<a class="anchor" name="66f7b38cee9d08a96f2b6e4b5c971fa4"></a><!-- doxytag: member="cmat.h::cclip" ref="66f7b38cee9d08a96f2b6e4b5c971fa4" args="(cmat *A, double min, double max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cclip           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Limit numbers in A to within [min, max]. 
<p>
used for DM clipping. 
</div>
</div><p>
<a class="anchor" name="77fc55aade8619fa7fab51a2887f0535"></a><!-- doxytag: member="cmat.h::cgramschmidt" ref="77fc55aade8619fa7fab51a2887f0535" args="(cmat *Mod, double *amp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgramschmidt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>amp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
OrthNormalize column vector in Mod, with weighting from vector amp. 
<p>
&lt;Mod|wt|Mod&gt; is equal to sum(wt). 2010-07-21: Bug found: The result is not orthonormal. cause: nonvalid is not initialized to 0. 
</div>
</div><p>
<a class="anchor" name="8d75289b919758fc3d3919b6026ba406"></a><!-- doxytag: member="cmat.h::cmuldiag" ref="8d75289b919758fc3d3919b6026ba406" args="(cmat *A, cmat *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmuldiag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A=A*B, where diag(B)=s. 
<p>

</div>
</div><p>
<a class="anchor" name="dd74de8c67cb4e5f897778c0268d7744"></a><!-- doxytag: member="cmat.h::ccwpow" ref="dd74de8c67cb4e5f897778c0268d7744" args="(cmat *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccwpow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Raise all elements to power power. 
<p>

</div>
</div><p>
<a class="anchor" name="ea36bb01ebe29d23687c2d6738080de1"></a><!-- doxytag: member="cmat.h::csvd" ref="ea36bb01ebe29d23687c2d6738080de1" args="(dmat **Sdiag, cmat **U, cmat **VT, const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csvd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>Sdiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
SVD of a general matrix. 
<p>
A=U*diag(S)*V'; diag(S) is returned. 
</div>
</div><p>
<a class="anchor" name="e3d755e9c6714e93a155d710b421dd06"></a><!-- doxytag: member="cmat.h::csvd_pow" ref="e3d755e9c6714e93a155d710b421dd06" args="(cmat *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csvd_pow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
computes pow(A,power) using svd 
<p>

</div>
</div><p>
<a class="anchor" name="2289f10c6693d6253721db413bb7d61f"></a><!-- doxytag: member="cmat.h::caddI" ref="2289f10c6693d6253721db413bb7d61f" args="(cmat *A, dcomplex val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caddI           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add val to diagonal values of A. 
<p>

</div>
</div><p>
<a class="anchor" name="d39a391d8bbcc4b7576df57820fc8eb7"></a><!-- doxytag: member="cmat.h::ctikcr" ref="d39a391d8bbcc4b7576df57820fc8eb7" args="(cmat *A, dcomplex thres)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ctikcr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>thres</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply tikhonov regularization to A. 
<p>

</div>
</div><p>
<a class="anchor" name="d1f4093f58b84b2e125919868b103a88"></a><!-- doxytag: member="cmat.h::cmulsp" ref="d1f4093f58b84b2e125919868b103a88" args="(cmat **yout, const cmat *x, const csp *A, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmulsp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
y=y+alpha*OP(x)*OP(A); implemented by transposing x,y index in sptmulmat implementation TESTED OK. 
<p>

</div>
</div><p>
<a class="anchor" name="071ca1c1e64bb1ae6b9ca352a69a31b0"></a><!-- doxytag: member="cmat.h::clogspace" ref="071ca1c1e64bb1ae6b9ca352a69a31b0" args="(double emin, double emax, long n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* clogspace           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create log spaced vector. 
<p>

</div>
</div><p>
<a class="anchor" name="5d357153670b6ce7f3eb9b7dee553912"></a><!-- doxytag: member="cmat.h::clinspace" ref="5d357153670b6ce7f3eb9b7dee553912" args="(double emin, double emax, long n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* clinspace           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create linearly spaced vector. 
<p>

</div>
</div><p>
<a class="anchor" name="e546d587249af8bbb4c09a03ff2cb9fd"></a><!-- doxytag: member="cmat.h::cinterp1" ref="e546d587249af8bbb4c09a03ff2cb9fd" args="(dmat *xin, dmat *yin, dmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cinterp1           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>yin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpolate using linear interp. 
<p>
xin is the coordinate of yin. xnew is the coordinate of the output. 
</div>
</div><p>
<a class="anchor" name="0fcc7887067339b812f96bc684f47f4c"></a><!-- doxytag: member="cmat.h::cinterp1log" ref="0fcc7887067339b812f96bc684f47f4c" args="(dmat *xin, dmat *yin, dmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cinterp1log           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>yin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpolate using log(xin) and log(xnew) xin is the coordinate of yin. 
<p>
xnew is the coordinate of the output. 
</div>
</div><p>
<a class="anchor" name="10d49d59390d39b5398979a55f90441a"></a><!-- doxytag: member="cmat.h::chistfill" ref="10d49d59390d39b5398979a55f90441a" args="(dmat **out, const cmat *A, double center, double spacing, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chistfill           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For each entry in A, call repeatly to collect its histogram, centered at center, spaced by spacing, for n bins in total. 
<p>
center if at bin n/2. 
</div>
</div><p>
<a class="anchor" name="1f6ecbeecb56f05d855f3e1f21342dc2"></a><!-- doxytag: member="cmat.h::cspline_prep" ref="1f6ecbeecb56f05d855f3e1f21342dc2" args="(cmat *x, cmat *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cspline_prep           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
1D Cubic spline interpolation preparation. 
<p>
if x has only 1 column: x is the coordinate. y is the function value. if x has two columns: first column is the coordinate, y is null.<p>
It is upto the user to make sure that the coordinate is increasingly ordered and evenly spaced .<p>
If the values of a function <img class="formulaInl" alt="$f(x)$" src="form_6.png"> and its derivative are know at x=0, and x=1 (normalized coordinate), then the function can be interpolated on the interval [0,1] using a third degree polynomial. This is called cubic interpolation. The formula of this polynomial can be easily derived.<p>
A third degree polynomial and its derivative: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x)=ax^3+bx^2+cx+d \]" src="form_7.png">
<p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x)=3ax^3+2bx+c \]" src="form_8.png">
<p>
 The coefficients can be derived from the value and derivatives: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} a&amp;=&amp;2f(0)-2f(1)+f^\prime (0)+f^\prime(1)\\ b&amp;=&amp;-3f(0)+3f(1)-2f^\prime(0)-f^\prime(0)\\ c&amp;=&amp;f^\prime(0)\\ d&amp;=&amp;f(0)\\ \end{eqnarray*}" src="form_9.png">
<p>
 the derivatives can be computed as <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} f^\prime(0)&amp;=&amp;\frac{f(1)-f(-1)}{2}\\ f^\prime(1)&amp;=&amp;\frac{f(2)-f(0)}{2}\\ \end{eqnarray*}" src="form_10.png">
<p>
 so we have the formula <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} a&amp;=&amp;-0.5 f(-1) + 1.5 f(0) - 1.5 f(1) + 0.5 f(2)\\ b&amp;=&amp; f(-1) - 2.5 f(0) + 2 f(1) - 0.5 f(2)\\ c&amp;=&amp;-0.5 f(-1) + 0.5 f(1) \\ d&amp;=&amp; f(0) \\ \end{eqnarray*}" src="form_11.png">
<p>
<p>
for the boundary pints, replace <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(-1))/2\]" src="form_12.png">
<p>
 by <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(0))\]" src="form_13.png">
<p>
 Otehr type of boundaries are handled in the same way.<p>
see <a href="http://www.paulinternet.nl/?page=bicubicx">http://www.paulinternet.nl/?page=bicubicx</a> 
</div>
</div><p>
<a class="anchor" name="105e0e17a7f377c30b63ff9bc5f002e1"></a><!-- doxytag: member="cmat.h::cspline_eval" ref="105e0e17a7f377c30b63ff9bc5f002e1" args="(cmat *coeff, cmat *x, cmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cspline_eval           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evluate the cubic spline represented by nx5 matrix coeff, at location array xnew. 
<p>

</div>
</div><p>
<a class="anchor" name="6dc13156073384a5722fcf7fd5f0833a"></a><!-- doxytag: member="cmat.h::cspline" ref="6dc13156073384a5722fcf7fd5f0833a" args="(cmat *x, cmat *y, cmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cspline           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Do 1D cubic spline all at once by calling X(spline_prep) and X(spline_evald). 
<p>

</div>
</div><p>
<a class="anchor" name="6d44ad8fe4da7595e7b54ac85015cfaa"></a><!-- doxytag: member="cmat.h::cbspline_prep" ref="6d44ad8fe4da7595e7b54ac85015cfaa" args="(cmat *x, cmat *y, cmat *z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* cbspline_prep           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
2D cubic spline interpolation preparation. 
<p>
x is the x coordinate vector of the 2-d grid. y is the y coordinate vector of the 2-d grid. z is defined on the 2-d grid. It is upto the user to make sure that the coordinate is increasingly ordered and evenly spaced .<p>
The boundaries are handled in the same way is X(spline). i.e. replace <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(-1))/2\]" src="form_12.png">
<p>
 by <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(0))\]" src="form_13.png">
<p>
 Otehr type of boundaries are handled in the same way. 
</div>
</div><p>
<a class="anchor" name="ee339b2c28b3fcf24144233e6b078002"></a><!-- doxytag: member="cmat.h::cbspline_eval" ref="ee339b2c28b3fcf24144233e6b078002" args="(ccell *coeff, cmat *x, cmat *y, cmat *xnew, cmat *ynew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cbspline_eval           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>ynew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evaluate 2D cubic spline at location defined 2-d arrays by xnew, ynew. 
<p>

</div>
</div><p>
<a class="anchor" name="cdcbda2dbd5dfec8344b8bada36a0a35"></a><!-- doxytag: member="cmat.h::ccellnew" ref="cdcbda2dbd5dfec8344b8bada36a0a35" args="(const long nx, const long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellnew           </td>
          <td>(</td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create a new block matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="3e751c651d80acbebc93a7536bfd4e65"></a><!-- doxytag: member="cmat.h::ccellnew2" ref="3e751c651d80acbebc93a7536bfd4e65" args="(const ccell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellnew2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create an new X(cell) similar to A in shape 
<p>

</div>
</div><p>
<a class="anchor" name="193a03f98ee7128386819d9821ceb859"></a><!-- doxytag: member="cmat.h::ccellzero" ref="193a03f98ee7128386819d9821ceb859" args="(ccell *dc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellzero           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
setting all elements of a X(cell) to zero. 
<p>

</div>
</div><p>
<a class="anchor" name="d9128f3e7703bfc29bb33d37397cf5c6"></a><!-- doxytag: member="cmat.h::ccellset" ref="d9128f3e7703bfc29bb33d37397cf5c6" args="(ccell *dc, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
setting all elements of a X(cell) to alpha. 
<p>

</div>
</div><p>
<a class="anchor" name="6631a2e1f0b26b3b14723cb8e127ab11"></a><!-- doxytag: member="cmat.h::ccellfree_do" ref="6631a2e1f0b26b3b14723cb8e127ab11" args="(ccell *dc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a X(cell) object. 
<p>

</div>
</div><p>
<a class="anchor" name="db8e69bbe2c05a039f236fbb2eae12de"></a><!-- doxytag: member="cmat.h::ccelltrans" ref="db8e69bbe2c05a039f236fbb2eae12de" args="(const ccell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccelltrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
transpose a X(cell) object 
<p>

</div>
</div><p>
<a class="anchor" name="1f870a53b480b1477c2bc30e0178a516"></a><!-- doxytag: member="cmat.h::ccellref" ref="1f870a53b480b1477c2bc30e0178a516" args="(const ccell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellref           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creat a X(cell) reference an existing X(cell) by referencing the elements. 
<p>

</div>
</div><p>
<a class="anchor" name="0ed077f33b1a869fd6154ded4b557a4b"></a><!-- doxytag: member="cmat.h::ccelldup" ref="0ed077f33b1a869fd6154ded4b557a4b" args="(const ccell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccelldup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
duplicate a X(cell) object. 
<p>

</div>
</div><p>
<a class="anchor" name="84b4ddc50d2114e9be97128fdf424e07"></a><!-- doxytag: member="cmat.h::ccellcp" ref="84b4ddc50d2114e9be97128fdf424e07" args="(ccell **out0, const ccell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellcp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy the values from one X(cell) to another. 
<p>

</div>
</div><p>
<a class="anchor" name="83dd0483ef61373a16ee4c5478a919d1"></a><!-- doxytag: member="cmat.h::ccellnorm2" ref="83dd0483ef61373a16ee4c5478a919d1" args="(const ccell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ccellnorm2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute norm2. 
<p>

</div>
</div><p>
<a class="anchor" name="0f63e81c5c497006f9f355a1f288cf91"></a><!-- doxytag: member="cmat.h::ccellscale" ref="0f63e81c5c497006f9f355a1f288cf91" args="(ccell *A, double w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>w</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
scale each element of A. 
<p>

</div>
</div><p>
<a class="anchor" name="00c2da2fc7f3d49037226159745c2378"></a><!-- doxytag: member="cmat.h::ccellreduce" ref="00c2da2fc7f3d49037226159745c2378" args="(const ccell *A, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellreduce           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reduce nx*ny cell matrix to 1*ny if dim=1 and nx*11 if dim=2 
<p>

</div>
</div><p>
<a class="anchor" name="6bc29f4fe8fda3c3a1ca2fe3ac56b126"></a><!-- doxytag: member="cmat.h::ccellcat" ref="6bc29f4fe8fda3c3a1ca2fe3ac56b126" args="(const ccell *A, const ccell *B, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellcat           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
concatenate two cell matrices along dimenstion 'dim' 
<p>

</div>
</div><p>
<a class="anchor" name="46bafd0a0ab7198be7c8c7ad4c42f88b"></a><!-- doxytag: member="cmat.h::ccellcat_each" ref="46bafd0a0ab7198be7c8c7ad4c42f88b" args="(const ccell *A, const ccell *B, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellcat_each           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
concatenate coresponding elements of each X(cell). 
<p>
They must have the same shape. 
</div>
</div><p>
<a class="anchor" name="d65426e91446c2e95481a47fc9e8716a"></a><!-- doxytag: member="cmat.h::ccelldropempty" ref="d65426e91446c2e95481a47fc9e8716a" args="(ccell **A0, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccelldropempty           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
drop empty rows or columns. 
<p>
(size of *A0 is changed. 
</div>
</div><p>
<a class="anchor" name="e52c5a573fcaa559847488c664365e62"></a><!-- doxytag: member="cmat.h::ccelladd" ref="e52c5a573fcaa559847488c664365e62" args="(ccell **B0, double bc, const ccell *A, const double ac)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccelladd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>ac</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add one to another. 
<p>
B=B*bc+A*ac 
</div>
</div><p>
<a class="anchor" name="df204a1a88694e37365a17488d1e12c8"></a><!-- doxytag: member="cmat.h::ccellinn" ref="df204a1a88694e37365a17488d1e12c8" args="(const ccell *A, const ccell *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex ccellinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the inner produce of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="92110ce17c83d4a1f68d856ec32a90cd"></a><!-- doxytag: member="cmat.h::ccellcwm" ref="92110ce17c83d4a1f68d856ec32a90cd" args="(ccell *B, const ccell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellcwm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Component wise multiply of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a> B=A. 
<p>
*B*alpha 
</div>
</div><p>
<a class="anchor" name="afe341e06821b09968d37a530a3adc3e"></a><!-- doxytag: member="cmat.h::ccellmm" ref="afe341e06821b09968d37a530a3adc3e" args="(ccell **C0, const ccell *A, const ccell *B, const char trans[2], const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellmm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>trans</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute A*B and add to C0. 
<p>
C=C+trans(A)*trans(B)*alpha<p>
2009-11-09: There was initially a beta parameter It was implemented wrongly for beta!=1 because for every call to dmm, the already accumulated ones are scaled. removed beta. 
</div>
</div><p>
<a class="anchor" name="99b65983778109d4aa815d3ea5db9414"></a><!-- doxytag: member="cmat.h::ccellinvspd" ref="99b65983778109d4aa815d3ea5db9414" args="(ccell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellinvspd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inplace Invert a SPD matrix. 
<p>
It is treated as a block matrix 
</div>
</div><p>
<a class="anchor" name="ddb2ebf6b55726391b1ea6be0e210e2e"></a><!-- doxytag: member="cmat.h::ccellinv" ref="ddb2ebf6b55726391b1ea6be0e210e2e" args="(ccell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellinv           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inplace Invert a matrix. 
<p>
It is treated as a block matrix. 
</div>
</div><p>
<a class="anchor" name="72a43514eb1abfbe161f74f5a223f2f5"></a><!-- doxytag: member="cmat.h::ccellinvspd_each" ref="72a43514eb1abfbe161f74f5a223f2f5" args="(ccell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellinvspd_each           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
invert each component of the <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>. 
<p>
Each cell is treated as an individual matrix. 
</div>
</div><p>
<a class="anchor" name="2c8c0809e00fd5d528cbb31048f3c52a"></a><!-- doxytag: member="cmat.h::ccell2m" ref="2c8c0809e00fd5d528cbb31048f3c52a" args="(const ccell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* ccell2m           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a block matrix to a matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="1545f84a1ac4226ce43fbfc8ba0af5db"></a><!-- doxytag: member="cmat.h::c2cellref" ref="1545f84a1ac4226ce43fbfc8ba0af5db" args="(const cmat *A, int *dims, int ndim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* c2cellref           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
convert a vector to cell using dimensions specified in dims. 
<p>
Reference the vector 
</div>
</div><p>
<a class="anchor" name="a5983177f2055cae1bb16f5a53e3f4aa"></a><!-- doxytag: member="cmat.h::c2cell" ref="a5983177f2055cae1bb16f5a53e3f4aa" args="(ccell **B, const cmat *A, const ccell *ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void c2cell           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>ref</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
make A a cell array using shape information from ref if *B is NULL 
<p>

</div>
</div><p>
<a class="anchor" name="b0d7e1c7d7eb2810eff34b04111129c8"></a><!-- doxytag: member="cmat.h::ccelldropzero" ref="b0d7e1c7d7eb2810eff34b04111129c8" args="(ccell *B, double thres)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccelldropzero           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>thres</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
drop empty blocks (zero). 
<p>
Size of B is not modified. 
</div>
</div><p>
<a class="anchor" name="2fd83c2f600649a6205e8c62547f6e8d"></a><!-- doxytag: member="cmat.h::ccelldiff" ref="2fd83c2f600649a6205e8c62547f6e8d" args="(const ccell *A, const ccell *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ccelldiff           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute ||A-B||/||A|| use mean. 
<p>

</div>
</div><p>
<a class="anchor" name="fdb96e19ff1dfea164570fc47815a2ab"></a><!-- doxytag: member="cmat.h::ccellclip" ref="fdb96e19ff1dfea164570fc47815a2ab" args="(ccell *Ac, double min, double max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccellclip           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>Ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
clip a X(cell) array to max at 'max', min at 'min' 
<p>

</div>
</div><p>
<a class="anchor" name="6e30556d58339cea7a00a4b163822af4"></a><!-- doxytag: member="cmat.h::ccelltikcr" ref="6e30556d58339cea7a00a4b163822af4" args="(ccell *A, double thres)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccelltikcr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>thres</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply tickholov regularization of relative thres to cell array by converting it to mat. 
<p>

</div>
</div><p>
<a class="anchor" name="0a9902ff737584f210c3730f430b1599"></a><!-- doxytag: member="cmat.h::ccellpinv" ref="0a9902ff737584f210c3730f430b1599" args="(const ccell *A, const ccell *wt, const cspcell *Wsp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellpinv           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>Wsp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the pseudo inverse of block matrix A. 
<p>
A is n*p cell, wt n*n cell or sparse cell. <img class="formulaInl" alt="$B=inv(A'*W*A)*A'*W$" src="form_3.png"> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>The matrix to pseudo invert </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wt</em>&nbsp;</td><td>Use a dense matrix for weighting </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Wsp</em>&nbsp;</td><td>Use a sparse matrix for weighting </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="611ce556f87c2ac01da0b00b717cd964"></a><!-- doxytag: member="cmat.h::ccellmulsp" ref="611ce556f87c2ac01da0b00b717cd964" args="(ccell **C0, const ccell *A, const cspcell *B, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellmulsp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a cell with a sparse cell. 
<p>
<img class="formulaInl" alt="$C0+=A*B*alpha$" src="form_4.png">. 
</div>
</div><p>
<a class="anchor" name="35a0966fdc0e65bdcf290c75e0404713"></a><!-- doxytag: member="cmat.h::ccelladdI" ref="35a0966fdc0e65bdcf290c75e0404713" args="(ccell *A, double a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccelladdI           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add a to diagonal elements of A; 
<p>

</div>
</div><p>
<a class="anchor" name="d7eece0d6b59dbc7d2e98d5ce866b21b"></a><!-- doxytag: member="cmat.h::ccellsvd_pow" ref="d7eece0d6b59dbc7d2e98d5ce866b21b" args="(ccell *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellsvd_pow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the power of a block matrix using svd method. 
<p>
First convert it do X(mat), do the power, and convert back to block matrix. 
</div>
</div><p>
<a class="anchor" name="92d8633d3243ae2a95e43d6b41c4a2cb"></a><!-- doxytag: member="cmat.h::ccellcwpow" ref="92d8633d3243ae2a95e43d6b41c4a2cb" args="(ccell *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellcwpow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
raise each cell in the cell array to power of power. 
<p>

</div>
</div><p>
<a class="anchor" name="28f2c1a91c80f5dc8c951f875d79f2de"></a><!-- doxytag: member="cmat.h::cwritedata" ref="28f2c1a91c80f5dc8c951f875d79f2de" args="(file_t *fp, const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cwritedata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contains routines to write/read dense/sparse matrix into/from file. 
<p>
Function to write dense matrix data into a file pointer. Generally used by library developer 
</div>
</div><p>
<a class="anchor" name="5fc25bdbb6758549b60bc4b9c34a9bef"></a><!-- doxytag: member="cmat.h::ccellwritedata" ref="5fc25bdbb6758549b60bc4b9c34a9bef" args="(file_t *fp, const ccell *dc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellwritedata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to write cell array of dense matrix data. 
<p>
into a file pointer Generally used by library developer 
</div>
</div><p>
<a class="anchor" name="e9df93488639190f0b09a837ba21fd3e"></a><!-- doxytag: member="cmat.h::creaddata" ref="e9df93488639190f0b09a837ba21fd3e" args="(file_t *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* creaddata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to read dense matrix into memory from file pointer. 
<p>
Generally used by library developer. 
</div>
</div><p>
<a class="anchor" name="41b9a0829de990592462d11aedcb2fa5"></a><!-- doxytag: member="cmat.h::ccellreaddata" ref="41b9a0829de990592462d11aedcb2fa5" args="(file_t *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellreaddata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to read dense matrix cell array into memory from file pointer. 
<p>
Generally used by library developer. 
</div>
</div><p>
<a class="anchor" name="c856ab97d0032304beb9cb4fe0465528"></a><!-- doxytag: member="cmat.h::cspwritedata" ref="c856ab97d0032304beb9cb4fe0465528" args="(file_t *fp, const csp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspwritedata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to write sparse matrix data into file pointed using a file pointer. 
<p>
Generally used by library developer. We do not convert data during saving, but rather do the conversion during reading. 
</div>
</div><p>
<a class="anchor" name="c52d1399af426794abf242869a2ec077"></a><!-- doxytag: member="cmat.h::cspreaddata" ref="c52d1399af426794abf242869a2ec077" args="(file_t *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspreaddata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to read sparse matrix data from file pointer into memory. 
<p>
Used by library developer. 
</div>
</div><p>
<a class="anchor" name="9593e890699be4f48e826d9048018c04"></a><!-- doxytag: member="cmat.h::cwrite" ref="9593e890699be4f48e826d9048018c04" args="(const cmat *A, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write dense matrix into a file. 
<p>
Usage: dwrite(A,"A") for double matrix. 
</div>
</div><p>
<a class="anchor" name="e75214457fa1e5c394d311b307a7f5e4"></a><!-- doxytag: member="cmat.h::ccellwrite" ref="e75214457fa1e5c394d311b307a7f5e4" args="(const ccell *dc, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write cell array of dense matrix into a file. 
<p>
Usage: dcellwrite(A,"A.bin.gz") for double matrix cell. 
</div>
</div><p>
<a class="anchor" name="d68739105dfbaca4f86b98fe0666f259"></a><!-- doxytag: member="cmat.h::cread" ref="d68739105dfbaca4f86b98fe0666f259" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read dense matrix into memory from file. 
<p>
Usage: A=dread("A.bin.gz"); for a <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> 
</div>
</div><p>
<a class="anchor" name="0a22a48812769ec4f65d0cc94b727059"></a><!-- doxytag: member="cmat.h::ccellread" ref="0a22a48812769ec4f65d0cc94b727059" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read cell array of dense matrix into memory from file. 
<p>
Usage: A=dcellread("A.bin.gz"); for a double <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>. 
</div>
</div><p>
<a class="anchor" name="ffeec010de1565a36f9d12612f9fae2f"></a><!-- doxytag: member="cmat.h::cspwrite" ref="ffeec010de1565a36f9d12612f9fae2f" args="(const csp *sp, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write sparse matrix into file. 
<p>
Usage: spwrite(A,"A.bin.gz"); 
</div>
</div><p>
<a class="anchor" name="0b8af4e4788bab83b6a9ed7a70017066"></a><!-- doxytag: member="cmat.h::cspcellwrite" ref="0b8af4e4788bab83b6a9ed7a70017066" args="(const cspcell *spc, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write cell array of sparse matrix into file. 
<p>
Usage: spcellwrite(A,"A.bin.gz"); 
</div>
</div><p>
<a class="anchor" name="65b955d360ccf1d72c40d93d9b6e077e"></a><!-- doxytag: member="cmat.h::cspread" ref="65b955d360ccf1d72c40d93d9b6e077e" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read sparse metrix from file. 
<p>
Usage: A=spread("A.bin.gz"); 
</div>
</div><p>
<a class="anchor" name="1e52a56ac12aa2823536f0c9e4c20584"></a><!-- doxytag: member="cmat.h::cspcellread" ref="1e52a56ac12aa2823536f0c9e4c20584" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcspcell.html">cspcell</a>* cspcellread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read cell array of sparse matrix from file. 
<p>
Usage: A=spcellread("A.bin.gz"); 
</div>
</div><p>
<a class="anchor" name="ac8504a7fc144e552e678c6543c34e8c"></a><!-- doxytag: member="cmat.h::cnew_mmap" ref="ac8504a7fc144e552e678c6543c34e8c" args="(long nx, long ny, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cnew_mmap           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(mat) matrix object, mmapped from file. 
<p>
be aware that the data is not 8-byte aligned. The file is truncated if already exists. 
</div>
</div><p>
<a class="anchor" name="0ad4e8669ecf08ee0f0811d9eb24544d"></a><!-- doxytag: member="cmat.h::ccellnew_mmap" ref="0ad4e8669ecf08ee0f0811d9eb24544d" args="(long nx, long ny, long *nnx, long *nny, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellnew_mmap           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>nnx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>nny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(cell) matrix cell object, mmapped from file. 
<p>
be aware that the data is not 8-byte aligned. The file is truncated if already exists. 
</div>
</div><p>
<a class="anchor" name="2c1c6578e7f7960142a73e928f6cd192"></a><!-- doxytag: member="cmat.h::ccellnewsame_mmap" ref="2c1c6578e7f7960142a73e928f6cd192" args="(long nx, long ny, long mx, long my, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellnewsame_mmap           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(cell) matrix cell object, with identical blocks, mmapped from file. 
<p>
be aware that the data is not 8-byte aligned. The file is truncated if already exists. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Nov 3 13:02:51 2010 for maos-0.7.1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
