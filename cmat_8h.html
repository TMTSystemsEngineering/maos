<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>maos-0.6.1: lib/cmat.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lib/cmat.h File Reference</h1>Contains the mathematically functions regarding to <a class="el" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a> and <a class="el" href="structccell.html" title="an 2-d block matrix of cmat.">ccell</a> object.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#52711a0852dba5f35bab3591c8b2ec09">cnew_ref</a> (dcomplex *p, long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creat a X(mat) object to reference an already existing vector.  <a href="#52711a0852dba5f35bab3591c8b2ec09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0e9274761076691022cbd210922e2107">cnew_data</a> (dcomplex *p, long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creat a X(mat) object with already allocated memory chunk.  <a href="#0e9274761076691022cbd210922e2107"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#bb2b86ffc48237c760e652708aaf1415">cnew</a> (long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new T matrix object.  <a href="#bb2b86ffc48237c760e652708aaf1415"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#856b68d7f24f9f844306dc5580808e9e">cfree_keepdata</a> (<a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the X(mat), but keep the data.  <a href="#856b68d7f24f9f844306dc5580808e9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#275de6db48fa66bf5228f89005903839">cfree_do</a> (<a class="el" href="structcmat.html">cmat</a> *A, int keepdata)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(mat) object.  <a href="#275de6db48fa66bf5228f89005903839"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#35b15d57f984dca577d67bc75fd1cf75">cresize</a> (<a class="el" href="structcmat.html">cmat</a> *A, long nx, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize a matrix by adding or removing columns or rows.  <a href="#35b15d57f984dca577d67bc75fd1cf75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#3f2400e9e770c0f2b7ea98c103cc5c10">cref</a> (<a class="el" href="structcmat.html">cmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creat a X(mat) reference an existing X(mat).  <a href="#3f2400e9e770c0f2b7ea98c103cc5c10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#68a7e2a1455ebc1f35863ea9724d0643">cref_reshape</a> (<a class="el" href="structcmat.html">cmat</a> *in, int nx, int ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create an new X(mat) reference another with different shape.  <a href="#68a7e2a1455ebc1f35863ea9724d0643"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#16a273177027c4134922936b2440c72e">crefcols</a> (<a class="el" href="structcmat.html">cmat</a> *in, long icol, long ncol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creat a new X(mat) referencing columns in existing X(mat).  <a href="#16a273177027c4134922936b2440c72e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#c82f2f9e84a8c582dfa64b207036fab9">csub</a> (const <a class="el" href="structcmat.html">cmat</a> *in, long sx, long nx, long sy, long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new sub matrix of nx*ny starting from(sx,sy).  <a href="#c82f2f9e84a8c582dfa64b207036fab9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#a599a4058986f102d01ddcb6723af232">ccat</a> (const <a class="el" href="structcmat.html">cmat</a> *in1, const <a class="el" href="structcmat.html">cmat</a> *in2, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">concatenate two matrixes into 1 along dimension "dim"  <a href="#a599a4058986f102d01ddcb6723af232"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#6018457a413452c4e0fbce6a80da6b4b">carrfree</a> (<a class="el" href="structcmat.html">cmat</a> **As, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free a X(mat) array.  <a href="#6018457a413452c4e0fbce6a80da6b4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#66d5a6e5e44f4035aa069d75c47eaf84">cdup</a> (const <a class="el" href="structcmat.html">cmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">duplicate a X(mat) array  <a href="#66d5a6e5e44f4035aa069d75c47eaf84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#db3c55ee96a9e7249403f738d251688c">ccp</a> (<a class="el" href="structcmat.html">cmat</a> **out0, const <a class="el" href="structcmat.html">cmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy the values from one X(mat) to another.  <a href="#db3c55ee96a9e7249403f738d251688c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#79a7b4a12c6fe0066453af5aac05197e">ctrans</a> (const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">transpose a X(mat) object  <a href="#79a7b4a12c6fe0066453af5aac05197e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#aa3be1e7b9926d4753d27b833b4735aa">cset</a> (<a class="el" href="structcmat.html">cmat</a> *A, const dcomplex val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set values of each element in a X(mat) to val.  <a href="#aa3be1e7b9926d4753d27b833b4735aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#5f6b5be2adda9848d051174da45fc340">czero</a> (<a class="el" href="structcmat.html">cmat</a> *out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialize all numbers in a X(mat) object to 0  <a href="#5f6b5be2adda9848d051174da45fc340"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#917d70d3162af1387e34ab3bd76b14fd">cmax</a> (const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find the maximum value of a X(mat) object  <a href="#917d70d3162af1387e34ab3bd76b14fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#638c8d3934ebd94ceaf7394966ce86f7">cmin</a> (const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find the minimum value of a X(mat) object  <a href="#638c8d3934ebd94ceaf7394966ce86f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#b53df31a0c2920c26bd6a58d1d76e967">cnorm2</a> (const <a class="el" href="structcmat.html">cmat</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the norm2 of A  <a href="#b53df31a0c2920c26bd6a58d1d76e967"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#eacf579254ec4bb0b06a3902052cd471">crandu</a> (<a class="el" href="structcmat.html">cmat</a> *A, const dcomplex mean, <a class="el" href="structmt__state.html">mt_state</a> *rstat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill A with random uniform numbers between [0, 1]*max.  <a href="#eacf579254ec4bb0b06a3902052cd471"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#b9966e372284993b73b92570066a731b">crandn</a> (<a class="el" href="structcmat.html">cmat</a> *A, const dcomplex sigma, <a class="el" href="structmt__state.html">mt_state</a> *rstat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill A with random normal distribution numbers with standard deviation of sigma.  <a href="#b9966e372284993b73b92570066a731b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#c0f00cb8f71b144c21627d1da2dcfb3f">cshow</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">display a X(mat) matrix.  <a href="#c0f00cb8f71b144c21627d1da2dcfb3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#204751357459432e00c5f5ee8d261f56">cscale</a> (<a class="el" href="structcmat.html">cmat</a> *A, dcomplex w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">scale each element of A by w  <a href="#204751357459432e00c5f5ee8d261f56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#cf3340d336a63035bc4aacd6fb03fd87">csum</a> (const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create sum of all the elements in A.  <a href="#cf3340d336a63035bc4aacd6fb03fd87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#8b4328dbfb8ced02b3ef2f523d4e37f5">cadd</a> (<a class="el" href="structcmat.html">cmat</a> **B0, dcomplex bc, const <a class="el" href="structcmat.html">cmat</a> *A, const dcomplex ac)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute B=bc*B+ac*A behavior changed on 2009-11-02.  <a href="#8b4328dbfb8ced02b3ef2f523d4e37f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#a5c02f882f7897bcafa6e65cf8a13c28">cinn</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the inner product of A and B.  <a href="#a5c02f882f7897bcafa6e65cf8a13c28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#8c64a290f550b8e43a6a100d216de986">cwdot</a> (const dcomplex *a, const <a class="el" href="structcmat.html">cmat</a> *w, const dcomplex *b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute weighted dot product a'*(w*b)  <a href="#8c64a290f550b8e43a6a100d216de986"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#c8a9b196602cd2b72cae912c49e4b504">cwdot2</a> (const dcomplex *a, const <a class="el" href="structcmat.html">cmat</a> *w, const dcomplex *b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">special version of dwdot for just 2 element vectors.  <a href="#c8a9b196602cd2b72cae912c49e4b504"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#94c0d4a66c6d83215f077cffcba34146">cwdot3</a> (const dcomplex *a, const <a class="el" href="structcmat.html">cmat</a> *w, const dcomplex *b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">special version of dwdot for just 3 element vectors.  <a href="#94c0d4a66c6d83215f077cffcba34146"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#2417a6c93f1245cf129586dce262aba3">ccwm</a> (<a class="el" href="structcmat.html">cmat</a> *B, const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute component wise multiply B=B.  <a href="#2417a6c93f1245cf129586dce262aba3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#5012aabec0611cd938b01765c892f6b3">cmulvec</a> (dcomplex *restrict y, const <a class="el" href="structcmat.html">cmat</a> *restrict A, const dcomplex *restrict x, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">multiply a X(mat) matrix with a vector and accumulate to y: y+=A*x*alpha  <a href="#5012aabec0611cd938b01765c892f6b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#da9977993e68f94425418b2c68d1789d">cmm</a> (<a class="el" href="structcmat.html">cmat</a> **C0, const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *B, const char trans[2], const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute matrix product using blas dgemm with beta=1; C=beta*C+ alpha *trans(A)*trans(B); if C exist.  <a href="#da9977993e68f94425418b2c68d1789d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#16f114b8d7e5173d9928b3dbb3f268a5">cinvspd_inplace</a> (<a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace invert a small square SPD matrix using lapack dposv_, usually (A'*w*A).  <a href="#16f114b8d7e5173d9928b3dbb3f268a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#d2251ee97ee6cd88196f8fb03f4ac880">cinvspd</a> (const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">out of place version of dinvspd_inplace  <a href="#d2251ee97ee6cd88196f8fb03f4ac880"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#fe6927dc25de67288c63961b3340f69c">cinv_inplace</a> (<a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inplace invert a general square matrix using lapack dgesv_  <a href="#fe6927dc25de67288c63961b3340f69c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#aad7fd796188a37ff988b75286ff1906">cinv</a> (const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">out of place version of dinv  <a href="#aad7fd796188a37ff988b75286ff1906"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#63f8f6199cd41366c1fdd40717c6b3c3">cmcc</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *wt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute (A'*W*A); where diag(W)=wt  <a href="#63f8f6199cd41366c1fdd40717c6b3c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#4a8db9c35e106c64a679ae96beb61b66">cimcc</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *wt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute inv(dmcc(A, wt))  <a href="#4a8db9c35e106c64a679ae96beb61b66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#364b9a68838d38ae710f3ade6e5e5820">ctmcc</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *wt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute (A*W*A'); where diag(W)=wt  <a href="#364b9a68838d38ae710f3ade6e5e5820"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#862a7aa868fe53404dc29d060b5f044d">cpinv</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *wt, const <a class="el" href="structcsp.html">csp</a> *Wsp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the pseudo inverse of matrix A with weigthing of full matrix W or sparse matrix weighting Wsp.  <a href="#862a7aa868fe53404dc29d060b5f044d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#77dbd9fcfc2e3185fc072bd6bec5e5e5">cdiff</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the relative difference betwee two vectors.  <a href="#77dbd9fcfc2e3185fc072bd6bec5e5e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#f962ae5334dec4a29e6626bc0be8b19b">ccircle</a> (<a class="el" href="structcmat.html">cmat</a> *A, double cx, double cy, double r, dcomplex val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a new gray pixel map generation based on bilinear influence functions used in mkw.  <a href="#f962ae5334dec4a29e6626bc0be8b19b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#779b108bf238d17187f25d3eee0f3fe9">ccircle_symbolic</a> (<a class="el" href="structcmat.html">cmat</a> *A, double cx, double cy, double r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">similar to X(circle).  <a href="#779b108bf238d17187f25d3eee0f3fe9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#2e68e24dcc5d7ffd8d9b2c575e0830b9">cfftshift</a> (<a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">shift frequency components by n/2  <a href="#2e68e24dcc5d7ffd8d9b2c575e0830b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#72f5647463dae0b89a5c8e444f580de0">ccpcorner2center</a> (<a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structcmat.html">cmat</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reorder B and embed/crop into center of A  <a href="#72f5647463dae0b89a5c8e444f580de0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#834e5e2f254160faa414569a60282089">cshift</a> (<a class="el" href="structcmat.html">cmat</a> **B0, const <a class="el" href="structcmat.html">cmat</a> *A, int sx, int sy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cyclic shift A by nx and ny to B.  <a href="#834e5e2f254160faa414569a60282089"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#1cccdaf44daa400ae770f49e5dc91771">crotvec</a> (<a class="el" href="structcmat.html">cmat</a> *A, const double theta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">rotate the vectors CCW.  <a href="#1cccdaf44daa400ae770f49e5dc91771"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#39e013291512a0930b8e18ba7efd9071">crotvecnn</a> (<a class="el" href="structcmat.html">cmat</a> **B0, const <a class="el" href="structcmat.html">cmat</a> *A, double theta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">rotate a 2x2 covariance matrix A by theta CCW (coordinate rotate -theta CCW) or from ra to xy coordinate.  <a href="#39e013291512a0930b8e18ba7efd9071"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#b7184001fed6ff87e17292e2092ee4b8">cmulvec3</a> (dcomplex *y, const <a class="el" href="structcmat.html">cmat</a> *A, const dcomplex *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">T matrix vector multiply optimized for just three values.  <a href="#b7184001fed6ff87e17292e2092ee4b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#689ab6d12867fee7225a83f93f1a0a9d">ccog</a> (double *grad, const <a class="el" href="structcmat.html">cmat</a> *i0, double offsetx, double offsety, double thres, double bkgrnd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute thresholded center of gravity.  <a href="#689ab6d12867fee7225a83f93f1a0a9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#47b5130ae904c436b75d6699abf025c6">cshift2center</a> (<a class="el" href="structcmat.html">cmat</a> *A, double offsetx, double offsety)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift the image in A to center on physical center+[offsetx,offsety] using cog and fft.  <a href="#47b5130ae904c436b75d6699abf025c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#66f7b38cee9d08a96f2b6e4b5c971fa4">cclip</a> (<a class="el" href="structcmat.html">cmat</a> *A, double min, double max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limit numbers in A to within [min, max].  <a href="#66f7b38cee9d08a96f2b6e4b5c971fa4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#77fc55aade8619fa7fab51a2887f0535">cgramschmidt</a> (<a class="el" href="structcmat.html">cmat</a> *Mod, double *amp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">OrthNormalize column vector in Mod, with weighting from vector amp.  <a href="#77fc55aade8619fa7fab51a2887f0535"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#8d75289b919758fc3d3919b6026ba406">cmuldiag</a> (<a class="el" href="structcmat.html">cmat</a> *A, <a class="el" href="structcmat.html">cmat</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A=A*B, where diag(B)=s.  <a href="#8d75289b919758fc3d3919b6026ba406"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#dd74de8c67cb4e5f897778c0268d7744">ccwpow</a> (<a class="el" href="structcmat.html">cmat</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raise all elements to power power.  <a href="#dd74de8c67cb4e5f897778c0268d7744"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#ea36bb01ebe29d23687c2d6738080de1">csvd</a> (<a class="el" href="structdmat.html">dmat</a> **Sdiag, <a class="el" href="structcmat.html">cmat</a> **U, <a class="el" href="structcmat.html">cmat</a> **VT, const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SVD of a general matrix.  <a href="#ea36bb01ebe29d23687c2d6738080de1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#e3d755e9c6714e93a155d710b421dd06">csvd_pow</a> (<a class="el" href="structcmat.html">cmat</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes pow(A,power) using svd  <a href="#e3d755e9c6714e93a155d710b421dd06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#2289f10c6693d6253721db413bb7d61f">caddI</a> (<a class="el" href="structcmat.html">cmat</a> *A, dcomplex val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add val to diagonal values of A.  <a href="#2289f10c6693d6253721db413bb7d61f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#d39a391d8bbcc4b7576df57820fc8eb7">ctikcr</a> (<a class="el" href="structcmat.html">cmat</a> *A, dcomplex thres)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply tikhonov regularization to A.  <a href="#d39a391d8bbcc4b7576df57820fc8eb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#d1f4093f58b84b2e125919868b103a88">cmulsp</a> (<a class="el" href="structcmat.html">cmat</a> **yout, const <a class="el" href="structcmat.html">cmat</a> *x, const <a class="el" href="structcsp.html">csp</a> *A, const dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">y=y+alpha*OP(x)*OP(A); implemented by transposing x,y index in sptmulmat implementation TESTED OK.  <a href="#d1f4093f58b84b2e125919868b103a88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#071ca1c1e64bb1ae6b9ca352a69a31b0">clogspace</a> (double emin, double emax, long n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create log spaced vector.  <a href="#071ca1c1e64bb1ae6b9ca352a69a31b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#5d357153670b6ce7f3eb9b7dee553912">clinspace</a> (double emin, double emax, long n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create linearly spaced vector.  <a href="#5d357153670b6ce7f3eb9b7dee553912"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#e546d587249af8bbb4c09a03ff2cb9fd">cinterp1</a> (<a class="el" href="structdmat.html">dmat</a> *xin, <a class="el" href="structdmat.html">dmat</a> *yin, <a class="el" href="structdmat.html">dmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolate using linear interp.  <a href="#e546d587249af8bbb4c09a03ff2cb9fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0fcc7887067339b812f96bc684f47f4c">cinterp1log</a> (<a class="el" href="structdmat.html">dmat</a> *xin, <a class="el" href="structdmat.html">dmat</a> *yin, <a class="el" href="structdmat.html">dmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interpolate using log(xin) and log(xnew) xin is the coordinate of yin.  <a href="#0fcc7887067339b812f96bc684f47f4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#10d49d59390d39b5398979a55f90441a">chistfill</a> (<a class="el" href="structdmat.html">dmat</a> **out, const <a class="el" href="structcmat.html">cmat</a> *A, double center, double spacing, int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For each entry in A, call repeatly to collect its histogram, centered at center, spaced by spacing, for n bins in total.  <a href="#10d49d59390d39b5398979a55f90441a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#1f6ecbeecb56f05d855f3e1f21342dc2">cspline_prep</a> (<a class="el" href="structcmat.html">cmat</a> *x, <a class="el" href="structcmat.html">cmat</a> *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">1D Cubic spline interpolation preparation.  <a href="#1f6ecbeecb56f05d855f3e1f21342dc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#105e0e17a7f377c30b63ff9bc5f002e1">cspline_eval</a> (<a class="el" href="structcmat.html">cmat</a> *coeff, <a class="el" href="structcmat.html">cmat</a> *x, <a class="el" href="structcmat.html">cmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evluate the cubic spline represented by nx5 matrix coeff, at location array xnew.  <a href="#105e0e17a7f377c30b63ff9bc5f002e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#6dc13156073384a5722fcf7fd5f0833a">cspline</a> (<a class="el" href="structcmat.html">cmat</a> *x, <a class="el" href="structcmat.html">cmat</a> *y, <a class="el" href="structcmat.html">cmat</a> *xnew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do 1D cubic spline all at once by calling X(spline_prep) and X(spline_evald).  <a href="#6dc13156073384a5722fcf7fd5f0833a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#6d44ad8fe4da7595e7b54ac85015cfaa">cbspline_prep</a> (<a class="el" href="structcmat.html">cmat</a> *x, <a class="el" href="structcmat.html">cmat</a> *y, <a class="el" href="structcmat.html">cmat</a> *z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2D cubic spline interpolation preparation.  <a href="#6d44ad8fe4da7595e7b54ac85015cfaa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#ee339b2c28b3fcf24144233e6b078002">cbspline_eval</a> (<a class="el" href="structccell.html">ccell</a> *coeff, <a class="el" href="structcmat.html">cmat</a> *x, <a class="el" href="structcmat.html">cmat</a> *y, <a class="el" href="structcmat.html">cmat</a> *xnew, <a class="el" href="structcmat.html">cmat</a> *ynew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate 2D cubic spline at location defined 2-d arrays by xnew, ynew.  <a href="#ee339b2c28b3fcf24144233e6b078002"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#cdcbda2dbd5dfec8344b8bada36a0a35">ccellnew</a> (const long nx, const long ny)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a new block matrix.  <a href="#cdcbda2dbd5dfec8344b8bada36a0a35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#3e751c651d80acbebc93a7536bfd4e65">ccellnew2</a> (const <a class="el" href="structccell.html">ccell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create an new X(cell) similar to A in shape  <a href="#3e751c651d80acbebc93a7536bfd4e65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#193a03f98ee7128386819d9821ceb859">ccellzero</a> (<a class="el" href="structccell.html">ccell</a> *dc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">setting all elements of a X(cell) to zero.  <a href="#193a03f98ee7128386819d9821ceb859"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#d9128f3e7703bfc29bb33d37397cf5c6">ccellset</a> (<a class="el" href="structccell.html">ccell</a> *dc, dcomplex alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">setting all elements of a X(cell) to alpha.  <a href="#d9128f3e7703bfc29bb33d37397cf5c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#6631a2e1f0b26b3b14723cb8e127ab11">ccellfree_do</a> (<a class="el" href="structccell.html">ccell</a> *dc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a X(cell) object.  <a href="#6631a2e1f0b26b3b14723cb8e127ab11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#db8e69bbe2c05a039f236fbb2eae12de">ccelltrans</a> (const <a class="el" href="structccell.html">ccell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">transpose a X(cell) object  <a href="#db8e69bbe2c05a039f236fbb2eae12de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#1f870a53b480b1477c2bc30e0178a516">ccellref</a> (const <a class="el" href="structccell.html">ccell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creat a X(cell) reference an existing X(cell) by referencing the elements.  <a href="#1f870a53b480b1477c2bc30e0178a516"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0ed077f33b1a869fd6154ded4b557a4b">ccelldup</a> (const <a class="el" href="structccell.html">ccell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">duplicate a X(cell) object.  <a href="#0ed077f33b1a869fd6154ded4b557a4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#84b4ddc50d2114e9be97128fdf424e07">ccellcp</a> (<a class="el" href="structccell.html">ccell</a> **out0, const <a class="el" href="structccell.html">ccell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy the values from one X(cell) to another.  <a href="#84b4ddc50d2114e9be97128fdf424e07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#83dd0483ef61373a16ee4c5478a919d1">ccellnorm2</a> (const <a class="el" href="structccell.html">ccell</a> *in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute norm2.  <a href="#83dd0483ef61373a16ee4c5478a919d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0f63e81c5c497006f9f355a1f288cf91">ccellscale</a> (<a class="el" href="structccell.html">ccell</a> *A, double w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">scale each element of A.  <a href="#0f63e81c5c497006f9f355a1f288cf91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#00c2da2fc7f3d49037226159745c2378">ccellreduce</a> (const <a class="el" href="structccell.html">ccell</a> *A, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reduce nx*ny cell matrix to 1*ny if dim=1 and nx*11 if dim=2  <a href="#00c2da2fc7f3d49037226159745c2378"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#6bc29f4fe8fda3c3a1ca2fe3ac56b126">ccellcat</a> (const <a class="el" href="structccell.html">ccell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">concatenate two cell matrices along dimenstion 'dim'  <a href="#6bc29f4fe8fda3c3a1ca2fe3ac56b126"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#46bafd0a0ab7198be7c8c7ad4c42f88b">ccellcat_each</a> (const <a class="el" href="structccell.html">ccell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">concatenate coresponding elements of each X(cell).  <a href="#46bafd0a0ab7198be7c8c7ad4c42f88b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#d65426e91446c2e95481a47fc9e8716a">ccelldropempty</a> (<a class="el" href="structccell.html">ccell</a> **A0, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">drop empty rows or columns.  <a href="#d65426e91446c2e95481a47fc9e8716a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#e52c5a573fcaa559847488c664365e62">ccelladd</a> (<a class="el" href="structccell.html">ccell</a> **B0, double bc, const <a class="el" href="structccell.html">ccell</a> *A, const double ac)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add one to another.  <a href="#e52c5a573fcaa559847488c664365e62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">dcomplex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#df204a1a88694e37365a17488d1e12c8">ccellinn</a> (const <a class="el" href="structccell.html">ccell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the inner produce of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>.  <a href="#df204a1a88694e37365a17488d1e12c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#92110ce17c83d4a1f68d856ec32a90cd">ccellcwm</a> (<a class="el" href="structccell.html">ccell</a> *B, const <a class="el" href="structccell.html">ccell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Component wise multiply of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a> B=A.  <a href="#92110ce17c83d4a1f68d856ec32a90cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#afe341e06821b09968d37a530a3adc3e">ccellmm</a> (<a class="el" href="structccell.html">ccell</a> **C0, const <a class="el" href="structccell.html">ccell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B, const char trans[2], const double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute A*B and add to C0.  <a href="#afe341e06821b09968d37a530a3adc3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#99b65983778109d4aa815d3ea5db9414">ccellinvspd</a> (<a class="el" href="structccell.html">ccell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Invert a SPD matrix.  <a href="#99b65983778109d4aa815d3ea5db9414"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#ddb2ebf6b55726391b1ea6be0e210e2e">ccellinv</a> (<a class="el" href="structccell.html">ccell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Invert a matrix.  <a href="#ddb2ebf6b55726391b1ea6be0e210e2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#72a43514eb1abfbe161f74f5a223f2f5">ccellinvspd_each</a> (<a class="el" href="structccell.html">ccell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">invert each component of the <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>.  <a href="#72a43514eb1abfbe161f74f5a223f2f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#2c8c0809e00fd5d528cbb31048f3c52a">ccell2m</a> (const <a class="el" href="structccell.html">ccell</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a block matrix to a matrix.  <a href="#2c8c0809e00fd5d528cbb31048f3c52a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#1545f84a1ac4226ce43fbfc8ba0af5db">c2cellref</a> (const <a class="el" href="structcmat.html">cmat</a> *A, int *dims, int ndim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convert a vector to cell using dimensions specified in dims.  <a href="#1545f84a1ac4226ce43fbfc8ba0af5db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#a5983177f2055cae1bb16f5a53e3f4aa">c2cell</a> (<a class="el" href="structccell.html">ccell</a> **B, const <a class="el" href="structcmat.html">cmat</a> *A, const <a class="el" href="structccell.html">ccell</a> *ref)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">make A a cell array using shape information from ref if *B is NULL  <a href="#a5983177f2055cae1bb16f5a53e3f4aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#b0d7e1c7d7eb2810eff34b04111129c8">ccelldropzero</a> (<a class="el" href="structccell.html">ccell</a> *B, double thres)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">drop empty blocks (zero).  <a href="#b0d7e1c7d7eb2810eff34b04111129c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#2fd83c2f600649a6205e8c62547f6e8d">ccelldiff</a> (const <a class="el" href="structccell.html">ccell</a> *A, const <a class="el" href="structccell.html">ccell</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute ||A-B||/||A|| use mean.  <a href="#2fd83c2f600649a6205e8c62547f6e8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#fdb96e19ff1dfea164570fc47815a2ab">ccellclip</a> (<a class="el" href="structccell.html">ccell</a> *Ac, double min, double max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">clip a X(cell) array to max at 'max', min at 'min'  <a href="#fdb96e19ff1dfea164570fc47815a2ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#6e30556d58339cea7a00a4b163822af4">ccelltikcr</a> (<a class="el" href="structccell.html">ccell</a> *A, double thres)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply tickholov regularization of relative thres to cell array by converting it to mat.  <a href="#6e30556d58339cea7a00a4b163822af4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0a9902ff737584f210c3730f430b1599">ccellpinv</a> (const <a class="el" href="structccell.html">ccell</a> *A, const <a class="el" href="structccell.html">ccell</a> *wt, const <a class="el" href="structcspcell.html">cspcell</a> *Wsp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the pseudo inverse of block matrix A.  <a href="#0a9902ff737584f210c3730f430b1599"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#611ce556f87c2ac01da0b00b717cd964">ccellmulsp</a> (<a class="el" href="structccell.html">ccell</a> **C0, const <a class="el" href="structccell.html">ccell</a> *A, const <a class="el" href="structcspcell.html">cspcell</a> *B, double alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a cell with a sparse cell.  <a href="#611ce556f87c2ac01da0b00b717cd964"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#35a0966fdc0e65bdcf290c75e0404713">ccelladdI</a> (<a class="el" href="structccell.html">ccell</a> *A, double a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add a to diagonal elements of A;  <a href="#35a0966fdc0e65bdcf290c75e0404713"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#d7eece0d6b59dbc7d2e98d5ce866b21b">ccellsvd_pow</a> (<a class="el" href="structccell.html">ccell</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute the power of a block matrix using svd method.  <a href="#d7eece0d6b59dbc7d2e98d5ce866b21b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#92d8633d3243ae2a95e43d6b41c4a2cb">ccellcwpow</a> (<a class="el" href="structccell.html">ccell</a> *A, double power)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">raise each cell in the cell array to power of power.  <a href="#92d8633d3243ae2a95e43d6b41c4a2cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#28f2c1a91c80f5dc8c951f875d79f2de">cwritedata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp, const <a class="el" href="structcmat.html">cmat</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains routines to write/read dense/sparse matrix into/from file.  <a href="#28f2c1a91c80f5dc8c951f875d79f2de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#5fc25bdbb6758549b60bc4b9c34a9bef">ccellwritedata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp, const <a class="el" href="structccell.html">ccell</a> *dc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to write cell array of dense matrix data.  <a href="#5fc25bdbb6758549b60bc4b9c34a9bef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#e9df93488639190f0b09a837ba21fd3e">creaddata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to read dense matrix into memory from file pointer.  <a href="#e9df93488639190f0b09a837ba21fd3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#41b9a0829de990592462d11aedcb2fa5">ccellreaddata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to read dense matrix cell array into memory from file pointer.  <a href="#41b9a0829de990592462d11aedcb2fa5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#c856ab97d0032304beb9cb4fe0465528">cspwritedata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp, const <a class="el" href="structcsp.html">csp</a> *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to write sparse matrix data into file pointed using a file pointer.  <a href="#c856ab97d0032304beb9cb4fe0465528"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#c52d1399af426794abf242869a2ec077">cspreaddata</a> (<a class="el" href="structfile__t.html">file_t</a> *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to read sparse matrix data from file pointer into memory.  <a href="#c52d1399af426794abf242869a2ec077"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#9593e890699be4f48e826d9048018c04">cwrite</a> (const <a class="el" href="structcmat.html">cmat</a> *A, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write dense matrix into a file.  <a href="#9593e890699be4f48e826d9048018c04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#e75214457fa1e5c394d311b307a7f5e4">ccellwrite</a> (const <a class="el" href="structccell.html">ccell</a> *dc, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write cell array of dense matrix into a file.  <a href="#e75214457fa1e5c394d311b307a7f5e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#d68739105dfbaca4f86b98fe0666f259">cread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read dense matrix into memory from file.  <a href="#d68739105dfbaca4f86b98fe0666f259"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0a22a48812769ec4f65d0cc94b727059">ccellread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read cell array of dense matrix into memory from file.  <a href="#0a22a48812769ec4f65d0cc94b727059"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#ffeec010de1565a36f9d12612f9fae2f">cspwrite</a> (const <a class="el" href="structcsp.html">csp</a> *sp, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write sparse matrix into file.  <a href="#ffeec010de1565a36f9d12612f9fae2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0b8af4e4788bab83b6a9ed7a70017066">cspcellwrite</a> (const <a class="el" href="structcspcell.html">cspcell</a> *spc, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to write cell array of sparse matrix into file.  <a href="#0b8af4e4788bab83b6a9ed7a70017066"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsp.html">csp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#65b955d360ccf1d72c40d93d9b6e077e">cspread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read sparse metrix from file.  <a href="#65b955d360ccf1d72c40d93d9b6e077e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#1e52a56ac12aa2823536f0c9e4c20584">cspcellread</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User callable function to read cell array of sparse matrix from file.  <a href="#1e52a56ac12aa2823536f0c9e4c20584"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#ac8504a7fc144e552e678c6543c34e8c">cnew_mmap</a> (long nx, long ny, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(mat) matrix object, mmapped from file.  <a href="#ac8504a7fc144e552e678c6543c34e8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#0ad4e8669ecf08ee0f0811d9eb24544d">ccellnew_mmap</a> (long nx, long ny, long *nnx, long *nny, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(cell) matrix cell object, mmapped from file.  <a href="#0ad4e8669ecf08ee0f0811d9eb24544d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmat_8h.html#2c1c6578e7f7960142a73e928f6cd192">ccellnewsame_mmap</a> (long nx, long ny, long mx, long my, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new X(cell) matrix cell object, with identical blocks, mmapped from file.  <a href="#2c1c6578e7f7960142a73e928f6cd192"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Contains the mathematically functions regarding to <a class="el" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a> and <a class="el" href="structccell.html" title="an 2-d block matrix of cmat.">ccell</a> object. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="52711a0852dba5f35bab3591c8b2ec09"></a><!-- doxytag: member="cmat.h::cnew_ref" ref="52711a0852dba5f35bab3591c8b2ec09" args="(dcomplex *p, long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cnew_ref           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creat a X(mat) object to reference an already existing vector. 
<p>
free the X(mat) object won't free the existing vector. <div class="fragment"><pre class="fragment"><a name="l00123"></a>00123                                           {
<a name="l00124"></a>00124     <span class="keywordflow">return</span> X(new_do)(p,nx,ny,1);
<a name="l00125"></a>00125 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0e9274761076691022cbd210922e2107"></a><!-- doxytag: member="cmat.h::cnew_data" ref="0e9274761076691022cbd210922e2107" args="(dcomplex *p, long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cnew_data           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creat a X(mat) object with already allocated memory chunk. 
<p>
the memory is freed when the memory is freed. <div class="fragment"><pre class="fragment"><a name="l00131"></a>00131                                            {
<a name="l00132"></a>00132     <span class="keywordflow">return</span> X(new_do)(p,nx,ny,0);
<a name="l00133"></a>00133 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bb2b86ffc48237c760e652708aaf1415"></a><!-- doxytag: member="cmat.h::cnew" ref="bb2b86ffc48237c760e652708aaf1415" args="(long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cnew           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new T matrix object. 
<p>
initialized all to zero. <div class="fragment"><pre class="fragment"><a name="l00138"></a>00138                                 {
<a name="l00139"></a>00139     <span class="keywordflow">return</span> X(new_do)(NULL,nx,ny,0);
<a name="l00140"></a>00140 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="856b68d7f24f9f844306dc5580808e9e"></a><!-- doxytag: member="cmat.h::cfree_keepdata" ref="856b68d7f24f9f844306dc5580808e9e" args="(cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cfree_keepdata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free the X(mat), but keep the data. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00145"></a>00145                                 {
<a name="l00146"></a>00146     X(free_do)(A,1);
<a name="l00147"></a>00147 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="275de6db48fa66bf5228f89005903839"></a><!-- doxytag: member="cmat.h::cfree_do" ref="275de6db48fa66bf5228f89005903839" args="(cmat *A, int keepdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>keepdata</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(mat) object. 
<p>
if keepdata!=0, will not free A-&gt;p. <div class="fragment"><pre class="fragment"><a name="l00151"></a>00151                                         {
<a name="l00152"></a>00152     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00153"></a>00153     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcmat.html#9caa98929d0b8ff67c7ef6a56ce56940" title="reference count">nref</a>[0]==1){
<a name="l00154"></a>00154     free(A-&gt;<a class="code" href="structcmat.html#9caa98929d0b8ff67c7ef6a56ce56940" title="reference count">nref</a>);
<a name="l00155"></a>00155     <span class="keywordflow">if</span>(!keepdata &amp;&amp; A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>){
<a name="l00156"></a>00156         <span class="keywordflow">switch</span>(A-&gt;<a class="code" href="structcmat.html#35a7c4fdf16005fb3da25ad7e553f116" title="specify whether this is allocated or in shared memory.">type</a>){
<a name="l00157"></a>00157         <span class="keywordflow">case</span> MT_NORMAL:
<a name="l00158"></a>00158         free(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>); 
<a name="l00159"></a>00159 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span>        <a class="code" href="fft_8c.html#1752744dba77b7791b1a629eab4ca99e" title="Free FFTW plans.">cfree_plan</a>(A);
<a name="l00161"></a>00161 <span class="preprocessor">#endif</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span>        <span class="keywordflow">break</span>;
<a name="l00163"></a>00163         <span class="keywordflow">case</span> MT_MMAP:
<a name="l00164"></a>00164         {
<a name="l00165"></a>00165 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span>        <a class="code" href="fft_8c.html#1752744dba77b7791b1a629eab4ca99e" title="Free FFTW plans.">cfree_plan</a>(A);
<a name="l00167"></a>00167 <span class="preprocessor">#endif</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>        <span class="keywordtype">long</span> headersize=<span class="keyword">sizeof</span>(long)*2+<span class="keyword">sizeof</span>(uint32_t);
<a name="l00169"></a>00169         munmap(((<span class="keywordtype">char</span>*)A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>)-headersize, headersize+A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>*<span class="keyword">sizeof</span>(T));
<a name="l00170"></a>00170         }
<a name="l00171"></a>00171         <span class="keywordflow">break</span>;
<a name="l00172"></a>00172         <span class="keywordflow">case</span> MT_REF:<span class="comment">//reference from a nother vector. don't free.</span>
<a name="l00173"></a>00173         <span class="keywordflow">break</span>;
<a name="l00174"></a>00174         <span class="keywordflow">default</span>:
<a name="l00175"></a>00175         warning(<span class="stringliteral">"Wrong format: p=%p. type=%ld\n"</span>, A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, A-&gt;<a class="code" href="structcmat.html#35a7c4fdf16005fb3da25ad7e553f116" title="specify whether this is allocated or in shared memory.">type</a>);
<a name="l00176"></a>00176         }
<a name="l00177"></a>00177     }
<a name="l00178"></a>00178     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcmat.html#9caa98929d0b8ff67c7ef6a56ce56940" title="reference count">nref</a>[0]&gt;1){
<a name="l00179"></a>00179     A-&gt;<a class="code" href="structcmat.html#9caa98929d0b8ff67c7ef6a56ce56940" title="reference count">nref</a>[0]--;
<a name="l00180"></a>00180     }<span class="keywordflow">else</span>{
<a name="l00181"></a>00181     error(<span class="stringliteral">"The ref is less than 1. unlikely!!!:%ld\n"</span>,A-&gt;<a class="code" href="structcmat.html#9caa98929d0b8ff67c7ef6a56ce56940" title="reference count">nref</a>[0]);
<a name="l00182"></a>00182     }
<a name="l00183"></a>00183     free(A);
<a name="l00184"></a>00184 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="35b15d57f984dca577d67bc75fd1cf75"></a><!-- doxytag: member="cmat.h::cresize" ref="35b15d57f984dca577d67bc75fd1cf75" args="(cmat *A, long nx, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cresize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resize a matrix by adding or removing columns or rows. 
<p>
Data is kept whever possible. Not used as of 2010-09-07. <div class="fragment"><pre class="fragment"><a name="l00190"></a>00190                                            {
<a name="l00191"></a>00191     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcmat.html#9caa98929d0b8ff67c7ef6a56ce56940" title="reference count">nref</a>[0]&gt;1){
<a name="l00192"></a>00192     error(<span class="stringliteral">"Resizing a referenced vector\n"</span>);
<a name="l00193"></a>00193     }
<a name="l00194"></a>00194     <span class="keywordflow">if</span>(nx==0 || ny==0){
<a name="l00195"></a>00195     warning(<span class="stringliteral">"resizing to (%ld, %ld). Free the vector.\n"</span>, nx,ny);
<a name="l00196"></a>00196     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>) free(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>);
<a name="l00197"></a>00197     A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>=NULL;
<a name="l00198"></a>00198     A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>=nx;
<a name="l00199"></a>00199     A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>=ny;
<a name="l00200"></a>00200     }
<a name="l00201"></a>00201     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>&gt;nx || A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>&gt;ny){
<a name="l00202"></a>00202     warning(<span class="stringliteral">"Resize from (%ld,%ld) to (%ld,%ld)\n"</span>,
<a name="l00203"></a>00203         A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>,A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>,nx,ny);
<a name="l00204"></a>00204     }
<a name="l00205"></a>00205     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==nx){
<a name="l00206"></a>00206     A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>=realloc(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, <span class="keyword">sizeof</span>(T)*nx*ny);
<a name="l00207"></a>00207     <span class="keywordflow">if</span>(nx*ny&gt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>){
<a name="l00208"></a>00208         memset(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>+A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>, 0, (nx*ny-A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>)*<span class="keyword">sizeof</span>(T));
<a name="l00209"></a>00209     }
<a name="l00210"></a>00210     }<span class="keywordflow">else</span>{
<a name="l00211"></a>00211     warning(<span class="stringliteral">"column vector length is not preserved!!!"</span>);
<a name="l00212"></a>00212     T *p=calloc(nx*ny,<span class="keyword">sizeof</span>(T));
<a name="l00213"></a>00213     <span class="keywordtype">long</span> minx=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>&lt;nx?A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>:nx;
<a name="l00214"></a>00214     <span class="keywordtype">long</span> miny=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>&lt;ny?A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>:ny;
<a name="l00215"></a>00215     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;miny; iy++){
<a name="l00216"></a>00216         memcpy(p+iy*nx, A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>+iy*A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, <span class="keyword">sizeof</span>(T)*minx);
<a name="l00217"></a>00217     }
<a name="l00218"></a>00218     free(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>);
<a name="l00219"></a>00219     A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>=p;
<a name="l00220"></a>00220     }
<a name="l00221"></a>00221 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3f2400e9e770c0f2b7ea98c103cc5c10"></a><!-- doxytag: member="cmat.h::cref" ref="3f2400e9e770c0f2b7ea98c103cc5c10" args="(cmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cref           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creat a X(mat) reference an existing X(mat). 
<p>
Use the reference carefully. <div class="fragment"><pre class="fragment"><a name="l00226"></a>00226                           {
<a name="l00227"></a>00227     <span class="keywordflow">if</span>(!in) <span class="keywordflow">return</span> NULL;
<a name="l00228"></a>00228     X(mat) *out=calloc(1, <span class="keyword">sizeof</span>(X(mat)));
<a name="l00229"></a>00229     <span class="keywordflow">if</span>(!out){
<a name="l00230"></a>00230     error(<span class="stringliteral">"Allocation failed\n"</span>);
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232     memcpy(out,in,<span class="keyword">sizeof</span>(X(mat)));
<a name="l00233"></a>00233     out-&gt;nref[0]++;
<a name="l00234"></a>00234     <span class="keywordflow">return</span> out;
<a name="l00235"></a>00235 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="68a7e2a1455ebc1f35863ea9724d0643"></a><!-- doxytag: member="cmat.h::cref_reshape" ref="68a7e2a1455ebc1f35863ea9724d0643" args="(cmat *in, int nx, int ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cref_reshape           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create an new X(mat) reference another with different shape. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00240"></a>00240                                                   {
<a name="l00241"></a>00241     X(mat) *out=X(ref)(in);
<a name="l00242"></a>00242     <span class="keywordflow">if</span>(in-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*in-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>!=nx*ny){
<a name="l00243"></a>00243     error(<span class="stringliteral">"Must not change number of elements\n"</span>);
<a name="l00244"></a>00244     }
<a name="l00245"></a>00245     out-&gt;nx=nx;
<a name="l00246"></a>00246     out-&gt;ny=ny;
<a name="l00247"></a>00247     <span class="keywordflow">return</span> out;
<a name="l00248"></a>00248 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="16a273177027c4134922936b2440c72e"></a><!-- doxytag: member="cmat.h::crefcols" ref="16a273177027c4134922936b2440c72e" args="(cmat *in, long icol, long ncol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* crefcols           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>icol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ncol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creat a new X(mat) referencing columns in existing X(mat). 
<p>
reference counted. not used <div class="fragment"><pre class="fragment"><a name="l00254"></a>00254                                                     {
<a name="l00255"></a>00255     X(mat) *out=calloc(1, <span class="keyword">sizeof</span>(X(mat)));
<a name="l00256"></a>00256     out-&gt;type=MT_REF;
<a name="l00257"></a>00257     out-&gt;nref=in-&gt;<a class="code" href="structcmat.html#9caa98929d0b8ff67c7ef6a56ce56940" title="reference count">nref</a>;
<a name="l00258"></a>00258     out-&gt;nref[0]++;
<a name="l00259"></a>00259     out-&gt;nx=in-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00260"></a>00260     out-&gt;ny=ncol;
<a name="l00261"></a>00261     out-&gt;p=in-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>+icol*out-&gt;nx;
<a name="l00262"></a>00262     <span class="keywordflow">return</span> out;
<a name="l00263"></a>00263 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c82f2f9e84a8c582dfa64b207036fab9"></a><!-- doxytag: member="cmat.h::csub" ref="c82f2f9e84a8c582dfa64b207036fab9" args="(const cmat *in, long sx, long nx, long sy, long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* csub           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new sub matrix of nx*ny starting from(sx,sy). 
<p>
<div class="fragment"><pre class="fragment"><a name="l00268"></a>00268                                                                     {
<a name="l00269"></a>00269     <span class="keywordflow">if</span>(nx&lt;=sx){
<a name="l00270"></a>00270     nx=in-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>-sx;
<a name="l00271"></a>00271     }
<a name="l00272"></a>00272     <span class="keywordflow">if</span>(ny&lt;=sy){
<a name="l00273"></a>00273     ny=in-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>-sy;
<a name="l00274"></a>00274     }
<a name="l00275"></a>00275     X(mat)*out=X(<span class="keyword">new</span>)(nx, ny);
<a name="l00276"></a>00276     <span class="keywordflow">if</span>(sx+nx&gt;in-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> || sy+ny&gt;in-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>){
<a name="l00277"></a>00277     error(<span class="stringliteral">"Invalid parameter range\n"</span>);
<a name="l00278"></a>00278     }
<a name="l00279"></a>00279     PMAT(in, pin);
<a name="l00280"></a>00280     PMAT(out, pout);
<a name="l00281"></a>00281     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;ny; iy++){
<a name="l00282"></a>00282     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;nx; ix++){
<a name="l00283"></a>00283         pout[iy][ix]=pin[iy+sy][ix+sx];
<a name="l00284"></a>00284     }
<a name="l00285"></a>00285     }
<a name="l00286"></a>00286     <span class="keywordflow">return</span> out;
<a name="l00287"></a>00287 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a599a4058986f102d01ddcb6723af232"></a><!-- doxytag: member="cmat.h::ccat" ref="a599a4058986f102d01ddcb6723af232" args="(const cmat *in1, const cmat *in2, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* ccat           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
concatenate two matrixes into 1 along dimension "dim" 
<p>
<div class="fragment"><pre class="fragment"><a name="l00292"></a>00292                                                              {
<a name="l00293"></a>00293     <span class="keywordflow">if</span>(!in2){
<a name="l00294"></a>00294     <span class="keywordflow">if</span>(in1){
<a name="l00295"></a>00295         <span class="keywordflow">return</span> X(dup)(in1);
<a name="l00296"></a>00296     }<span class="keywordflow">else</span>{
<a name="l00297"></a>00297         <span class="keywordflow">return</span> NULL;
<a name="l00298"></a>00298     }
<a name="l00299"></a>00299     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(!in1){
<a name="l00300"></a>00300     <span class="keywordflow">return</span> X(dup)(in2);
<a name="l00301"></a>00301     }
<a name="l00302"></a>00302 
<a name="l00303"></a>00303     X(mat) *out=NULL;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305     <span class="keywordflow">if</span>(dim==1){
<a name="l00306"></a>00306     <span class="comment">//along x.</span>
<a name="l00307"></a>00307     <span class="keywordflow">if</span>(in1-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>!=in2-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>){
<a name="l00308"></a>00308         error(<span class="stringliteral">"Mismatch. in1 is (%ld, %ld), in2 is (%ld, %ld)\n"</span>, 
<a name="l00309"></a>00309           in1-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, in1-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>, in2-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, in2-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l00310"></a>00310     }
<a name="l00311"></a>00311     out=X(<span class="keyword">new</span>)(in1-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>+in2-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, in1-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l00312"></a>00312     PMAT(out,pout);
<a name="l00313"></a>00313     PMAT(in1,pin1);
<a name="l00314"></a>00314     PMAT(in2,pin2);
<a name="l00315"></a>00315     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;in1-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iy++){
<a name="l00316"></a>00316         memcpy(pout[iy],pin1[iy], in1-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*<span class="keyword">sizeof</span>(T));
<a name="l00317"></a>00317         memcpy(pout[iy]+in1-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, pin2[iy], in2-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*<span class="keyword">sizeof</span>(T));
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim==2){
<a name="l00320"></a>00320     <span class="comment">//along y.</span>
<a name="l00321"></a>00321     <span class="keywordflow">if</span>(in1-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>!=in2-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>){
<a name="l00322"></a>00322         error(<span class="stringliteral">"Mismatch. in1 is (%ld, %ld), in2 is (%ld, %ld)\n"</span>, 
<a name="l00323"></a>00323           in1-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, in1-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>, in2-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, in2-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l00324"></a>00324     }
<a name="l00325"></a>00325     out=X(<span class="keyword">new</span>)(in1-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, in1-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>+in2-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l00326"></a>00326     memcpy(out-&gt;p, in1-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, in1-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*in1-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>*<span class="keyword">sizeof</span>(T));
<a name="l00327"></a>00327     memcpy(out-&gt;p+in1-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*in1-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>,in2-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>,in2-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*in2-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>*<span class="keyword">sizeof</span>(T));
<a name="l00328"></a>00328     }<span class="keywordflow">else</span>{
<a name="l00329"></a>00329     error(<span class="stringliteral">"Invalid dim\n"</span>);
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331     <span class="keywordflow">return</span> out;
<a name="l00332"></a>00332 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6018457a413452c4e0fbce6a80da6b4b"></a><!-- doxytag: member="cmat.h::carrfree" ref="6018457a413452c4e0fbce6a80da6b4b" args="(cmat **As, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void carrfree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>As</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
free a X(mat) array. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00337"></a>00337                                    {
<a name="l00338"></a>00338     <span class="keywordtype">int</span> i;
<a name="l00339"></a>00339     <span class="keywordflow">if</span>(!As) <span class="keywordflow">return</span>;
<a name="l00340"></a>00340     <span class="keywordflow">for</span>(i=0; i&lt;n; i++){
<a name="l00341"></a>00341     X(free)(As[i]);
<a name="l00342"></a>00342     }
<a name="l00343"></a>00343     free(As);
<a name="l00344"></a>00344 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="66d5a6e5e44f4035aa069d75c47eaf84"></a><!-- doxytag: member="cmat.h::cdup" ref="66d5a6e5e44f4035aa069d75c47eaf84" args="(const cmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cdup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
duplicate a X(mat) array 
<p>
<div class="fragment"><pre class="fragment"><a name="l00375"></a>00375                                 {
<a name="l00376"></a>00376     X(mat) *out=NULL;
<a name="l00377"></a>00377     X(cp)(&amp;out, in);
<a name="l00378"></a>00378     <span class="keywordflow">return</span> out;
<a name="l00379"></a>00379 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="db3c55ee96a9e7249403f738d251688c"></a><!-- doxytag: member="cmat.h::ccp" ref="db3c55ee96a9e7249403f738d251688c" args="(cmat **out0, const cmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy the values from one X(mat) to another. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00384"></a>00384                                            {
<a name="l00385"></a>00385     <span class="keywordflow">if</span>(in &amp;&amp; in-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>!=0 &amp;&amp; in-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>!=0){
<a name="l00386"></a>00386     <span class="keywordflow">if</span>(!*out0) 
<a name="l00387"></a>00387         *out0=X(<span class="keyword">new</span>)(in-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, in-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l00388"></a>00388     <span class="keywordflow">else</span>{
<a name="l00389"></a>00389         assert(in-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==(*out0)-&gt;nx &amp;&amp; in-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a> == (*out0)-&gt;ny);
<a name="l00390"></a>00390     }
<a name="l00391"></a>00391     X(mat) *out=*out0;
<a name="l00392"></a>00392     memcpy(out-&gt;p, in-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, in-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*in-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>*<span class="keyword">sizeof</span>(T));
<a name="l00393"></a>00393     }<span class="keywordflow">else</span>{
<a name="l00394"></a>00394     X(free)(*out0); *out0=NULL;
<a name="l00395"></a>00395     }
<a name="l00396"></a>00396 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="79a7b4a12c6fe0066453af5aac05197e"></a><!-- doxytag: member="cmat.h::ctrans" ref="79a7b4a12c6fe0066453af5aac05197e" args="(const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* ctrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
transpose a X(mat) object 
<p>
<div class="fragment"><pre class="fragment"><a name="l00401"></a>00401                                  {
<a name="l00402"></a>00402     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l00403"></a>00403     X(mat) *B=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>,A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>);
<a name="l00404"></a>00404     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==1 || A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1){
<a name="l00405"></a>00405     memcpy(B-&gt;p, A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>*<span class="keyword">sizeof</span>(T));
<a name="l00406"></a>00406     }<span class="keywordflow">else</span>{
<a name="l00407"></a>00407     T (*Bp)[B-&gt;nx]=(<span class="keywordtype">void</span>*)B-&gt;p;
<a name="l00408"></a>00408     T (*Ap)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>]=(<span class="keywordtype">void</span>*)A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00409"></a>00409     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;nx; ix++){
<a name="l00410"></a>00410         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iy++){
<a name="l00411"></a>00411         Bp[ix][iy]=Ap[iy][ix];
<a name="l00412"></a>00412         }
<a name="l00413"></a>00413     }
<a name="l00414"></a>00414     }
<a name="l00415"></a>00415     <span class="keywordflow">return</span> B;
<a name="l00416"></a>00416 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="aa3be1e7b9926d4753d27b833b4735aa"></a><!-- doxytag: member="cmat.h::cset" ref="aa3be1e7b9926d4753d27b833b4735aa" args="(cmat *A, const dcomplex val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set values of each element in a X(mat) to val. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00421"></a>00421                                    {
<a name="l00422"></a>00422     <span class="keywordflow">if</span>(A){
<a name="l00423"></a>00423     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l00424"></a>00424         A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]=val;
<a name="l00425"></a>00425     }
<a name="l00426"></a>00426     }
<a name="l00427"></a>00427 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5f6b5be2adda9848d051174da45fc340"></a><!-- doxytag: member="cmat.h::czero" ref="5f6b5be2adda9848d051174da45fc340" args="(cmat *out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void czero           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>out</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
initialize all numbers in a X(mat) object to 0 
<p>
<div class="fragment"><pre class="fragment"><a name="l00432"></a>00432                          {
<a name="l00433"></a>00433     <span class="keywordflow">if</span>(out){
<a name="l00434"></a>00434     memset(out-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, 0, <span class="keyword">sizeof</span>(T)*out-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*out-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l00435"></a>00435     }
<a name="l00436"></a>00436 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="917d70d3162af1387e34ab3bd76b14fd"></a><!-- doxytag: member="cmat.h::cmax" ref="917d70d3162af1387e34ab3bd76b14fd" args="(const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cmax           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find the maximum value of a X(mat) object 
<p>
<div class="fragment"><pre class="fragment"><a name="l00349"></a>00349                               {
<a name="l00350"></a>00350     <span class="keywordtype">double</span> max,min,sum;
<a name="l00351"></a>00351 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l00352"></a>00352 <span class="preprocessor"></span>    maxmincmp(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>,A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>,&amp;max,&amp;min,&amp;sum);
<a name="l00353"></a>00353 <span class="preprocessor">#else</span>
<a name="l00354"></a>00354 <span class="preprocessor"></span>    maxmindbl(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>,A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>,&amp;max,&amp;min,&amp;sum);
<a name="l00355"></a>00355 <span class="preprocessor">#endif</span>
<a name="l00356"></a>00356 <span class="preprocessor"></span>    <span class="keywordflow">return</span> max;
<a name="l00357"></a>00357 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="638c8d3934ebd94ceaf7394966ce86f7"></a><!-- doxytag: member="cmat.h::cmin" ref="638c8d3934ebd94ceaf7394966ce86f7" args="(const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cmin           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find the minimum value of a X(mat) object 
<p>
<div class="fragment"><pre class="fragment"><a name="l00362"></a>00362                               {
<a name="l00363"></a>00363     <span class="keywordtype">double</span> max,min,sum;
<a name="l00364"></a>00364 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l00365"></a>00365 <span class="preprocessor"></span>    maxmincmp(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>,A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>,&amp;max,&amp;min,&amp;sum);
<a name="l00366"></a>00366 <span class="preprocessor">#else</span>
<a name="l00367"></a>00367 <span class="preprocessor"></span>    maxmindbl(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>,A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>,&amp;max,&amp;min,&amp;sum);
<a name="l00368"></a>00368 <span class="preprocessor">#endif</span>
<a name="l00369"></a>00369 <span class="preprocessor"></span>    <span class="keywordflow">return</span> min;
<a name="l00370"></a>00370 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b53df31a0c2920c26bd6a58d1d76e967"></a><!-- doxytag: member="cmat.h::cnorm2" ref="b53df31a0c2920c26bd6a58d1d76e967" args="(const cmat *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cnorm2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the norm2 of A 
<p>
<div class="fragment"><pre class="fragment"><a name="l00441"></a>00441                                {
<a name="l00442"></a>00442     <span class="keywordtype">double</span> out=0;
<a name="l00443"></a>00443     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;nx; i++){
<a name="l00444"></a>00444     out+=(double)(A-&gt;p[i]*CONJ(A-&gt;p[i]));
<a name="l00445"></a>00445     }
<a name="l00446"></a>00446     <span class="keywordflow">return</span> out;
<a name="l00447"></a>00447 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="eacf579254ec4bb0b06a3902052cd471"></a><!-- doxytag: member="cmat.h::crandu" ref="eacf579254ec4bb0b06a3902052cd471" args="(cmat *A, const dcomplex mean, mt_state *rstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crandu           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmt__state.html">mt_state</a> *&nbsp;</td>
          <td class="paramname"> <em>rstat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill A with random uniform numbers between [0, 1]*max. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00452"></a>00452                                                          {
<a name="l00453"></a>00453     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00454"></a>00454     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l00455"></a>00455     A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]=RANDU(rstat)*max;
<a name="l00456"></a>00456     }
<a name="l00457"></a>00457 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b9966e372284993b73b92570066a731b"></a><!-- doxytag: member="cmat.h::crandn" ref="b9966e372284993b73b92570066a731b" args="(cmat *A, const dcomplex sigma, mt_state *rstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crandn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmt__state.html">mt_state</a> *&nbsp;</td>
          <td class="paramname"> <em>rstat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill A with random normal distribution numbers with standard deviation of sigma. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00462"></a>00462                                                            {
<a name="l00463"></a>00463     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00464"></a>00464     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l00465"></a>00465     A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]=RANDN(rstat)*sigma;
<a name="l00466"></a>00466     }
<a name="l00467"></a>00467 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c0f00cb8f71b144c21627d1da2dcfb3f"></a><!-- doxytag: member="cmat.h::cshow" ref="c0f00cb8f71b144c21627d1da2dcfb3f" args="(const cmat *A, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cshow           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
display a X(mat) matrix. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00472"></a>00472                                                       {
<a name="l00473"></a>00473     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00474"></a>00474     format2fn;
<a name="l00475"></a>00475     info(<span class="stringliteral">"show: %s"</span>,fn);
<a name="l00476"></a>00476     T (*restrict p)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>]=(T (*)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>])A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00477"></a>00477     <span class="keywordtype">long</span> colmax=10;
<a name="l00478"></a>00478     <span class="keywordtype">long</span> icol,i,j;
<a name="l00479"></a>00479     <span class="keywordflow">for</span>(icol=0; icol&lt;ceil((<span class="keywordtype">double</span>)A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>/(<span class="keywordtype">double</span>)colmax); icol++){
<a name="l00480"></a>00480     <span class="keywordtype">int</span> ncol=(icol+1)*colmax;
<a name="l00481"></a>00481     <span class="keywordflow">if</span>(ncol&gt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>) ncol=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00482"></a>00482     printf(<span class="stringliteral">"Cols %ld to %d\n"</span>, icol, ncol-1);
<a name="l00483"></a>00483     <span class="keywordflow">for</span>(j=0; j&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; j++){
<a name="l00484"></a>00484         <span class="keywordflow">for</span>(i=icol*colmax; i&lt;ncol; i++){
<a name="l00485"></a>00485         PRINT(p[i][j]);
<a name="l00486"></a>00486         }
<a name="l00487"></a>00487         printf(<span class="stringliteral">"\n"</span>);
<a name="l00488"></a>00488     }
<a name="l00489"></a>00489     }
<a name="l00490"></a>00490 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="204751357459432e00c5f5ee8d261f56"></a><!-- doxytag: member="cmat.h::cscale" ref="204751357459432e00c5f5ee8d261f56" args="(cmat *A, dcomplex w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>w</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
scale each element of A by w 
<p>
<div class="fragment"><pre class="fragment"><a name="l00495"></a>00495                              {
<a name="l00496"></a>00496     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00497"></a>00497     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l00498"></a>00498     A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*=w;
<a name="l00499"></a>00499     }
<a name="l00500"></a>00500 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cf3340d336a63035bc4aacd6fb03fd87"></a><!-- doxytag: member="cmat.h::csum" ref="cf3340d336a63035bc4aacd6fb03fd87" args="(const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex csum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create sum of all the elements in A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00505"></a>00505                          {
<a name="l00506"></a>00506     T v=0;
<a name="l00507"></a>00507     <span class="keywordflow">if</span>(A){
<a name="l00508"></a>00508     T *restrict p=A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;<span class="comment"></span>
<a name="l00509"></a>00509 <span class="comment">    /**</span>
<a name="l00510"></a>00510 <span class="comment">       Loops like this will only be vectorized with -ffast-math because</span>
<a name="l00511"></a>00511 <span class="comment">       different orders of accumulation give different results for floating</span>
<a name="l00512"></a>00512 <span class="comment">       point numbers.</span>
<a name="l00513"></a>00513 <span class="comment">    */</span>
<a name="l00514"></a>00514     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l00515"></a>00515         v+=p[i];
<a name="l00516"></a>00516     }
<a name="l00517"></a>00517     }
<a name="l00518"></a>00518     <span class="keywordflow">return</span> v;
<a name="l00519"></a>00519 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8b4328dbfb8ced02b3ef2f523d4e37f5"></a><!-- doxytag: member="cmat.h::cadd" ref="8b4328dbfb8ced02b3ef2f523d4e37f5" args="(cmat **B0, dcomplex bc, const cmat *A, const dcomplex ac)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cadd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>ac</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute B=bc*B+ac*A behavior changed on 2009-11-02. 
<p>
if A is NULL, don't do anything. <div class="fragment"><pre class="fragment"><a name="l00525"></a>00525                                                           {
<a name="l00526"></a>00526     <span class="keywordflow">if</span>(A){
<a name="l00527"></a>00527     <span class="keywordflow">if</span>(!*B0){
<a name="l00528"></a>00528         *B0=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>); bc=0;
<a name="l00529"></a>00529     }
<a name="l00530"></a>00530     X(mat) *B=*B0;
<a name="l00531"></a>00531     assert(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==B-&gt;nx &amp;&amp; A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a> == B-&gt;ny);
<a name="l00532"></a>00532     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l00533"></a>00533         B-&gt;p[i]=B-&gt;p[i]*bc+A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*ac;
<a name="l00534"></a>00534     }
<a name="l00535"></a>00535     }
<a name="l00536"></a>00536 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a5c02f882f7897bcafa6e65cf8a13c28"></a><!-- doxytag: member="cmat.h::cinn" ref="a5c02f882f7897bcafa6e65cf8a13c28" args="(const cmat *A, const cmat *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the inner product of A and B. 
<p>
(inner product) <div class="fragment"><pre class="fragment"><a name="l00542"></a>00542                                          {
<a name="l00543"></a>00543     assert(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> &amp;&amp; A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1 &amp;&amp; B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1);
<a name="l00544"></a>00544     T out=0;
<a name="l00545"></a>00545     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; i++){
<a name="l00546"></a>00546     out+=A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i];
<a name="l00547"></a>00547     }
<a name="l00548"></a>00548     <span class="keywordflow">if</span>(isnan(out)){
<a name="l00549"></a>00549     error(<span class="stringliteral">"NaN found\n"</span>);
<a name="l00550"></a>00550     }
<a name="l00551"></a>00551     <span class="keywordflow">return</span> out;
<a name="l00552"></a>00552 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8c64a290f550b8e43a6a100d216de986"></a><!-- doxytag: member="cmat.h::cwdot" ref="8c64a290f550b8e43a6a100d216de986" args="(const dcomplex *a, const cmat *w, const dcomplex *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cwdot           </td>
          <td>(</td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute weighted dot product a'*(w*b) 
<p>
<div class="fragment"><pre class="fragment"><a name="l00557"></a>00557                                                   {
<a name="l00558"></a>00558     PMAT(w,pw);
<a name="l00559"></a>00559     T res=0;
<a name="l00560"></a>00560     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;w-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; j++){
<a name="l00561"></a>00561     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;w-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; i++){
<a name="l00562"></a>00562         res+=pw[j][i]*a[i]*b[j];
<a name="l00563"></a>00563     }
<a name="l00564"></a>00564     }
<a name="l00565"></a>00565     <span class="keywordflow">return</span> res;
<a name="l00566"></a>00566 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c8a9b196602cd2b72cae912c49e4b504"></a><!-- doxytag: member="cmat.h::cwdot2" ref="c8a9b196602cd2b72cae912c49e4b504" args="(const dcomplex *a, const cmat *w, const dcomplex *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cwdot2           </td>
          <td>(</td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
special version of dwdot for just 2 element vectors. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00571"></a>00571                                                    {
<a name="l00572"></a>00572     assert(w-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==2 &amp;&amp; w-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==2);
<a name="l00573"></a>00573     T (*W)[2]=(T(*)[2])w-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00574"></a>00574     T res;
<a name="l00575"></a>00575     res=a[0]*(W[0][0]*b[0]+W[1][0]*b[1])
<a name="l00576"></a>00576     +a[1]*(W[0][1]*b[0]+W[1][1]*b[1]);
<a name="l00577"></a>00577     <span class="keywordflow">return</span> res;
<a name="l00578"></a>00578 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="94c0d4a66c6d83215f077cffcba34146"></a><!-- doxytag: member="cmat.h::cwdot3" ref="94c0d4a66c6d83215f077cffcba34146" args="(const dcomplex *a, const cmat *w, const dcomplex *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cwdot3           </td>
          <td>(</td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
special version of dwdot for just 3 element vectors. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00583"></a>00583                                                    {
<a name="l00584"></a>00584     assert(w-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==3 &amp;&amp; w-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==3);
<a name="l00585"></a>00585     T (*W)[3]=(T(*)[3])w-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00586"></a>00586     T res;
<a name="l00587"></a>00587     res=a[0]*(W[0][0]*b[0]+W[1][0]*b[1]+W[2][0]*b[2])
<a name="l00588"></a>00588     +a[1]*(W[0][1]*b[0]+W[1][1]*b[1]+W[2][1]*b[2])
<a name="l00589"></a>00589     +a[2]*(W[0][2]*b[0]+W[1][2]*b[1]+W[2][2]*b[2]);
<a name="l00590"></a>00590     <span class="keywordflow">return</span> res;
<a name="l00591"></a>00591 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2417a6c93f1245cf129586dce262aba3"></a><!-- doxytag: member="cmat.h::ccwm" ref="2417a6c93f1245cf129586dce262aba3" args="(cmat *B, const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccwm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute component wise multiply B=B. 
<p>
*A <div class="fragment"><pre class="fragment"><a name="l00596"></a>00596                                        {
<a name="l00597"></a>00597     assert(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> &amp;&amp; A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l00598"></a>00598     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l00599"></a>00599     B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]*=A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i];
<a name="l00600"></a>00600     }
<a name="l00601"></a>00601 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5012aabec0611cd938b01765c892f6b3"></a><!-- doxytag: member="cmat.h::cmulvec" ref="5012aabec0611cd938b01765c892f6b3" args="(dcomplex *restrict y, const cmat *restrict A, const dcomplex *restrict x, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmulvec           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *restrict&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *restrict&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
multiply a X(mat) matrix with a vector and accumulate to y: y+=A*x*alpha 
<p>
<div class="fragment"><pre class="fragment"><a name="l00608"></a>00608                                               {
<a name="l00609"></a>00609     assert(y &amp;&amp; x &amp;&amp; A);
<a name="l00610"></a>00610     T (*restrict Ap)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>]=(<span class="keywordtype">void</span>*)A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00611"></a>00611     <span class="keywordflow">if</span>(ABS(alpha-1)&gt;1.e-15){
<a name="l00612"></a>00612     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iy++){
<a name="l00613"></a>00613         T tmp=x[iy]*alpha;
<a name="l00614"></a>00614         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l00615"></a>00615         y[ix]+=Ap[iy][ix]*tmp;
<a name="l00616"></a>00616         }
<a name="l00617"></a>00617     }
<a name="l00618"></a>00618     }<span class="keywordflow">else</span>{
<a name="l00619"></a>00619     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iy++){
<a name="l00620"></a>00620         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l00621"></a>00621         y[ix]+=Ap[iy][ix]*x[iy];
<a name="l00622"></a>00622         }
<a name="l00623"></a>00623     }
<a name="l00624"></a>00624     }
<a name="l00625"></a>00625 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="da9977993e68f94425418b2c68d1789d"></a><!-- doxytag: member="cmat.h::cmm" ref="da9977993e68f94425418b2c68d1789d" args="(cmat **C0, const cmat *A, const cmat *B, const char trans[2], const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>trans</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute matrix product using blas dgemm with beta=1; C=beta*C+ alpha *trans(A)*trans(B); if C exist. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00632"></a>00632                                           {
<a name="l00633"></a>00633     <span class="keywordflow">if</span>(!A || !B) <span class="keywordflow">return</span>;
<a name="l00634"></a>00634     <span class="keywordtype">int</span> m,n,k,lda,ldb,ldc,k2;
<a name="l00635"></a>00635     <span class="keywordflow">if</span> (trans[0]==<span class="charliteral">'T'</span> || trans[0]==<span class="charliteral">'t'</span> || trans[0]==<span class="charliteral">'C'</span> || trans[0]==<span class="charliteral">'c'</span>){
<a name="l00636"></a>00636     m=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; k=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00637"></a>00637     }<span class="keywordflow">else</span>{
<a name="l00638"></a>00638     m=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; k=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00639"></a>00639     }
<a name="l00640"></a>00640     <span class="keywordflow">if</span> (trans[1]==<span class="charliteral">'T'</span> || trans[1]==<span class="charliteral">'t'</span>|| trans[0]==<span class="charliteral">'C'</span> || trans[0]==<span class="charliteral">'c'</span>){
<a name="l00641"></a>00641     n=B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00642"></a>00642     k2=B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00643"></a>00643     }<span class="keywordflow">else</span>{
<a name="l00644"></a>00644     n=B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00645"></a>00645     k2=B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00646"></a>00646     }
<a name="l00647"></a>00647     <span class="keywordflow">if</span>(k!=k2) error(<span class="stringliteral">"dmm: Matrix doesn't match\n"</span>);
<a name="l00648"></a>00648     <span class="keywordflow">if</span>(!*C0){
<a name="l00649"></a>00649     *C0=X(<span class="keyword">new</span>)(m,n); 
<a name="l00650"></a>00650     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(m!=(*C0)-&gt;nx || n!=(*C0)-&gt;ny){
<a name="l00651"></a>00651     error(<span class="stringliteral">"dmm: Matrix doesn't match\n"</span>);
<a name="l00652"></a>00652     }
<a name="l00653"></a>00653     X(mat) *C=*C0;
<a name="l00654"></a>00654     lda=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00655"></a>00655     ldb=B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00656"></a>00656     ldc=C-&gt;nx;
<a name="l00657"></a>00657     <span class="keyword">const</span> T beta=1;
<a name="l00658"></a>00658     Z(gemm)(&amp;trans[0], &amp;trans[1], &amp;m,&amp;n,&amp;k,&amp;alpha, 
<a name="l00659"></a>00659         A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, &amp;lda, B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, &amp;ldb, &amp;beta, C-&gt;p,&amp;ldc);
<a name="l00660"></a>00660 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="16f114b8d7e5173d9928b3dbb3f268a5"></a><!-- doxytag: member="cmat.h::cinvspd_inplace" ref="16f114b8d7e5173d9928b3dbb3f268a5" args="(cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cinvspd_inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace invert a small square SPD matrix using lapack dposv_, usually (A'*w*A). 
<p>
by solving Ax=I; copy x to A. dposv_ modifies A also. be careful <div class="fragment"><pre class="fragment"><a name="l00667"></a>00667                                  {
<a name="l00668"></a>00668     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00669"></a>00669     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>!=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>) error(<span class="stringliteral">"Must be a square matrix"</span>);
<a name="l00670"></a>00670     <span class="keywordtype">int</span> info=0, N=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00671"></a>00671     <span class="keyword">const</span> <span class="keywordtype">char</span> uplo=<span class="charliteral">'U'</span>;
<a name="l00672"></a>00672     <span class="comment">// B is identity matrix</span>
<a name="l00673"></a>00673     T *B=calloc(N*N,<span class="keyword">sizeof</span>(T));
<a name="l00674"></a>00674     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0;i&lt;N;i++)
<a name="l00675"></a>00675     B[i+i*N]=1;
<a name="l00676"></a>00676     Z(posv)(&amp;uplo, &amp;N, &amp;N, A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, &amp;N, B, &amp;N, &amp;info);
<a name="l00677"></a>00677     <span class="keywordflow">if</span>(info!=0){
<a name="l00678"></a>00678     X(write)(A,<span class="stringliteral">"posv"</span>);
<a name="l00679"></a>00679     error(<span class="stringliteral">"posv_ failed, info=%d. data saved to posv.\n"</span>,info);
<a name="l00680"></a>00680     }
<a name="l00681"></a>00681     memcpy(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, B, <span class="keyword">sizeof</span>(T)*N*N);
<a name="l00682"></a>00682     free(B);
<a name="l00683"></a>00683 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d2251ee97ee6cd88196f8fb03f4ac880"></a><!-- doxytag: member="cmat.h::cinvspd" ref="d2251ee97ee6cd88196f8fb03f4ac880" args="(const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cinvspd           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
out of place version of dinvspd_inplace 
<p>
<div class="fragment"><pre class="fragment"><a name="l00688"></a>00688                                   {
<a name="l00689"></a>00689     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l00690"></a>00690     X(mat) *out=NULL;
<a name="l00691"></a>00691     X(cp)(&amp;out, A);
<a name="l00692"></a>00692     X(invspd_inplace)(out);
<a name="l00693"></a>00693     <span class="keywordflow">return</span> out;
<a name="l00694"></a>00694 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="fe6927dc25de67288c63961b3340f69c"></a><!-- doxytag: member="cmat.h::cinv_inplace" ref="fe6927dc25de67288c63961b3340f69c" args="(cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cinv_inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inplace invert a general square matrix using lapack dgesv_ 
<p>
<div class="fragment"><pre class="fragment"><a name="l00699"></a>00699                              {
<a name="l00700"></a>00700     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l00701"></a>00701     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>!=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>) error(<span class="stringliteral">"Must be a square matrix"</span>);
<a name="l00702"></a>00702     <span class="keywordtype">int</span> info=0, N=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00703"></a>00703     T *B=calloc(N*N,<span class="keyword">sizeof</span>(T));
<a name="l00704"></a>00704     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;i++)
<a name="l00705"></a>00705     B[i+i*N]=1;
<a name="l00706"></a>00706     <span class="keywordtype">int</span> *ipiv=calloc(N, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00707"></a>00707     Z(gesv)(&amp;N, &amp;N, A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, &amp;N, ipiv, B, &amp;N, &amp;info);
<a name="l00708"></a>00708     <span class="keywordflow">if</span>(info!=0){
<a name="l00709"></a>00709     X(write)(A,<span class="stringliteral">"gesv"</span>);
<a name="l00710"></a>00710     error(<span class="stringliteral">"dgesv_ failed, info=%d. data saved to posv.\n"</span>,info);
<a name="l00711"></a>00711     }
<a name="l00712"></a>00712     memcpy(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, B, <span class="keyword">sizeof</span>(T)*N*N);
<a name="l00713"></a>00713     free(B);
<a name="l00714"></a>00714     free(ipiv);
<a name="l00715"></a>00715 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="aad7fd796188a37ff988b75286ff1906"></a><!-- doxytag: member="cmat.h::cinv" ref="aad7fd796188a37ff988b75286ff1906" args="(const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cinv           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
out of place version of dinv 
<p>
<div class="fragment"><pre class="fragment"><a name="l00720"></a>00720                                {
<a name="l00721"></a>00721     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l00722"></a>00722     X(mat) *out=NULL;
<a name="l00723"></a>00723     X(cp)(&amp;out, A);
<a name="l00724"></a>00724     X(inv_inplace)(out);
<a name="l00725"></a>00725     <span class="keywordflow">return</span> out;
<a name="l00726"></a>00726 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="63f8f6199cd41366c1fdd40717c6b3c3"></a><!-- doxytag: member="cmat.h::cmcc" ref="63f8f6199cd41366c1fdd40717c6b3c3" args="(const cmat *A, const cmat *wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cmcc           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute (A'*W*A); where diag(W)=wt 
<p>
<div class="fragment"><pre class="fragment"><a name="l00731"></a>00731                                                  {
<a name="l00732"></a>00732     assert(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==wt-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> &amp;&amp; wt-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1);
<a name="l00733"></a>00733     <span class="keywordtype">int</span> nmod=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00734"></a>00734     <span class="keywordtype">int</span> nsa2=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00735"></a>00735     X(mat) *ata=X(<span class="keyword">new</span>)(nmod, nmod);;
<a name="l00736"></a>00736     T (*ATA)[nmod]=(T(*)[nmod])ata-&gt;p; 
<a name="l00737"></a>00737     T (*Ap)[nsa2]=(T(*)[nsa2])A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00738"></a>00738     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> imod=0; imod&lt;nmod; imod++){
<a name="l00739"></a>00739     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jmod=imod; jmod&lt;nmod; jmod++){
<a name="l00740"></a>00740         T tmp=0;
<a name="l00741"></a>00741         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ik=0; ik&lt;nsa2; ik++){
<a name="l00742"></a>00742         tmp+=Ap[imod][ik]*Ap[jmod][ik]*wt-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[ik];
<a name="l00743"></a>00743         }
<a name="l00744"></a>00744         ATA[imod][jmod]=tmp;
<a name="l00745"></a>00745         <span class="keywordflow">if</span>(imod!=jmod)
<a name="l00746"></a>00746         ATA[jmod][imod]=ATA[imod][jmod];
<a name="l00747"></a>00747     }
<a name="l00748"></a>00748     }
<a name="l00749"></a>00749     <span class="keywordflow">return</span> ata;
<a name="l00750"></a>00750 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4a8db9c35e106c64a679ae96beb61b66"></a><!-- doxytag: member="cmat.h::cimcc" ref="4a8db9c35e106c64a679ae96beb61b66" args="(const cmat *A, const cmat *wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cimcc           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute inv(dmcc(A, wt)) 
<p>
<div class="fragment"><pre class="fragment"><a name="l00755"></a>00755                                                   {
<a name="l00756"></a>00756     X(mat) *mcc=X(mcc)(A,wt);
<a name="l00757"></a>00757     X(invspd_inplace)(mcc);
<a name="l00758"></a>00758     <span class="keywordflow">return</span> mcc;
<a name="l00759"></a>00759 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="364b9a68838d38ae710f3ade6e5e5820"></a><!-- doxytag: member="cmat.h::ctmcc" ref="364b9a68838d38ae710f3ade6e5e5820" args="(const cmat *A, const cmat *wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* ctmcc           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute (A*W*A'); where diag(W)=wt 
<p>
<div class="fragment"><pre class="fragment"><a name="l00764"></a>00764                                                   {
<a name="l00765"></a>00765     assert(A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==wt-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> &amp;&amp; wt-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1);
<a name="l00766"></a>00766     <span class="keywordtype">int</span> nmod=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00767"></a>00767     <span class="keywordtype">int</span> nsa2=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00768"></a>00768     X(mat) *ata=X(<span class="keyword">new</span>)(nmod, nmod);;
<a name="l00769"></a>00769     T (*ATA)[nmod]=(T(*)[nmod])ata-&gt;p; 
<a name="l00770"></a>00770     T (*Ap)[nmod]=(T(*)[nmod])A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00771"></a>00771     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> imod=0; imod&lt;nmod; imod++){
<a name="l00772"></a>00772     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jmod=imod; jmod&lt;nmod; jmod++){
<a name="l00773"></a>00773         T tmp=0;
<a name="l00774"></a>00774         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;nsa2; k++){
<a name="l00775"></a>00775         tmp+=Ap[k][imod]*Ap[k][jmod]*wt-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[k];
<a name="l00776"></a>00776         }
<a name="l00777"></a>00777         ATA[imod][jmod]=tmp;
<a name="l00778"></a>00778         <span class="keywordflow">if</span>(imod!=jmod)
<a name="l00779"></a>00779         ATA[jmod][imod]=ATA[imod][jmod];
<a name="l00780"></a>00780     }
<a name="l00781"></a>00781     }
<a name="l00782"></a>00782     <span class="keywordflow">return</span> ata;
<a name="l00783"></a>00783 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="862a7aa868fe53404dc29d060b5f044d"></a><!-- doxytag: member="cmat.h::cpinv" ref="862a7aa868fe53404dc29d060b5f044d" args="(const cmat *A, const cmat *wt, const csp *Wsp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cpinv           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>Wsp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the pseudo inverse of matrix A with weigthing of full matrix W or sparse matrix weighting Wsp. 
<p>
For full matrix, wt can be either W or diag (W) for diagonal weighting. B=inv(A'*W*A)*A'*W; <div class="fragment"><pre class="fragment"><a name="l00789"></a>00789                                                                     {
<a name="l00790"></a>00790     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l00791"></a>00791     X(mat) *AtW=NULL;
<a name="l00792"></a>00792     <span class="comment">//Compute AtW=A'*W</span>
<a name="l00793"></a>00793     <span class="keywordflow">if</span>(wt){
<a name="l00794"></a>00794     <span class="keywordflow">if</span>(Wsp){
<a name="l00795"></a>00795         error(<span class="stringliteral">"Both wt and Wsp are supplied. Not supported\n"</span>);
<a name="l00796"></a>00796     }
<a name="l00797"></a>00797     <span class="keywordflow">if</span>(wt-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==wt-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>){
<a name="l00798"></a>00798         X(mm)(&amp;AtW, A, wt, <span class="stringliteral">"tn"</span>, 1);
<a name="l00799"></a>00799     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(wt-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1){
<a name="l00800"></a>00800         AtW=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>,A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>);
<a name="l00801"></a>00801         PMAT(A,pA);
<a name="l00802"></a>00802         PMAT(AtW,pAtW);
<a name="l00803"></a>00803         T *w=wt-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00804"></a>00804         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iy++){
<a name="l00805"></a>00805         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0;ix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l00806"></a>00806             pAtW[ix][iy]=pA[iy][ix]*w[ix];
<a name="l00807"></a>00807         }
<a name="l00808"></a>00808         }
<a name="l00809"></a>00809     }<span class="keywordflow">else</span>{
<a name="l00810"></a>00810         error(<span class="stringliteral">"Invalid format\n"</span>);
<a name="l00811"></a>00811     }
<a name="l00812"></a>00812     }<span class="keywordflow">else</span>{
<a name="l00813"></a>00813     <span class="keywordflow">if</span>(Wsp){
<a name="l00814"></a>00814         X(mat)*At = X(trans)(A);
<a name="l00815"></a>00815         X(mulsp)(&amp;AtW, At, Wsp, 1);
<a name="l00816"></a>00816         X(free)(At);
<a name="l00817"></a>00817     }<span class="keywordflow">else</span>{
<a name="l00818"></a>00818         AtW=X(trans)(A);
<a name="l00819"></a>00819     }
<a name="l00820"></a>00820     }
<a name="l00821"></a>00821     <span class="comment">//Compute cc=A'*W*A</span>
<a name="l00822"></a>00822     X(mat) *cc=NULL;
<a name="l00823"></a>00823     X(mm) (&amp;cc, AtW, A, <span class="stringliteral">"nn"</span>, 1);
<a name="l00824"></a>00824     <span class="comment">//Compute inv of cc</span>
<a name="l00825"></a>00825     X(invspd_inplace)(cc);
<a name="l00826"></a>00826     X(mat) *out=NULL;
<a name="l00827"></a>00827     <span class="comment">//Compute (A'*W*A)*A'*W</span>
<a name="l00828"></a>00828     X(mm) (&amp;out, cc, AtW, <span class="stringliteral">"nn"</span>, 1);
<a name="l00829"></a>00829     X(free)(AtW);
<a name="l00830"></a>00830     X(free)(cc);
<a name="l00831"></a>00831     <span class="keywordflow">return</span> out;
<a name="l00832"></a>00832 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="77dbd9fcfc2e3185fc072bd6bec5e5e5"></a><!-- doxytag: member="cmat.h::cdiff" ref="77dbd9fcfc2e3185fc072bd6bec5e5e5" args="(const cmat *A, const cmat *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex cdiff           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the relative difference betwee two vectors. 
<p>
||A-B||/||A|| using norm2. for debugging purpose. <div class="fragment"><pre class="fragment"><a name="l00838"></a>00838                                            {
<a name="l00839"></a>00839     X(mat) *C=NULL;
<a name="l00840"></a>00840     X(cp)(&amp;C,A);
<a name="l00841"></a>00841     X(<span class="keyword">add</span>)(&amp;C,1,B,-1);
<a name="l00842"></a>00842     T d=X(norm2)(C)*2/(X(norm2)(C)+X(norm2)(B));
<a name="l00843"></a>00843     <span class="keywordflow">return</span> isnan(d)?0:d;
<a name="l00844"></a>00844 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f962ae5334dec4a29e6626bc0be8b19b"></a><!-- doxytag: member="cmat.h::ccircle" ref="f962ae5334dec4a29e6626bc0be8b19b" args="(cmat *A, double cx, double cy, double r, dcomplex val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccircle           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
a new gray pixel map generation based on bilinear influence functions used in mkw. 
<p>
creates slightly larger map. add an filled circle. cx,cy,r are in unit of pixels <div class="fragment"><pre class="fragment"><a name="l00851"></a>00851                                                                 {
<a name="l00852"></a>00852     <span class="keywordtype">int</span> nres=100;
<a name="l00853"></a>00853     <span class="keyword">const</span> <span class="keywordtype">double</span> res=1./(double)(nres);
<a name="l00854"></a>00854     <span class="keyword">const</span> <span class="keywordtype">double</span> res1=1./(double)(nres);
<a name="l00855"></a>00855     <span class="keyword">const</span> <span class="keywordtype">double</span> res2=res1*res1*4.;
<a name="l00856"></a>00856     <span class="keywordtype">double</span> resm=(double)(nres-1)/2.;
<a name="l00857"></a>00857     <span class="keywordtype">double</span> r2=r*r;
<a name="l00858"></a>00858     <span class="keywordtype">double</span> r2l=(r-1.5)*(r-1.5);
<a name="l00859"></a>00859     <span class="keywordtype">double</span> r2u=(r+2.5)*(r+2.5);
<a name="l00860"></a>00860     PMAT(A,As);
<a name="l00861"></a>00861     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iy++){
<a name="l00862"></a>00862     <span class="keywordtype">double</span> r2y=(iy-cy)*(iy-cy);
<a name="l00863"></a>00863     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l00864"></a>00864         <span class="keywordtype">double</span> r2r=(ix-cx)*(ix-cx)+r2y;
<a name="l00865"></a>00865         <span class="keywordflow">if</span>(r2r&lt;r2l) 
<a name="l00866"></a>00866             As[iy][ix]+=val;
<a name="l00867"></a>00867         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(r2r&lt;r2u){
<a name="l00868"></a>00868         <span class="keywordtype">double</span> tot=0.;
<a name="l00869"></a>00869         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jy=0; jy&lt;nres; jy++){
<a name="l00870"></a>00870             <span class="keywordtype">double</span> iiy=iy+(jy-resm)*2*res;
<a name="l00871"></a>00871             <span class="keywordtype">double</span> rr2y=(iiy-cy)*(iiy-cy);
<a name="l00872"></a>00872             <span class="keywordtype">double</span> wty=1.-fabs(iy-iiy);
<a name="l00873"></a>00873             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jx=0; jx&lt;nres; jx++){
<a name="l00874"></a>00874             <span class="keywordtype">double</span> iix=ix+(jx-resm)*2*res;
<a name="l00875"></a>00875             <span class="keywordtype">double</span> rr2r=(iix-cx)*(iix-cx)+rr2y;
<a name="l00876"></a>00876             <span class="keywordtype">double</span> wtx=1.-fabs(ix-iix);
<a name="l00877"></a>00877             <span class="keywordflow">if</span>(rr2r&lt;r2)
<a name="l00878"></a>00878                 tot+=res2*wty*wtx;
<a name="l00879"></a>00879             }
<a name="l00880"></a>00880         }
<a name="l00881"></a>00881         As[iy][ix]+=tot*val;
<a name="l00882"></a>00882         }
<a name="l00883"></a>00883     }
<a name="l00884"></a>00884     }
<a name="l00885"></a>00885 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="779b108bf238d17187f25d3eee0f3fe9"></a><!-- doxytag: member="cmat.h::ccircle_symbolic" ref="779b108bf238d17187f25d3eee0f3fe9" args="(cmat *A, double cx, double cy, double r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccircle_symbolic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
similar to X(circle). 
<p>
but don't actually compute the weights. just test the corners; <div class="fragment"><pre class="fragment"><a name="l00891"></a>00891                                                                   {
<a name="l00892"></a>00892     <span class="keywordtype">double</span> r2=r*r;
<a name="l00893"></a>00893     <span class="keywordtype">double</span> r2u=(r+2.5)*(r+2.5);
<a name="l00894"></a>00894     double (*As)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>]=(double(*)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>])A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00895"></a>00895     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;ny; iy++){
<a name="l00896"></a>00896     <span class="keywordtype">double</span> r2y=(iy-cy)*(iy-cy);
<a name="l00897"></a>00897     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l00898"></a>00898         <span class="keywordtype">double</span> r2r=(ix-cx)*(ix-cx)+r2y;
<a name="l00899"></a>00899         <span class="keywordflow">if</span>(r2r&lt;r2) 
<a name="l00900"></a>00900             As[iy][ix]=1;
<a name="l00901"></a>00901         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(r2r&lt;r2u){
<a name="l00902"></a>00902         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jy=-1; jy&lt;2; jy++){
<a name="l00903"></a>00903             <span class="keywordtype">double</span> iiy=iy+jy;
<a name="l00904"></a>00904             <span class="keywordtype">double</span> rr2y=(iiy-cy)*(iiy-cy);
<a name="l00905"></a>00905             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jx=-1; jx&lt;2; jx++){
<a name="l00906"></a>00906             <span class="keywordtype">double</span> iix=ix+jx;
<a name="l00907"></a>00907             <span class="keywordtype">double</span> rr2r=pow(iix-cx,2)+rr2y;
<a name="l00908"></a>00908             <span class="keywordflow">if</span>(rr2r&lt;r2){
<a name="l00909"></a>00909                 As[iy][ix]=1;
<a name="l00910"></a>00910                 <span class="keywordflow">goto</span> next;
<a name="l00911"></a>00911             }
<a name="l00912"></a>00912             }
<a name="l00913"></a>00913         }
<a name="l00914"></a>00914         }
<a name="l00915"></a>00915     next:
<a name="l00916"></a>00916         <span class="keywordflow">continue</span>;
<a name="l00917"></a>00917     }
<a name="l00918"></a>00918     }
<a name="l00919"></a>00919 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2e68e24dcc5d7ffd8d9b2c575e0830b9"></a><!-- doxytag: member="cmat.h::cfftshift" ref="2e68e24dcc5d7ffd8d9b2c575e0830b9" args="(cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cfftshift           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
shift frequency components by n/2 
<p>
<div class="fragment"><pre class="fragment"><a name="l00924"></a>00924                            {
<a name="l00925"></a>00925     <span class="keywordtype">size_t</span> i;
<a name="l00926"></a>00926     <span class="keyword">const</span> <span class="keywordtype">size_t</span> nx=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00927"></a>00927     <span class="keyword">const</span> <span class="keywordtype">size_t</span> ny=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00928"></a>00928     assert ((nx&amp;1)==0);
<a name="l00929"></a>00929     <span class="keyword">const</span> <span class="keywordtype">size_t</span> nx2=nx/2;
<a name="l00930"></a>00930     <span class="keyword">const</span> <span class="keywordtype">size_t</span> ny2=ny/2;
<a name="l00931"></a>00931     <span class="keyword">const</span> <span class="keywordtype">size_t</span> nx2d=nx2*<span class="keyword">sizeof</span>(T);
<a name="l00932"></a>00932     T *tmp=(T*)malloc(nx2d);
<a name="l00933"></a>00933     T *data=A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00934"></a>00934     <span class="keywordflow">if</span>(ny==1){
<a name="l00935"></a>00935     memcpy(tmp,data,nx2d);
<a name="l00936"></a>00936     memcpy(data,data+nx2,nx2d);
<a name="l00937"></a>00937     memcpy(data+nx2,tmp,nx2d);
<a name="l00938"></a>00938     }<span class="keywordflow">else</span>{
<a name="l00939"></a>00939     assert((ny&amp;1)==0);
<a name="l00940"></a>00940     <span class="keywordflow">for</span>(i=0; i&lt;ny2; i++){
<a name="l00941"></a>00941         memcpy(tmp,data+i*nx,nx2d);
<a name="l00942"></a>00942         memcpy(data+i*nx,data+(i+ny2)*nx+nx2, nx2d);
<a name="l00943"></a>00943         memcpy(data+(i+ny2)*nx+nx2,tmp, nx2d);
<a name="l00944"></a>00944         memcpy(tmp,data+i*nx+nx2,nx2d);
<a name="l00945"></a>00945         memcpy(data+i*nx+nx2,data+(i+ny2)*nx, nx2d); 
<a name="l00946"></a>00946         memcpy(data+(i+ny2)*nx,tmp, nx2d);
<a name="l00947"></a>00947     }
<a name="l00948"></a>00948     }
<a name="l00949"></a>00949     
<a name="l00950"></a>00950     free(tmp);
<a name="l00951"></a>00951 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="72f5647463dae0b89a5c8e444f580de0"></a><!-- doxytag: member="cmat.h::ccpcorner2center" ref="72f5647463dae0b89a5c8e444f580de0" args="(cmat *A, const cmat *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccpcorner2center           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reorder B and embed/crop into center of A 
<p>
<div class="fragment"><pre class="fragment">
   4 * * 3
   * * * *
   * * * *
   2 * * 1
   </pre></div> to <div class="fragment"><pre class="fragment">
   1 2 
   3 4
   </pre></div> <div class="fragment"><pre class="fragment"><a name="l00968"></a>00968                                                   {
<a name="l00969"></a>00969     <span class="keyword">const</span> <span class="keywordtype">size_t</span> nx=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00970"></a>00970     <span class="keyword">const</span> <span class="keywordtype">size_t</span> ny=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00971"></a>00971     T *Ap=A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00972"></a>00972     memset(Ap, 0, <span class="keyword">sizeof</span>(T)*nx*ny);
<a name="l00973"></a>00973     <span class="keyword">const</span> <span class="keywordtype">size_t</span> ninx=B-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l00974"></a>00974     <span class="keyword">const</span> <span class="keywordtype">size_t</span> niny=B-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l00975"></a>00975     <span class="keyword">const</span> T * Bp=B-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l00976"></a>00976     assert((nx&amp;1)==0 &amp;&amp; (ny&amp;1)==0 &amp;&amp; (ninx&amp;1)==0 &amp;&amp; (niny&amp;1)==0);
<a name="l00977"></a>00977 
<a name="l00978"></a>00978     <span class="keyword">const</span> <span class="keywordtype">int</span> ny2=(ny&lt;niny)?ny/2:niny/2;
<a name="l00979"></a>00979     <span class="keyword">const</span> <span class="keywordtype">int</span> nx2=(nx&lt;ninx)?nx/2:ninx/2;
<a name="l00980"></a>00980     <span class="keyword">const</span> <span class="keywordtype">int</span> xskip=nx/2-nx2;
<a name="l00981"></a>00981     <span class="keyword">const</span> <span class="keywordtype">int</span> yskip=ny/2-ny2;
<a name="l00982"></a>00982     T* Ap0=Ap+yskip*nx+xskip;
<a name="l00983"></a>00983     <span class="keyword">const</span> <span class="keywordtype">int</span> nx2d=nx2*<span class="keyword">sizeof</span>(T);
<a name="l00984"></a>00984     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;ny2; i++){
<a name="l00985"></a>00985     memcpy(Ap0+i*nx, Bp+(niny-ny2+i)*ninx+(ninx-nx2),nx2d); 
<a name="l00986"></a>00986     memcpy(Ap0+i*nx+nx2, Bp+(niny-ny2+i)*ninx, nx2d); 
<a name="l00987"></a>00987     memcpy(Ap0+(i+ny2)*nx, Bp+i*ninx+(ninx-nx2), nx2d); 
<a name="l00988"></a>00988     memcpy(Ap0+(i+ny2)*nx+nx2, Bp+i*ninx, nx2d); 
<a name="l00989"></a>00989     }
<a name="l00990"></a>00990 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="834e5e2f254160faa414569a60282089"></a><!-- doxytag: member="cmat.h::cshift" ref="834e5e2f254160faa414569a60282089" args="(cmat **B0, const cmat *A, int sx, int sy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cshift           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
cyclic shift A by nx and ny to B. 
<p>
<div class="fragment"><pre class="fragment">
   4   3     1   2 
      
   2   1 to  3   4
   </pre></div> <div class="fragment"><pre class="fragment"><a name="l01000"></a>01000                                                            {
<a name="l01001"></a>01001     <span class="keywordflow">if</span>(!*B0){
<a name="l01002"></a>01002     *B0=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l01003"></a>01003     }
<a name="l01004"></a>01004     X(mat) *B=*B0;
<a name="l01005"></a>01005 
<a name="l01006"></a>01006     <span class="keyword">const</span> <span class="keywordtype">int</span> nx=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; 
<a name="l01007"></a>01007     <span class="keyword">const</span> <span class="keywordtype">int</span> ny=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l01008"></a>01008     sx=sx%nx; <span class="keywordflow">if</span>(sx&lt;0) sx+=nx;
<a name="l01009"></a>01009     sy=sy%ny; <span class="keywordflow">if</span>(sy&lt;0) sy+=ny;
<a name="l01010"></a>01010     <span class="keywordflow">if</span>(sx!=0 || sy!=0){
<a name="l01011"></a>01011     <span class="keywordtype">int</span> dy=ny-sy;
<a name="l01012"></a>01012     <span class="keywordtype">int</span> dx=nx-sx;
<a name="l01013"></a>01013     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;sy; iy++){
<a name="l01014"></a>01014         memcpy(B-&gt;p+iy*nx, A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>+(dy+iy)*nx+dx, sx*<span class="keyword">sizeof</span>(T));<span class="comment">//3</span>
<a name="l01015"></a>01015         memcpy(B-&gt;p+iy*nx+sx, A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>+(dy+iy)*nx, dx*<span class="keyword">sizeof</span>(T));<span class="comment">//4</span>
<a name="l01016"></a>01016     }
<a name="l01017"></a>01017     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=sy; iy&lt;ny; iy++){
<a name="l01018"></a>01018         memcpy(B-&gt;p+iy*nx, A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>+(iy-sy)*nx+dx, sx*<span class="keyword">sizeof</span>(T));<span class="comment">//1</span>
<a name="l01019"></a>01019         memcpy(B-&gt;p+iy*nx+sx, A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>+(iy-sy)*nx, dx*<span class="keyword">sizeof</span>(T));<span class="comment">//2</span>
<a name="l01020"></a>01020     }
<a name="l01021"></a>01021     }<span class="keywordflow">else</span>{
<a name="l01022"></a>01022     memcpy(B-&gt;p, A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, <span class="keyword">sizeof</span>(T)*nx*ny);
<a name="l01023"></a>01023     }
<a name="l01024"></a>01024 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1cccdaf44daa400ae770f49e5dc91771"></a><!-- doxytag: member="cmat.h::crotvec" ref="1cccdaf44daa400ae770f49e5dc91771" args="(cmat *A, const double theta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crotvec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>theta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
rotate the vectors CCW. 
<p>
same as rotate coordinate theta CW. A(:,1) is x, A(:,2) is y. <div class="fragment"><pre class="fragment"><a name="l01031"></a>01031                                              {
<a name="l01032"></a>01032     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>!=2) error(<span class="stringliteral">"Wrong dimension\n"</span>);
<a name="l01033"></a>01033     <span class="keyword">const</span> <span class="keywordtype">double</span> ctheta=cos(theta);
<a name="l01034"></a>01034     <span class="keyword">const</span> <span class="keywordtype">double</span> stheta=sin(theta);
<a name="l01035"></a>01035     T (*Ap)[A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>]=(<span class="keywordtype">void</span>*)A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l01036"></a>01036     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;nx; i++){
<a name="l01037"></a>01037     T tmp=Ap[0][i]*ctheta-Ap[1][i]*stheta;
<a name="l01038"></a>01038     Ap[1][i]=Ap[0][i]*stheta+Ap[1][i]*ctheta;
<a name="l01039"></a>01039     Ap[0][i]=tmp;
<a name="l01040"></a>01040     }
<a name="l01041"></a>01041 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="39e013291512a0930b8e18ba7efd9071"></a><!-- doxytag: member="cmat.h::crotvecnn" ref="39e013291512a0930b8e18ba7efd9071" args="(cmat **B0, const cmat *A, double theta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crotvecnn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>theta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
rotate a 2x2 covariance matrix A by theta CCW (coordinate rotate -theta CCW) or from ra to xy coordinate. 
<p>
R*A*R'; <div class="fragment"><pre class="fragment"><a name="l01048"></a>01048                                                             {
<a name="l01049"></a>01049     assert(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==2 &amp;&amp; A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==2);
<a name="l01050"></a>01050     <span class="keywordflow">if</span>(!*B0) 
<a name="l01051"></a>01051     *B0=X(<span class="keyword">new</span>)(2,2);
<a name="l01052"></a>01052     X(mat) *B=*B0;
<a name="l01053"></a>01053     assert(B-&gt;nx==2 &amp;&amp; B-&gt;ny==2);
<a name="l01054"></a>01054     <span class="keyword">const</span> T ctheta=cos(theta);
<a name="l01055"></a>01055     <span class="keyword">const</span> T stheta=sin(theta);
<a name="l01056"></a>01056     T tmp[2][2];
<a name="l01057"></a>01057     <span class="keyword">const</span> T (*Ap)[2]=(<span class="keyword">const</span> T (*)[2])A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l01058"></a>01058     T (*Bp)[2]=(T (*)[2])B-&gt;p;
<a name="l01059"></a>01059     <span class="comment">//first apply left R</span>
<a name="l01060"></a>01060     tmp[0][0]=ctheta*Ap[0][0]-stheta*Ap[0][1];
<a name="l01061"></a>01061     tmp[1][0]=ctheta*Ap[1][0]-stheta*Ap[1][1];
<a name="l01062"></a>01062     tmp[0][1]=stheta*Ap[0][0]+ctheta*Ap[0][1];
<a name="l01063"></a>01063     tmp[1][1]=stheta*Ap[1][0]+ctheta*Ap[1][1];
<a name="l01064"></a>01064     <span class="comment">//then apply right R'</span>
<a name="l01065"></a>01065     
<a name="l01066"></a>01066     Bp[0][0]=ctheta*tmp[0][0]-stheta*tmp[1][0];
<a name="l01067"></a>01067     Bp[1][0]=stheta*tmp[0][0]+ctheta*tmp[1][0];
<a name="l01068"></a>01068     Bp[0][1]=ctheta*tmp[0][1]-stheta*tmp[1][1];
<a name="l01069"></a>01069     Bp[1][1]=stheta*tmp[0][1]+ctheta*tmp[1][1];
<a name="l01070"></a>01070 
<a name="l01071"></a>01071 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b7184001fed6ff87e17292e2092ee4b8"></a><!-- doxytag: member="cmat.h::cmulvec3" ref="b7184001fed6ff87e17292e2092ee4b8" args="(dcomplex *y, const cmat *A, const dcomplex *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmulvec3           </td>
          <td>(</td>
          <td class="paramtype">dcomplex *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
T matrix vector multiply optimized for just three values. 
<p>
y=A*x; <div class="fragment"><pre class="fragment"><a name="l01077"></a>01077                                                   {
<a name="l01078"></a>01078     assert(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==3 &amp;&amp; A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==3);
<a name="l01079"></a>01079     T(*Ap)[3]=(T(*)[3])A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l01080"></a>01080     <span class="comment">//calculate y=A*x for 3.</span>
<a name="l01081"></a>01081     y[0]=Ap[0][0]*x[0]+Ap[1][0]*x[1]+Ap[2][0]*x[2];
<a name="l01082"></a>01082     y[1]=Ap[0][1]*x[0]+Ap[1][1]*x[1]+Ap[2][1]*x[2];
<a name="l01083"></a>01083     y[2]=Ap[0][2]*x[0]+Ap[1][2]*x[1]+Ap[2][2]*x[2];
<a name="l01084"></a>01084 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="689ab6d12867fee7225a83f93f1a0a9d"></a><!-- doxytag: member="cmat.h::ccog" ref="689ab6d12867fee7225a83f93f1a0a9d" args="(double *grad, const cmat *i0, double offsetx, double offsety, double thres, double bkgrnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccog           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsetx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsety</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>thres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>bkgrnd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute thresholded center of gravity. 
<p>
The threshold is absolute value. bkgrnd is removed from i0 when computing cog. offset is the offset of the reference point (cog=0) from the physical center. all length are given in terms of pixel. <div class="fragment"><pre class="fragment"><a name="l01095"></a>01095                                                     {
<a name="l01096"></a>01096     <span class="keywordtype">double</span> sum=0,sumx=0,sumy=0;
<a name="l01097"></a>01097     <span class="keywordtype">double</span> iI;
<a name="l01098"></a>01098     PMAT(i0,pi0);
<a name="l01099"></a>01099     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;i0-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iy++){
<a name="l01100"></a>01100     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;i0-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l01101"></a>01101         iI=REAL(pi0[iy][ix])-bkgrnd;
<a name="l01102"></a>01102         <span class="keywordflow">if</span>(iI&gt;thres){
<a name="l01103"></a>01103         sum+=iI;
<a name="l01104"></a>01104         sumx+=iI*ix;
<a name="l01105"></a>01105         sumy+=iI*iy;
<a name="l01106"></a>01106         }
<a name="l01107"></a>01107     }
<a name="l01108"></a>01108     }
<a name="l01109"></a>01109     <span class="keywordflow">if</span>(fabs(sum)&gt;0){
<a name="l01110"></a>01110     grad[0]=sumx/sum-((double)(i0-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>-1)*0.5+offsetx);
<a name="l01111"></a>01111     grad[1]=sumy/sum-((double)(i0-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>-1)*0.5+offsety);
<a name="l01112"></a>01112     }<span class="keywordflow">else</span>{
<a name="l01113"></a>01113     grad[0]=0;
<a name="l01114"></a>01114     grad[1]=0;
<a name="l01115"></a>01115     }
<a name="l01116"></a>01116 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="47b5130ae904c436b75d6699abf025c6"></a><!-- doxytag: member="cmat.h::cshift2center" ref="47b5130ae904c436b75d6699abf025c6" args="(cmat *A, double offsetx, double offsety)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cshift2center           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsetx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offsety</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shift the image in A to center on physical center+[offsetx,offsety] using cog and fft. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01122"></a>01122                                                                {
<a name="l01123"></a>01123     <span class="keywordtype">double</span> grad[2];
<a name="l01124"></a>01124     <span class="keywordtype">double</span> Amax=X(max)(A);
<a name="l01125"></a>01125     X(cog)(grad,A,offsetx,offsety,Amax*0.1,Amax*0.2);
<a name="l01126"></a>01126     <span class="keywordflow">if</span>(fabs(grad[0])&gt;0.1 || fabs(grad[1])&gt;0.1){
<a name="l01127"></a>01127     <span class="comment">//info("Before shift, residual grad is %g %g\n",grad[0],grad[1]);</span>
<a name="l01128"></a>01128     <a class="code" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a> *B=<a class="code" href="cmat_8h.html#bb2b86ffc48237c760e652708aaf1415" title="Create a new T matrix object.">cnew</a>(A-&gt;nx,A-&gt;ny);
<a name="l01129"></a>01129     <a class="code" href="fft_8c.html#8b872386a7d070a175aa54dadcf2c68e" title="Create FFTW plans for 2d FFT transforms.">cfft2plan</a>(B,-1);
<a name="l01130"></a>01130     <a class="code" href="fft_8c.html#8b872386a7d070a175aa54dadcf2c68e" title="Create FFTW plans for 2d FFT transforms.">cfft2plan</a>(B,1);
<a name="l01131"></a>01131 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l01132"></a>01132 <span class="preprocessor"></span>    <a class="code" href="cmat_8h.html#db3c55ee96a9e7249403f738d251688c" title="copy the values from one X(mat) to another.">ccp</a>(&amp;B,A);
<a name="l01133"></a>01133 <span class="preprocessor">#else</span>
<a name="l01134"></a>01134 <span class="preprocessor"></span>    <a class="code" href="cmat__extra_8c.html#4ff6717c6a0f3919c71a2dc6fde5aae8" title="Copy a dmat into real part of cmat.">ccpd</a>(&amp;B,A);
<a name="l01135"></a>01135 <span class="preprocessor">#endif</span>
<a name="l01136"></a>01136 <span class="preprocessor"></span>    <span class="keywordtype">double</span> scale=1./(A-&gt;nx*A-&gt;ny);
<a name="l01137"></a>01137     <a class="code" href="cmat_8h.html#2e68e24dcc5d7ffd8d9b2c575e0830b9" title="shift frequency components by n/2">cfftshift</a>(B);
<a name="l01138"></a>01138     <a class="code" href="fft_8c.html#5e22d51b30da1c5c057cb5b8f121273d" title="Do 2d FFT transforms.">cfft2</a>(B,-1);
<a name="l01139"></a>01139     <a class="code" href="cmat__extra_8c.html#f912fcd3192a45180c528f075f1d0988" title="Tilt the otf to make the image shift.">ctilt</a>(B,-grad[0],-grad[1],0);
<a name="l01140"></a>01140     <a class="code" href="fft_8c.html#5e22d51b30da1c5c057cb5b8f121273d" title="Do 2d FFT transforms.">cfft2</a>(B,1);
<a name="l01141"></a>01141     <a class="code" href="cmat_8h.html#2e68e24dcc5d7ffd8d9b2c575e0830b9" title="shift frequency components by n/2">cfftshift</a>(B);
<a name="l01142"></a>01142     <a class="code" href="cmat_8h.html#204751357459432e00c5f5ee8d261f56" title="scale each element of A by w">cscale</a>(B,scale);
<a name="l01143"></a>01143 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l01144"></a>01144 <span class="preprocessor"></span>    <a class="code" href="cmat_8h.html#db3c55ee96a9e7249403f738d251688c" title="copy the values from one X(mat) to another.">ccp</a>(&amp;A,B);
<a name="l01145"></a>01145 <span class="preprocessor">#else</span>
<a name="l01146"></a>01146 <span class="preprocessor"></span>    <a class="code" href="cmat__extra_8c.html#b2baa26f7bd8861ab342eee97889522d" title="Copy real part of a cmat to dmat with optional scaling: A0=A0.">creal2d</a>(&amp;A,0,B,1);
<a name="l01147"></a>01147 <span class="preprocessor">#endif</span>
<a name="l01148"></a>01148 <span class="preprocessor"></span>    X(cog)(grad,A,offsetx,offsety,Amax*0.1,Amax*0.2);
<a name="l01149"></a>01149     <span class="comment">//info("After shift, residual grad is %g %g\n",grad[0],grad[1]);</span>
<a name="l01150"></a>01150     cfree(B);
<a name="l01151"></a>01151     }
<a name="l01152"></a>01152 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="66f7b38cee9d08a96f2b6e4b5c971fa4"></a><!-- doxytag: member="cmat.h::cclip" ref="66f7b38cee9d08a96f2b6e4b5c971fa4" args="(cmat *A, double min, double max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cclip           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Limit numbers in A to within [min, max]. 
<p>
used for DM clipping. <div class="fragment"><pre class="fragment"><a name="l01157"></a>01157                                               {
<a name="l01158"></a>01158     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> 0;
<a name="l01159"></a>01159     <span class="keywordflow">if</span>(isinf(min)==-1 &amp;&amp; isinf(max)==1) <span class="keywordflow">return</span> 0;
<a name="l01160"></a>01160     <span class="keywordflow">if</span>(max&lt;=min){
<a name="l01161"></a>01161     error(<span class="stringliteral">"upper light should be larger than lower limit\n"</span>);
<a name="l01162"></a>01162     }
<a name="l01163"></a>01163     T *restrict Ap=A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l01164"></a>01164     <span class="keywordtype">int</span> nclip=0;
<a name="l01165"></a>01165     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> *A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l01166"></a>01166     <span class="keywordflow">if</span>(REAL(Ap[i])&gt;max) {
<a name="l01167"></a>01167         Ap[i]=max;
<a name="l01168"></a>01168         nclip++;
<a name="l01169"></a>01169     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(REAL(Ap[i])&lt;min) {
<a name="l01170"></a>01170         Ap[i]=min;
<a name="l01171"></a>01171         nclip++;
<a name="l01172"></a>01172     }
<a name="l01173"></a>01173     }
<a name="l01174"></a>01174     <span class="keywordflow">return</span> nclip;
<a name="l01175"></a>01175 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="77fc55aade8619fa7fab51a2887f0535"></a><!-- doxytag: member="cmat.h::cgramschmidt" ref="77fc55aade8619fa7fab51a2887f0535" args="(cmat *Mod, double *amp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgramschmidt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>amp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
OrthNormalize column vector in Mod, with weighting from vector amp. 
<p>
&lt;Mod|wt|Mod&gt; is equal to sum(wt). 2010-07-21: Bug found: The result is not orthonormal. cause: nonvalid is not initialized to 0. <div class="fragment"><pre class="fragment"><a name="l01182"></a>01182                                              {
<a name="l01183"></a>01183     <span class="keyword">const</span> <span class="keywordtype">int</span> nmod=Mod-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l01184"></a>01184     <span class="keyword">const</span> <span class="keywordtype">long</span> nx=Mod-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l01185"></a>01185     T wtsum=(T)nx;
<a name="l01186"></a>01186     <span class="keywordflow">if</span>(amp){
<a name="l01187"></a>01187     wtsum=<a class="code" href="mathmisc_8c.html#2e90f5760bd508b1e45e25ca9f2c39f4" title="Compute the sum of double vector.">dblsum</a>(amp, nx);
<a name="l01188"></a>01188     }
<a name="l01189"></a>01189     <span class="keywordtype">int</span> nonvalid[nmod];
<a name="l01190"></a>01190     memset(nonvalid, 0, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)*nmod);
<a name="l01191"></a>01191     PMAT(Mod,pMod);
<a name="l01192"></a>01192     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> imod=0; imod&lt;nmod; imod++){
<a name="l01193"></a>01193     <span class="keywordflow">if</span>(imod&gt;0){<span class="comment">//orthogonalize</span>
<a name="l01194"></a>01194         T cross;
<a name="l01195"></a>01195         <span class="comment">//compute dot product.</span>
<a name="l01196"></a>01196         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jmod=0; jmod&lt;imod; jmod++){
<a name="l01197"></a>01197         <span class="keywordflow">if</span>(nonvalid[jmod]) <span class="keywordflow">continue</span>;
<a name="l01198"></a>01198         cross=-dot_do(pMod[imod],pMod[jmod],amp,nx)/wtsum;
<a name="l01199"></a>01199         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;nx; ix++){
<a name="l01200"></a>01200             pMod[imod][ix]+=cross*pMod[jmod][ix];
<a name="l01201"></a>01201         }
<a name="l01202"></a>01202         }
<a name="l01203"></a>01203     }
<a name="l01204"></a>01204     
<a name="l01205"></a>01205     T norm=SQRT(dot_do(pMod[imod],pMod[imod],amp,nx)/wtsum);
<a name="l01206"></a>01206     <span class="keywordflow">if</span>(ABS(norm)&gt;1.e-15){
<a name="l01207"></a>01207         norm=1./norm;
<a name="l01208"></a>01208         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;nx; ix++){
<a name="l01209"></a>01209         pMod[imod][ix]*=norm;
<a name="l01210"></a>01210         }
<a name="l01211"></a>01211     }<span class="keywordflow">else</span>{
<a name="l01212"></a>01212         nonvalid[imod]=1;
<a name="l01213"></a>01213         warning(<span class="stringliteral">"Column %d is not independent on other columns\n"</span>,imod);
<a name="l01214"></a>01214     }
<a name="l01215"></a>01215     }
<a name="l01216"></a>01216 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8d75289b919758fc3d3919b6026ba406"></a><!-- doxytag: member="cmat.h::cmuldiag" ref="8d75289b919758fc3d3919b6026ba406" args="(cmat *A, cmat *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmuldiag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A=A*B, where diag(B)=s. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01221"></a>01221                                      {
<a name="l01222"></a>01222     assert(A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==s-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> &amp;&amp; s-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1);
<a name="l01223"></a>01223     PMAT(A,pA);
<a name="l01224"></a>01224     <span class="keyword">const</span> T *ps=s-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l01225"></a>01225     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; iy++){
<a name="l01226"></a>01226     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>; ix++){
<a name="l01227"></a>01227         pA[iy][ix]*=ps[iy];
<a name="l01228"></a>01228     }
<a name="l01229"></a>01229     }
<a name="l01230"></a>01230 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dd74de8c67cb4e5f897778c0268d7744"></a><!-- doxytag: member="cmat.h::ccwpow" ref="dd74de8c67cb4e5f897778c0268d7744" args="(cmat *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccwpow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Raise all elements to power power. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01235"></a>01235                                      {
<a name="l01236"></a>01236     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l01237"></a>01237     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l01238"></a>01238     A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i]=Y(pow)(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i],power);
<a name="l01239"></a>01239     }
<a name="l01240"></a>01240 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ea36bb01ebe29d23687c2d6738080de1"></a><!-- doxytag: member="cmat.h::csvd" ref="ea36bb01ebe29d23687c2d6738080de1" args="(dmat **Sdiag, cmat **U, cmat **VT, const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csvd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>Sdiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
SVD of a general matrix. 
<p>
A=U*diag(S)*V'; diag(S) is returned. <div class="fragment"><pre class="fragment"><a name="l01247"></a>01247                                                                    {
<a name="l01248"></a>01248     <span class="keywordtype">char</span> jobuv=<span class="charliteral">'S'</span>;
<a name="l01249"></a>01249     <span class="keywordtype">int</span> M=(int)A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l01250"></a>01250     <span class="keywordtype">int</span> N=(<span class="keywordtype">int</span>)A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l01251"></a>01251     <span class="keywordflow">if</span>((Sdiag&amp;&amp;*Sdiag)||(U&amp;&amp;*U)||(VT&amp;&amp;*VT)){
<a name="l01252"></a>01252     warning(<span class="stringliteral">"Sdiag,U,VT should all be NULL. discard their value\n"</span>);
<a name="l01253"></a>01253     }
<a name="l01254"></a>01254     X(mat) *tmp=X(dup)(A);
<a name="l01255"></a>01255     <span class="keywordtype">int</span> nsvd=M&lt;N?M:N;
<a name="l01256"></a>01256     <a class="code" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> *s=<a class="code" href="dmat_8h.html#0d7497e2dbb79adb228de6bdde4a201e" title="Create a new T matrix object.">dnew</a>(nsvd,1);
<a name="l01257"></a>01257     X(mat) *u=X(<span class="keyword">new</span>)(M,nsvd);
<a name="l01258"></a>01258     X(mat) *vt=X(<span class="keyword">new</span>)(nsvd,N);
<a name="l01259"></a>01259     <span class="keywordtype">int</span> lwork=-1;
<a name="l01260"></a>01260     T work0[1];
<a name="l01261"></a>01261     <span class="keywordtype">int</span> info=0;
<a name="l01262"></a>01262 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l01263"></a>01263 <span class="preprocessor"></span>    <span class="keywordtype">double</span> *rwork=malloc(nsvd*5*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l01264"></a>01264     Z(gesvd)(&amp;jobuv,&amp;jobuv,&amp;M,&amp;N,tmp-&gt;p,&amp;M,s-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>,u-&gt;p,&amp;M,vt-&gt;p,&amp;nsvd,work0,&amp;lwork,rwork,&amp;info);
<a name="l01265"></a>01265 <span class="preprocessor">#else</span>
<a name="l01266"></a>01266 <span class="preprocessor"></span>    Z(gesvd)(&amp;jobuv,&amp;jobuv,&amp;M,&amp;N,tmp-&gt;p,&amp;M,s-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>,u-&gt;p,&amp;M,vt-&gt;p,&amp;nsvd,work0,&amp;lwork,&amp;info);
<a name="l01267"></a>01267 <span class="preprocessor">#endif</span>
<a name="l01268"></a>01268 <span class="preprocessor"></span>    lwork=(int)(work0[0]);
<a name="l01269"></a>01269     T *work1=malloc(<span class="keyword">sizeof</span>(T)*lwork);
<a name="l01270"></a>01270 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l01271"></a>01271 <span class="preprocessor"></span>    Z(gesvd)(&amp;jobuv,&amp;jobuv,&amp;M,&amp;N,tmp-&gt;p,&amp;M,s-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>,u-&gt;p,&amp;M,vt-&gt;p,&amp;nsvd,work1,&amp;lwork,rwork,&amp;info);
<a name="l01272"></a>01272 <span class="preprocessor">#else</span>
<a name="l01273"></a>01273 <span class="preprocessor"></span>    Z(gesvd)(&amp;jobuv,&amp;jobuv,&amp;M,&amp;N,tmp-&gt;p,&amp;M,s-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>,u-&gt;p,&amp;M,vt-&gt;p,&amp;nsvd,work1,&amp;lwork,&amp;info);
<a name="l01274"></a>01274 <span class="preprocessor">#endif</span>
<a name="l01275"></a>01275 <span class="preprocessor"></span>    free(work1);
<a name="l01276"></a>01276     <span class="keywordflow">if</span>(info){
<a name="l01277"></a>01277     <span class="keywordflow">if</span>(info&lt;0){
<a name="l01278"></a>01278         error(<span class="stringliteral">"The %d-th argument has an illegal value\n"</span>,info);
<a name="l01279"></a>01279     }<span class="keywordflow">else</span>{
<a name="l01280"></a>01280         error(<span class="stringliteral">"svd: dbdsqr doesn't converge. info is %d\n"</span>,info);
<a name="l01281"></a>01281     }
<a name="l01282"></a>01282     }
<a name="l01283"></a>01283     <span class="keywordflow">if</span>(Sdiag) *Sdiag=s; <span class="keywordflow">else</span> dfree(s);
<a name="l01284"></a>01284     <span class="keywordflow">if</span>(U) *U=u; <span class="keywordflow">else</span> X(free)(u);
<a name="l01285"></a>01285     <span class="keywordflow">if</span>(VT) *VT=vt; <span class="keywordflow">else</span> X(free)(vt);
<a name="l01286"></a>01286     X(free)(tmp);
<a name="l01287"></a>01287 <span class="preprocessor">#ifdef USE_COMPLEX</span>
<a name="l01288"></a>01288 <span class="preprocessor"></span>    free(rwork);
<a name="l01289"></a>01289 <span class="preprocessor">#endif</span>
<a name="l01290"></a>01290 <span class="preprocessor"></span>}
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e3d755e9c6714e93a155d710b421dd06"></a><!-- doxytag: member="cmat.h::csvd_pow" ref="e3d755e9c6714e93a155d710b421dd06" args="(cmat *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csvd_pow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
computes pow(A,power) using svd 
<p>
<div class="fragment"><pre class="fragment"><a name="l01295"></a>01295                                         {
<a name="l01296"></a>01296     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>!=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>){
<a name="l01297"></a>01297     warning(<span class="stringliteral">"dsvd_pow is only good for square arrays.\n"</span>);
<a name="l01298"></a>01298     }
<a name="l01299"></a>01299     <a class="code" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> *Sdiag=NULL;
<a name="l01300"></a>01300     X(mat) *U=NULL;
<a name="l01301"></a>01301     X(mat) *VT=NULL;
<a name="l01302"></a>01302     
<a name="l01303"></a>01303     X(svd)(&amp;Sdiag, &amp;U, &amp;VT, A);
<a name="l01304"></a>01304     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;Sdiag-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>; i++){
<a name="l01305"></a>01305     Sdiag-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i]=pow(Sdiag-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[i],power);
<a name="l01306"></a>01306     }
<a name="l01307"></a>01307     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy &lt;VT-&gt;ny; iy++){
<a name="l01308"></a>01308     T *p=VT-&gt;p+iy*VT-&gt;nx;
<a name="l01309"></a>01309     <span class="keywordflow">for</span> (<span class="keywordtype">long</span> ix=0; ix&lt;VT-&gt;nx; ix++){
<a name="l01310"></a>01310         p[ix]*=Sdiag-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[ix];
<a name="l01311"></a>01311     }
<a name="l01312"></a>01312     }
<a name="l01313"></a>01313     X(zero)(A);
<a name="l01314"></a>01314     X(mm)(&amp;A,U,VT,<span class="stringliteral">"nn"</span>,1);
<a name="l01315"></a>01315     X(free)(U);
<a name="l01316"></a>01316     X(free)(VT);
<a name="l01317"></a>01317     dfree(Sdiag);
<a name="l01318"></a>01318 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2289f10c6693d6253721db413bb7d61f"></a><!-- doxytag: member="cmat.h::caddI" ref="2289f10c6693d6253721db413bb7d61f" args="(cmat *A, dcomplex val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caddI           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add val to diagonal values of A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01323"></a>01323                               {
<a name="l01324"></a>01324     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l01325"></a>01325     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>!=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>)
<a name="l01326"></a>01326     warning(<span class="stringliteral">"daddI: A is not square\n"</span>);
<a name="l01327"></a>01327     <span class="keywordtype">long</span> M=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>&lt;A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>?A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>:A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l01328"></a>01328     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;M; i++){
<a name="l01329"></a>01329     A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[i+i*A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>]+=val;
<a name="l01330"></a>01330     } 
<a name="l01331"></a>01331 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d39a391d8bbcc4b7576df57820fc8eb7"></a><!-- doxytag: member="cmat.h::ctikcr" ref="d39a391d8bbcc4b7576df57820fc8eb7" args="(cmat *A, dcomplex thres)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ctikcr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>thres</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply tikhonov regularization to A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01336"></a>01336                                  {
<a name="l01337"></a>01337     <a class="code" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> *S=NULL;
<a name="l01338"></a>01338     X(svd)(&amp;S,NULL,NULL,A);
<a name="l01339"></a>01339     T val=S-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[0]*thres;
<a name="l01340"></a>01340     dfree(S);
<a name="l01341"></a>01341     X(addI)(A,val);
<a name="l01342"></a>01342 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d1f4093f58b84b2e125919868b103a88"></a><!-- doxytag: member="cmat.h::cmulsp" ref="d1f4093f58b84b2e125919868b103a88" args="(cmat **yout, const cmat *x, const csp *A, const dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmulsp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> **&nbsp;</td>
          <td class="paramname"> <em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
y=y+alpha*OP(x)*OP(A); implemented by transposing x,y index in sptmulmat implementation TESTED OK. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01349"></a>01349                                                                            {
<a name="l01350"></a>01350     <span class="keywordflow">if</span>(A&amp;&amp;x){
<a name="l01351"></a>01351     <span class="keywordtype">long</span> icol, ix;
<a name="l01352"></a>01352     <span class="keywordflow">if</span>(!*yout){
<a name="l01353"></a>01353         *yout=X(<span class="keyword">new</span>)(x-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>);
<a name="l01354"></a>01354     }
<a name="l01355"></a>01355     X(mat) *y=*yout;
<a name="l01356"></a>01356     assert(x-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==y-&gt;nx);
<a name="l01357"></a>01357     <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==1){
<a name="l01358"></a>01358         Y(sptmulvec)(y-&gt;p, A, x-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>, alpha);
<a name="l01359"></a>01359     }<span class="keywordflow">else</span>{
<a name="l01360"></a>01360         <span class="keywordtype">int</span> jcol;
<a name="l01361"></a>01361         PMAT(y,Y); PMAT(x,X);
<a name="l01362"></a>01362         <span class="keywordflow">if</span>(ABS(alpha-1.)&lt;1.e-100){
<a name="l01363"></a>01363         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l01364"></a>01364             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l01365"></a>01365             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;nx; jcol++){
<a name="l01366"></a>01366                 Y[icol][jcol]+=A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*X[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]][jcol];
<a name="l01367"></a>01367             }
<a name="l01368"></a>01368             }
<a name="l01369"></a>01369         }
<a name="l01370"></a>01370         }<span class="keywordflow">else</span>{
<a name="l01371"></a>01371         <span class="keywordflow">for</span>(icol=0; icol&lt;A-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>; icol++){
<a name="l01372"></a>01372             <span class="keywordflow">for</span>(ix=A-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[icol]; ix&lt;A-&gt;p[icol+1]; ix++){
<a name="l01373"></a>01373             <span class="keywordflow">for</span>(jcol=0; jcol&lt;y-&gt;nx; jcol++){
<a name="l01374"></a>01374                 Y[icol][jcol]+=alpha*A-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a>[ix]*X[A-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[ix]][jcol];
<a name="l01375"></a>01375             }
<a name="l01376"></a>01376             }
<a name="l01377"></a>01377         }
<a name="l01378"></a>01378         }
<a name="l01379"></a>01379     }
<a name="l01380"></a>01380     }
<a name="l01381"></a>01381 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="071ca1c1e64bb1ae6b9ca352a69a31b0"></a><!-- doxytag: member="cmat.h::clogspace" ref="071ca1c1e64bb1ae6b9ca352a69a31b0" args="(double emin, double emax, long n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* clogspace           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create log spaced vector. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01386"></a>01386                                                      {
<a name="l01387"></a>01387     X(mat)* out=X(<span class="keyword">new</span>)(n,1);
<a name="l01388"></a>01388     <span class="keywordtype">double</span> esep=(emax-emin)/(n-1);
<a name="l01389"></a>01389     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;n; i++){
<a name="l01390"></a>01390     <span class="keywordtype">double</span> ex=emin+esep*i;
<a name="l01391"></a>01391     out-&gt;p[i]=pow(10, ex);
<a name="l01392"></a>01392     }
<a name="l01393"></a>01393     <span class="keywordflow">return</span> out;
<a name="l01394"></a>01394 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5d357153670b6ce7f3eb9b7dee553912"></a><!-- doxytag: member="cmat.h::clinspace" ref="5d357153670b6ce7f3eb9b7dee553912" args="(double emin, double emax, long n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* clinspace           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>emax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create linearly spaced vector. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01399"></a>01399                                                    {
<a name="l01400"></a>01400     X(mat)* out=X(<span class="keyword">new</span>)(n,1);
<a name="l01401"></a>01401     <span class="keywordtype">double</span> sep=(max-min)/(n-1);
<a name="l01402"></a>01402     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;n; i++){
<a name="l01403"></a>01403     out-&gt;p[i]=min+sep*i;
<a name="l01404"></a>01404     }
<a name="l01405"></a>01405     <span class="keywordflow">return</span> out;
<a name="l01406"></a>01406 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e546d587249af8bbb4c09a03ff2cb9fd"></a><!-- doxytag: member="cmat.h::cinterp1" ref="e546d587249af8bbb4c09a03ff2cb9fd" args="(dmat *xin, dmat *yin, dmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cinterp1           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>yin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpolate using linear interp. 
<p>
xin is the coordinate of yin. xnew is the coordinate of the output. <div class="fragment"><pre class="fragment"><a name="l01412"></a>01412                                                     {
<a name="l01413"></a>01413     <span class="keywordtype">long</span> nmax=xin-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l01414"></a>01414     <span class="keywordtype">long</span> nmax1=nmax-1;
<a name="l01415"></a>01415     <span class="keywordtype">double</span> xminl=(xin-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[0]);
<a name="l01416"></a>01416     <span class="keywordtype">double</span> xmaxl=(xin-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[nmax-1]);
<a name="l01417"></a>01417     <span class="keywordtype">double</span> xsep=(xmaxl-xminl)/(<span class="keywordtype">double</span>)(nmax1);
<a name="l01418"></a>01418     <span class="keywordtype">double</span> xsep1=1./xsep;
<a name="l01419"></a>01419     <span class="keywordflow">if</span>(fabs(xsep+xminl-xin-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[1])&gt;1.e-3){
<a name="l01420"></a>01420     error(<span class="stringliteral">"Xin is not linearly spaced\n"</span>);
<a name="l01421"></a>01421     }
<a name="l01422"></a>01422     <span class="keywordflow">if</span>(xin-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>!=1 || xnew-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>!=1){
<a name="l01423"></a>01423     error(<span class="stringliteral">"Either xin or xnew is in wrong format\n"</span>);
<a name="l01424"></a>01424     }
<a name="l01425"></a>01425 
<a name="l01426"></a>01426     X(mat) *ynew=X(<span class="keyword">new</span>)(xnew-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, xnew-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l01427"></a>01427     PMAT(yin, pyin);
<a name="l01428"></a>01428     PMAT(ynew, pynew);
<a name="l01429"></a>01429     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;ynew-&gt;ny; iy++){
<a name="l01430"></a>01430     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;ynew-&gt;nx; ix++){
<a name="l01431"></a>01431         <span class="keywordtype">double</span> xx=((xnew-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[ix])-xminl)*xsep1;
<a name="l01432"></a>01432         <span class="keywordflow">if</span>(xx&lt;0 || xx&gt;nmax1){
<a name="l01433"></a>01433         pynew[iy][ix]=0;
<a name="l01434"></a>01434         }<span class="keywordflow">else</span>{
<a name="l01435"></a>01435         <span class="keywordtype">long</span> xxm=ifloor(xx);
<a name="l01436"></a>01436         <span class="keywordtype">double</span> xxw=xx-xxm;
<a name="l01437"></a>01437         pynew[iy][ix]=xxw*pyin[iy][xxm+1]+(1.-xxw)*pyin[iy][xxm];
<a name="l01438"></a>01438         }
<a name="l01439"></a>01439     }
<a name="l01440"></a>01440     }
<a name="l01441"></a>01441     <span class="keywordflow">return</span> ynew;
<a name="l01442"></a>01442 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0fcc7887067339b812f96bc684f47f4c"></a><!-- doxytag: member="cmat.h::cinterp1log" ref="0fcc7887067339b812f96bc684f47f4c" args="(dmat *xin, dmat *yin, dmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cinterp1log           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>yin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interpolate using log(xin) and log(xnew) xin is the coordinate of yin. 
<p>
xnew is the coordinate of the output. <div class="fragment"><pre class="fragment"><a name="l01448"></a>01448                                                        {
<a name="l01449"></a>01449     <span class="keywordtype">long</span> nmax=xin-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>;
<a name="l01450"></a>01450     <span class="keywordtype">long</span> nmax1=nmax-1;
<a name="l01451"></a>01451     <span class="keywordtype">double</span> xminl=log10(xin-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[0]);
<a name="l01452"></a>01452     <span class="keywordtype">double</span> xmaxl=log10(xin-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[nmax-1]);
<a name="l01453"></a>01453     <span class="keywordtype">double</span> xsep=(xmaxl-xminl)/(<span class="keywordtype">double</span>)(nmax1);
<a name="l01454"></a>01454     <span class="keywordtype">double</span> xsep1=1./xsep;
<a name="l01455"></a>01455     <span class="keywordflow">if</span>(fabs(xsep+xminl-log10(xin-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[1]))&gt;1.e-3){
<a name="l01456"></a>01456     info(<span class="stringliteral">"xsep=%g, nmax1=%ld, xminl=%g, xmaxl=%g\n"</span>,xsep, nmax1, xminl, xmaxl);
<a name="l01457"></a>01457     error(<span class="stringliteral">"Xin is not logrithmicly spaced\n"</span>);
<a name="l01458"></a>01458     }
<a name="l01459"></a>01459     <span class="keywordflow">if</span>(xin-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>!=1 || xnew-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>!=1){
<a name="l01460"></a>01460     error(<span class="stringliteral">"Either xin or xnew is in wrong format\n"</span>);
<a name="l01461"></a>01461     }
<a name="l01462"></a>01462 
<a name="l01463"></a>01463     X(mat) *ynew=X(<span class="keyword">new</span>)(xnew-&gt;<a class="code" href="structdmat.html#983086836d817046db8588de2873dd36" title="number of rows">nx</a>, xnew-&gt;<a class="code" href="structdmat.html#690854282ff0f4fbd5d734d6c377c9b2" title="number of columns">ny</a>);
<a name="l01464"></a>01464     PMAT(yin, pyin);
<a name="l01465"></a>01465     PMAT(ynew, pynew);
<a name="l01466"></a>01466     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;ynew-&gt;ny; iy++){
<a name="l01467"></a>01467     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;ynew-&gt;nx; ix++){
<a name="l01468"></a>01468         <span class="keywordtype">double</span> xx=(log10(xnew-&gt;<a class="code" href="structdmat.html#653d0780e19f58a3f74ead17630d9dcb" title="the pointer to allocated memory.">p</a>[ix])-xminl)*xsep1;
<a name="l01469"></a>01469         <span class="keywordflow">if</span>(xx&lt;0 || xx&gt;nmax1){
<a name="l01470"></a>01470         pynew[iy][ix]=0;
<a name="l01471"></a>01471         }<span class="keywordflow">else</span>{
<a name="l01472"></a>01472         <span class="keywordtype">long</span> xxm=ifloor(xx);
<a name="l01473"></a>01473         <span class="keywordtype">double</span> xxw=xx-xxm;
<a name="l01474"></a>01474         pynew[iy][ix]=xxw*pyin[iy][xxm+1]+(1.-xxw)*pyin[iy][xxm];
<a name="l01475"></a>01475         }
<a name="l01476"></a>01476     }
<a name="l01477"></a>01477     }
<a name="l01478"></a>01478     <span class="keywordflow">return</span> ynew;
<a name="l01479"></a>01479 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="10d49d59390d39b5398979a55f90441a"></a><!-- doxytag: member="cmat.h::chistfill" ref="10d49d59390d39b5398979a55f90441a" args="(dmat **out, const cmat *A, double center, double spacing, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chistfill           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdmat.html">dmat</a> **&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For each entry in A, call repeatly to collect its histogram, centered at center, spaced by spacing, for n bins in total. 
<p>
center if at bin n/2. <div class="fragment"><pre class="fragment"><a name="l01559"></a>01559                                               {
<a name="l01560"></a>01560     <span class="keywordflow">if</span>(!A || !A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>) <span class="keywordflow">return</span>;
<a name="l01561"></a>01561     <span class="keywordtype">int</span> nn=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l01562"></a>01562     <span class="keywordflow">if</span>(!*out){
<a name="l01563"></a>01563     *out=<a class="code" href="dmat_8h.html#0d7497e2dbb79adb228de6bdde4a201e" title="Create a new T matrix object.">dnew</a>(n,nn);
<a name="l01564"></a>01564     }
<a name="l01565"></a>01565     double (*restrict Op)[n]=(<span class="keywordtype">void</span>*)(*out)-&gt;p;
<a name="l01566"></a>01566     <span class="keyword">const</span> T *restrict Ap=A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l01567"></a>01567     <span class="keyword">const</span> <span class="keywordtype">double</span> spacingi=1./spacing;
<a name="l01568"></a>01568     <span class="keyword">const</span> <span class="keywordtype">int</span> noff=n/2;
<a name="l01569"></a>01569     <span class="keyword">const</span> <span class="keywordtype">int</span> n1=n-1;
<a name="l01570"></a>01570     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;A-&gt;nx*A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; i++){
<a name="l01571"></a>01571     <span class="keywordtype">int</span> ind=(int)round(REAL(Ap[i]-center)*spacingi)+noff;
<a name="l01572"></a>01572     <span class="keywordflow">if</span>(ind&lt;0) ind=0;
<a name="l01573"></a>01573     <span class="keywordflow">if</span>(ind&gt;n1) ind=n1;
<a name="l01574"></a>01574     Op[i][ind]++;
<a name="l01575"></a>01575     }
<a name="l01576"></a>01576 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1f6ecbeecb56f05d855f3e1f21342dc2"></a><!-- doxytag: member="cmat.h::cspline_prep" ref="1f6ecbeecb56f05d855f3e1f21342dc2" args="(cmat *x, cmat *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cspline_prep           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
1D Cubic spline interpolation preparation. 
<p>
if x has only 1 column: x is the coordinate. y is the function value. if x has two columns: first column is the coordinate, y is null.<p>
It is upto the user to make sure that the coordinate is increasingly ordered and evenly spaced .<p>
If the values of a function <img class="formulaInl" alt="$f(x)$" src="form_3.png"> and its derivative are know at x=0, and x=1 (normalized coordinate), then the function can be interpolated on the interval [0,1] using a third degree polynomial. This is called cubic interpolation. The formula of this polynomial can be easily derived.<p>
A third degree polynomial and its derivative: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x)=ax^3+bx^2+cx+d \]" src="form_4.png">
<p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x)=3ax^3+2bx+c \]" src="form_5.png">
<p>
 The coefficients can be derived from the value and derivatives: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} a&amp;=&amp;2f(0)-2f(1)+f^\prime (0)+f^\prime(1)\\ b&amp;=&amp;-3f(0)+3f(1)-2f^\prime(0)-f^\prime(0)\\ c&amp;=&amp;f^\prime(0)\\ d&amp;=&amp;f(0)\\ \end{eqnarray*}" src="form_6.png">
<p>
 the derivatives can be computed as <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} f^\prime(0)&amp;=&amp;\frac{f(1)-f(-1)}{2}\\ f^\prime(1)&amp;=&amp;\frac{f(2)-f(0)}{2}\\ \end{eqnarray*}" src="form_7.png">
<p>
 so we have the formula <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} a&amp;=&amp;-0.5 f(-1) + 1.5 f(0) - 1.5 f(1) + 0.5 f(2)\\ b&amp;=&amp; f(-1) - 2.5 f(0) + 2 f(1) - 0.5 f(2)\\ c&amp;=&amp;-0.5 f(-1) + 0.5 f(1) \\ d&amp;=&amp; f(0) \\ \end{eqnarray*}" src="form_8.png">
<p>
<p>
for the boundary pints, replace <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(-1))/2\]" src="form_9.png">
<p>
 by <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(0))\]" src="form_10.png">
<p>
 Otehr type of boundaries are handled in the same way.<p>
see <a href="http://www.paulinternet.nl/?page=bicubicx">http://www.paulinternet.nl/?page=bicubicx</a> <div class="fragment"><pre class="fragment"><a name="l01624"></a>01624                                             {
<a name="l01625"></a>01625     T *px,*py;
<a name="l01626"></a>01626     <span class="keyword">const</span> <span class="keywordtype">long</span> nx=x-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l01627"></a>01627     px=x-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l01628"></a>01628     <span class="keywordflow">switch</span>(x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>){
<a name="l01629"></a>01629     <span class="keywordflow">case</span> 1:
<a name="l01630"></a>01630     py=y-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l01631"></a>01631     <span class="keywordflow">break</span>;
<a name="l01632"></a>01632     <span class="keywordflow">case</span> 2:
<a name="l01633"></a>01633     assert(y==NULL);
<a name="l01634"></a>01634     py=x-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>+nx;
<a name="l01635"></a>01635     <span class="keywordflow">break</span>;
<a name="l01636"></a>01636     <span class="keywordflow">default</span>:
<a name="l01637"></a>01637     py=NULL;
<a name="l01638"></a>01638     error(<span class="stringliteral">"Invalid input\n"</span>);
<a name="l01639"></a>01639     }
<a name="l01640"></a>01640     X(mat) *coeff=X(<span class="keyword">new</span>)(4,nx);
<a name="l01641"></a>01641     T xsep=(px[nx-1]-px[0])/(nx-1);
<a name="l01642"></a>01642     <span class="keywordtype">double</span> thres=ABS(xsep)*1.e-5;
<a name="l01643"></a>01643   
<a name="l01644"></a>01644     PMAT(coeff,pc);
<a name="l01645"></a>01645     T ypriv,ynext;
<a name="l01646"></a>01646     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;nx-1; ix++){
<a name="l01647"></a>01647     <span class="keywordflow">if</span>(ABS(px[ix+1]-px[ix]-xsep)&gt;thres){
<a name="l01648"></a>01648         error(<span class="stringliteral">"The coordinate is not evenly spaced\n"</span>);
<a name="l01649"></a>01649     }
<a name="l01650"></a>01650     <span class="keywordflow">if</span>(UNLIKELY(ix==0)){
<a name="l01651"></a>01651         ypriv=2*py[ix]-py[ix+1];
<a name="l01652"></a>01652     }<span class="keywordflow">else</span>{
<a name="l01653"></a>01653         ypriv=py[ix-1];
<a name="l01654"></a>01654     }
<a name="l01655"></a>01655     <span class="keywordflow">if</span>(UNLIKELY(ix==nx-2)){
<a name="l01656"></a>01656         ynext=2*py[ix+1]-py[ix];
<a name="l01657"></a>01657     }<span class="keywordflow">else</span>{
<a name="l01658"></a>01658         ynext=py[ix+2];
<a name="l01659"></a>01659     }
<a name="l01660"></a>01660     pc[ix][0]=-0.5*ypriv+1.5*py[ix]-1.5*py[ix+1]+0.5*ynext;<span class="comment">//a</span>
<a name="l01661"></a>01661     pc[ix][1]=     ypriv-2.5*py[ix]+2.0*py[ix+1]-0.5*ynext;<span class="comment">//b</span>
<a name="l01662"></a>01662     pc[ix][2]=-0.5*ypriv           +0.5*py[ix+1];<span class="comment">//c</span>
<a name="l01663"></a>01663     pc[ix][3]=               py[ix] ;<span class="comment">//d</span>
<a name="l01664"></a>01664     <span class="comment">/*</span>
<a name="l01665"></a>01665 <span class="comment">      For any point within this bin, with normalized coordinate t (0&lt;t&lt;1);</span>
<a name="l01666"></a>01666 <span class="comment">      y(t)=a*pow(t,3)+b*pow(t,2)+c*t+d;</span>
<a name="l01667"></a>01667 <span class="comment">    */</span>
<a name="l01668"></a>01668     }
<a name="l01669"></a>01669     <span class="keywordflow">return</span> coeff;
<a name="l01670"></a>01670 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="105e0e17a7f377c30b63ff9bc5f002e1"></a><!-- doxytag: member="cmat.h::cspline_eval" ref="105e0e17a7f377c30b63ff9bc5f002e1" args="(cmat *coeff, cmat *x, cmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cspline_eval           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evluate the cubic spline represented by nx5 matrix coeff, at location array xnew. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01674"></a>01674                                                               {
<a name="l01675"></a>01675     assert(coeff-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==4);
<a name="l01676"></a>01676     <span class="keyword">const</span> <span class="keywordtype">long</span> nx=coeff-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l01677"></a>01677     PMAT(coeff,pc);
<a name="l01678"></a>01678     T xmin=x-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[0];
<a name="l01679"></a>01679     T xsep1=(double)(nx-1)/(x-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[nx-1]-xmin);
<a name="l01680"></a>01680     X(mat) *out=X(<span class="keyword">new</span>)(xnew-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, xnew-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l01681"></a>01681     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;xnew-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*xnew-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; ix++){
<a name="l01682"></a>01682     <span class="keywordtype">double</span> xn=REAL((xnew-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[ix]-xmin)*xsep1);
<a name="l01683"></a>01683     <span class="keywordtype">long</span> xnf=floor(xn);
<a name="l01684"></a>01684     <span class="keywordflow">if</span>(xnf&lt;0) xnf=0;
<a name="l01685"></a>01685     <span class="keywordflow">if</span>(xnf&gt;nx-2) xnf=nx-2;
<a name="l01686"></a>01686     xn=xn-xnf;
<a name="l01687"></a>01687     T xn2=xn*xn;
<a name="l01688"></a>01688     T xn3=xn2*xn;
<a name="l01689"></a>01689     out-&gt;p[ix]=pc[xnf][0]*xn3+pc[xnf][1]*xn2+pc[xnf][2]*xn+pc[xnf][3];
<a name="l01690"></a>01690     }
<a name="l01691"></a>01691     <span class="keywordflow">return</span> out;
<a name="l01692"></a>01692 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6dc13156073384a5722fcf7fd5f0833a"></a><!-- doxytag: member="cmat.h::cspline" ref="6dc13156073384a5722fcf7fd5f0833a" args="(cmat *x, cmat *y, cmat *xnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cspline           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Do 1D cubic spline all at once by calling X(spline_prep) and X(spline_evald). 
<p>
<div class="fragment"><pre class="fragment"><a name="l01696"></a>01696                                                    {
<a name="l01697"></a>01697     X(mat) *coeff=X(spline_prep)(x,y);
<a name="l01698"></a>01698     X(mat) *out=X(spline_eval)(coeff,x,xnew);
<a name="l01699"></a>01699     X(free)(coeff);
<a name="l01700"></a>01700     <span class="keywordflow">return</span> out;
<a name="l01701"></a>01701 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6d44ad8fe4da7595e7b54ac85015cfaa"></a><!-- doxytag: member="cmat.h::cbspline_prep" ref="6d44ad8fe4da7595e7b54ac85015cfaa" args="(cmat *x, cmat *y, cmat *z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* cbspline_prep           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
2D cubic spline interpolation preparation. 
<p>
x is the x coordinate vector of the 2-d grid. y is the y coordinate vector of the 2-d grid. z is defined on the 2-d grid. It is upto the user to make sure that the coordinate is increasingly ordered and evenly spaced .<p>
The boundaries are handled in the same way is X(spline). i.e. replace <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(-1))/2\]" src="form_9.png">
<p>
 by <p class="formulaDsp">
<img class="formulaDsp" alt="\[f^\prime(0)=(f(1)-f(0))\]" src="form_10.png">
<p>
 Otehr type of boundaries are handled in the same way. <div class="fragment"><pre class="fragment"><a name="l01714"></a>01714                                                        {
<a name="l01715"></a>01715     <span class="keyword">const</span> <span class="keywordtype">long</span> nx=x-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l01716"></a>01716     <span class="keyword">const</span> <span class="keywordtype">long</span> ny=y-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l01717"></a>01717     assert(x-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==1 &amp;&amp; y-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a> ==1 &amp;&amp; z-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>==nx &amp;&amp; z-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>==ny);
<a name="l01718"></a>01718     X(cell)*coeff=X(cellnew)(nx,ny);
<a name="l01719"></a>01719     PCELL(coeff,pc);
<a name="l01720"></a>01720   
<a name="l01721"></a>01721     PMAT(z,p);
<a name="l01722"></a>01722     T p00,p01,p02,p03,p10,p11,p12,p13,p20,p21,p22,p23,p30,p31,p32,p33;
<a name="l01723"></a>01723     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;ny-1; iy++){
<a name="l01724"></a>01724     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;nx-1; ix++){
<a name="l01725"></a>01725         <span class="keywordflow">if</span>(iy==0){
<a name="l01726"></a>01726         <span class="keywordflow">if</span>(ix==0){
<a name="l01727"></a>01727             p00=2*(2*p[iy][ix]-p[iy][ix+1])-(2*p[iy+1][ix]-p[iy+1][ix+1]);<span class="comment">//from a</span>
<a name="l01728"></a>01728         }<span class="keywordflow">else</span>{
<a name="l01729"></a>01729             p00=2*p[iy][ix-1]-p[iy+1][ix-1];<span class="comment">//from b</span>
<a name="l01730"></a>01730         }
<a name="l01731"></a>01731         p01=2*p[iy][ix]-p[iy+1][ix];
<a name="l01732"></a>01732         p02=2*p[iy][ix+1]-p[iy+1][ix+1];
<a name="l01733"></a>01733         <span class="keywordflow">if</span>(ix==nx-2){
<a name="l01734"></a>01734             p03=2*(p[iy][ix+1]*2-p[iy][ix])-(p[iy+1][ix+1]*2-p[iy+1][ix]);<span class="comment">//from n</span>
<a name="l01735"></a>01735         }<span class="keywordflow">else</span>{
<a name="l01736"></a>01736             p03=2*p[iy][ix+2]-p[iy+1][ix+2];<span class="comment">//from m</span>
<a name="l01737"></a>01737         }
<a name="l01738"></a>01738         }<span class="keywordflow">else</span>{
<a name="l01739"></a>01739         <span class="keywordflow">if</span>(ix==0){
<a name="l01740"></a>01740             p00=2*p[iy-1][ix]-p[iy-1][ix+1];<span class="comment">//a from b</span>
<a name="l01741"></a>01741         }<span class="keywordflow">else</span>{
<a name="l01742"></a>01742             p00=p[iy-1][ix-1];<span class="comment">//b</span>
<a name="l01743"></a>01743         }
<a name="l01744"></a>01744         p01=p[iy-1][ix];
<a name="l01745"></a>01745         p02=p[iy-1][ix+1];
<a name="l01746"></a>01746         <span class="keywordflow">if</span>(ix==nx-2){
<a name="l01747"></a>01747             p03=p[iy-1][ix+1]*2-p[iy-1][ix];<span class="comment">//n from m</span>
<a name="l01748"></a>01748         }<span class="keywordflow">else</span>{
<a name="l01749"></a>01749             p03=p[iy-1][ix+2];<span class="comment">//m</span>
<a name="l01750"></a>01750         }
<a name="l01751"></a>01751         }
<a name="l01752"></a>01752         <span class="keywordflow">if</span>(ix==0){
<a name="l01753"></a>01753         p10=p[iy][ix]*2-p[iy][ix+1];<span class="comment">//from c</span>
<a name="l01754"></a>01754         }<span class="keywordflow">else</span>{
<a name="l01755"></a>01755         p10=p[iy][ix-1];<span class="comment">//c</span>
<a name="l01756"></a>01756         }
<a name="l01757"></a>01757         p11=p[iy][ix];
<a name="l01758"></a>01758         p12=p[iy][ix+1];
<a name="l01759"></a>01759         <span class="keywordflow">if</span>(ix==nx-2){
<a name="l01760"></a>01760         p13=p[iy][ix+1]*2-p[iy][ix];<span class="comment">//from d</span>
<a name="l01761"></a>01761         }<span class="keywordflow">else</span>{
<a name="l01762"></a>01762         p13=p[iy][ix+2];<span class="comment">//d</span>
<a name="l01763"></a>01763         }
<a name="l01764"></a>01764         <span class="keywordflow">if</span>(ix==0){
<a name="l01765"></a>01765         p20=p[iy+1][ix]*2-p[iy+1][ix+1];<span class="comment">//from e</span>
<a name="l01766"></a>01766         }<span class="keywordflow">else</span>{
<a name="l01767"></a>01767         p20=p[iy+1][ix-1];<span class="comment">//e</span>
<a name="l01768"></a>01768         }
<a name="l01769"></a>01769         p21=p[iy+1][ix];
<a name="l01770"></a>01770         p22=p[iy+1][ix+1];
<a name="l01771"></a>01771         <span class="keywordflow">if</span>(ix==nx-2){
<a name="l01772"></a>01772         p23=p[iy+1][ix+1]*2-p[iy+1][ix];<span class="comment">//from f</span>
<a name="l01773"></a>01773         }<span class="keywordflow">else</span>{
<a name="l01774"></a>01774         p23=p[iy+1][ix+2];<span class="comment">//f</span>
<a name="l01775"></a>01775         }
<a name="l01776"></a>01776         <span class="keywordflow">if</span>(iy==ny-2){
<a name="l01777"></a>01777         <span class="keywordflow">if</span>(ix==0){
<a name="l01778"></a>01778             p30=2*(p[iy+1][ix]*2-p[iy+1][ix+1])-(p[iy][ix]*2-p[iy][ix+1]);<span class="comment">//from h</span>
<a name="l01779"></a>01779         }<span class="keywordflow">else</span>{
<a name="l01780"></a>01780             p30=2*p[iy+1][ix-1]-p[iy][ix-1];<span class="comment">//from g</span>
<a name="l01781"></a>01781         }
<a name="l01782"></a>01782         p31=2*p[iy+1][ix]-p[iy][ix];
<a name="l01783"></a>01783         p32=2*p[iy+1][ix+1]-p[iy][ix+1];
<a name="l01784"></a>01784         <span class="keywordflow">if</span>(ix==nx-2){
<a name="l01785"></a>01785             p33=2*(2*p[iy+1][ix+1]-p[iy+1][ix])-(2*p[iy][ix+1]-p[iy][ix]);<span class="comment">//from j</span>
<a name="l01786"></a>01786         }<span class="keywordflow">else</span>{
<a name="l01787"></a>01787             p33=2*p[iy+1][ix+2]-p[iy][ix+2];<span class="comment">//from i</span>
<a name="l01788"></a>01788         }
<a name="l01789"></a>01789         }<span class="keywordflow">else</span>{
<a name="l01790"></a>01790         <span class="keywordflow">if</span>(ix==0){
<a name="l01791"></a>01791             p30=p[iy+2][ix]*2-p[iy+2][ix+1];<span class="comment">//h from g</span>
<a name="l01792"></a>01792         }<span class="keywordflow">else</span>{
<a name="l01793"></a>01793             p30=p[iy+2][ix-1];<span class="comment">//g</span>
<a name="l01794"></a>01794         }
<a name="l01795"></a>01795         p31=p[iy+2][ix];
<a name="l01796"></a>01796         p32=p[iy+2][ix+1];
<a name="l01797"></a>01797         <span class="keywordflow">if</span>(ix==nx-2){
<a name="l01798"></a>01798             p33=2*p[iy+2][ix+1]-p[iy+2][ix];<span class="comment">//j from i</span>
<a name="l01799"></a>01799         }<span class="keywordflow">else</span>{
<a name="l01800"></a>01800             p33=p[iy+2][ix+2];<span class="comment">//i</span>
<a name="l01801"></a>01801         }
<a name="l01802"></a>01802         }
<a name="l01803"></a>01803         pc[iy][ix] = X(<span class="keyword">new</span>)(4,4);
<a name="l01804"></a>01804         PMAT(pc[iy][ix],ppc);
<a name="l01805"></a>01805         ppc[0][0] = p11;
<a name="l01806"></a>01806         ppc[0][1] = -.5*p10 + .5*p12;
<a name="l01807"></a>01807         ppc[0][2] = p10 - 2.5*p11 + 2*p12 - .5*p13;
<a name="l01808"></a>01808         ppc[0][3] = -.5*p10 + 1.5*p11 - 1.5*p12 + .5*p13;
<a name="l01809"></a>01809         ppc[1][0] = -.5*p01 + .5*p21;
<a name="l01810"></a>01810         ppc[1][1] = .25*p00 - .25*p02 - .25*p20 + .25*p22;
<a name="l01811"></a>01811         ppc[1][2] = -.5*p00 + 1.25*p01 - p02 + .25*p03 + .5*p20 - 1.25*p21 + p22 - .25*p23;
<a name="l01812"></a>01812         ppc[1][3] = .25*p00 - .75*p01 + .75*p02 - .25*p03 - .25*p20 + .75*p21 - .75*p22 + .25*p23;
<a name="l01813"></a>01813         ppc[2][0] = p01 - 2.5*p11 + 2*p21 - .5*p31;
<a name="l01814"></a>01814         ppc[2][1] = -.5*p00 + .5*p02 + 1.25*p10 - 1.25*p12 - p20 + p22 + .25*p30 - .25*p32;
<a name="l01815"></a>01815         ppc[2][2] = p00 - 2.5*p01 + 2*p02 - .5*p03 - 2.5*p10 + 6.25*p11 - 5*p12 + 1.25*p13 + 2*p20 - 5*p21 + 4*p22 - p23 - .5*p30 + 1.25*p31 - p32 + .25*p33;
<a name="l01816"></a>01816         ppc[2][3] = -.5*p00 + 1.5*p01 - 1.5*p02 + .5*p03 + 1.25*p10 - 3.75*p11 + 3.75*p12 - 1.25*p13 - p20 + 3*p21 - 3*p22 + p23 + .25*p30 - .75*p31 + .75*p32 - .25*p33;
<a name="l01817"></a>01817         ppc[3][0] = -.5*p01 + 1.5*p11 - 1.5*p21 + .5*p31;
<a name="l01818"></a>01818         ppc[3][1] = .25*p00 - .25*p02 - .75*p10 + .75*p12 + .75*p20 - .75*p22 - .25*p30 + .25*p32;
<a name="l01819"></a>01819         ppc[3][2] = -.5*p00 + 1.25*p01 - p02 + .25*p03 + 1.5*p10 - 3.75*p11 + 3*p12 - .75*p13 - 1.5*p20 + 3.75*p21 - 3*p22 + .75*p23 + .5*p30 - 1.25*p31 + p32 - .25*p33;
<a name="l01820"></a>01820         ppc[3][3] = .25*p00 - .75*p01 + .75*p02 - .25*p03 - .75*p10 + 2.25*p11 - 2.25*p12 + .75*p13 + .75*p20 - 2.25*p21 + 2.25*p22 - .75*p23 - .25*p30 + .75*p31 - .75*p32 + .25*p33;
<a name="l01821"></a>01821 
<a name="l01822"></a>01822     }
<a name="l01823"></a>01823     }
<a name="l01824"></a>01824     <span class="keywordflow">return</span> coeff;
<a name="l01825"></a>01825 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ee339b2c28b3fcf24144233e6b078002"></a><!-- doxytag: member="cmat.h::cbspline_eval" ref="ee339b2c28b3fcf24144233e6b078002" args="(ccell *coeff, cmat *x, cmat *y, cmat *xnew, cmat *ynew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cbspline_eval           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>xnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>ynew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evaluate 2D cubic spline at location defined 2-d arrays by xnew, ynew. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01830"></a>01830                                                                                         {
<a name="l01831"></a>01831     <span class="keyword">const</span> <span class="keywordtype">long</span> nx=x-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l01832"></a>01832     <span class="keyword">const</span> <span class="keywordtype">long</span> ny=y-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l01833"></a>01833     T xmin=x-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[0];
<a name="l01834"></a>01834     T ymin=y-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[0];
<a name="l01835"></a>01835     T xsep1=(double)(nx-1)/(x-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[nx-1]-xmin);
<a name="l01836"></a>01836     T ysep1=(double)(ny-1)/(y-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[ny-1]-ymin);
<a name="l01837"></a>01837     assert(xnew-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> == ynew-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> &amp;&amp; xnew-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a> == ynew-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l01838"></a>01838     X(mat)*znew=X(<span class="keyword">new</span>)(xnew-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, xnew-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l01839"></a>01839     PCELL(coeff,pc);
<a name="l01840"></a>01840     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;xnew-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>*xnew-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>; ix++){
<a name="l01841"></a>01841     <span class="keywordtype">double</span> xm=REAL((xnew-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[ix]-xmin)*xsep1);
<a name="l01842"></a>01842     <span class="keywordtype">long</span> xmf=floor(xm);
<a name="l01843"></a>01843     <span class="keywordflow">if</span>(xmf&lt;0) xmf=0;
<a name="l01844"></a>01844     <span class="keywordflow">if</span>(xmf&gt;nx-2) xmf=nx-2;
<a name="l01845"></a>01845     xm=xm-xmf;
<a name="l01846"></a>01846 
<a name="l01847"></a>01847     <span class="keywordtype">double</span> ym=REAL((ynew-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>[ix]-ymin)*ysep1);
<a name="l01848"></a>01848     <span class="keywordtype">long</span> ymf=floor(ym);
<a name="l01849"></a>01849     <span class="keywordflow">if</span>(ymf&lt;0) ymf=0;
<a name="l01850"></a>01850     <span class="keywordflow">if</span>(ymf&gt;ny-2) ymf=ny-2;
<a name="l01851"></a>01851     ym=ym-ymf;
<a name="l01852"></a>01852     
<a name="l01853"></a>01853     T xm2=xm *xm;
<a name="l01854"></a>01854     T xm3=xm2*xm;
<a name="l01855"></a>01855     T ym2=ym *ym;
<a name="l01856"></a>01856     T ym3=ym2*ym;
<a name="l01857"></a>01857     PMAT(pc[ymf][xmf],ppc);
<a name="l01858"></a>01858     znew-&gt;p[ix]= ppc[0][0] + ppc[0][1] * xm + ppc[0][2] * xm2 + ppc[0][3] * xm3 +
<a name="l01859"></a>01859         ppc[1][0] * ym + ppc[1][1] * ym * xm + ppc[1][2] * ym * xm2 + ppc[1][3] * ym * xm3 +
<a name="l01860"></a>01860         ppc[2][0] * ym2 + ppc[2][1] * ym2 * xm + ppc[2][2] * ym2 * xm2 + ppc[2][3] * ym2 * xm3 +
<a name="l01861"></a>01861         ppc[3][0] * ym3 + ppc[3][1] * ym3 * xm + ppc[3][2] * ym3 * xm2 + ppc[3][3] * ym3 * xm3;
<a name="l01862"></a>01862 
<a name="l01863"></a>01863     }
<a name="l01864"></a>01864     <span class="keywordflow">return</span> znew;
<a name="l01865"></a>01865 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cdcbda2dbd5dfec8344b8bada36a0a35"></a><!-- doxytag: member="cmat.h::ccellnew" ref="cdcbda2dbd5dfec8344b8bada36a0a35" args="(const long nx, const long ny)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellnew           </td>
          <td>(</td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&nbsp;</td>
          <td class="paramname"> <em>ny</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create a new block matrix. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01927"></a>01927                                                  {
<a name="l01928"></a>01928     X(cell) *dc;
<a name="l01929"></a>01929     dc=calloc(1, <span class="keyword">sizeof</span>(X(cell)));
<a name="l01930"></a>01930     dc-&gt;nx=nx;
<a name="l01931"></a>01931     dc-&gt;ny=ny;
<a name="l01932"></a>01932     dc-&gt;p=calloc(nx*ny, <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l01933"></a>01933     <span class="keywordflow">return</span> dc;
<a name="l01934"></a>01934 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3e751c651d80acbebc93a7536bfd4e65"></a><!-- doxytag: member="cmat.h::ccellnew2" ref="3e751c651d80acbebc93a7536bfd4e65" args="(const ccell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellnew2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create an new X(cell) similar to A in shape 
<p>
<div class="fragment"><pre class="fragment"><a name="l01939"></a>01939                                       {
<a name="l01940"></a>01940     X(cell) *out=X(cellnew)(A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>, A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>);
<a name="l01941"></a>01941     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>*A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; i++){
<a name="l01942"></a>01942     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[i]){
<a name="l01943"></a>01943         out-&gt;p[i]=X(<span class="keyword">new</span>)(A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[i]-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>, A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[i]-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l01944"></a>01944     }
<a name="l01945"></a>01945     }
<a name="l01946"></a>01946     <span class="keywordflow">return</span> out;
<a name="l01947"></a>01947 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="193a03f98ee7128386819d9821ceb859"></a><!-- doxytag: member="cmat.h::ccellzero" ref="193a03f98ee7128386819d9821ceb859" args="(ccell *dc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellzero           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
setting all elements of a X(cell) to zero. 
<p>
<div class="fragment"><pre class="fragment"><a name="l02010"></a>02010                              {
<a name="l02011"></a>02011     <span class="keywordflow">if</span>(dc){
<a name="l02012"></a>02012     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;dc-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>*dc-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; ix++){
<a name="l02013"></a>02013         X(zero)(dc-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[ix]);
<a name="l02014"></a>02014     }
<a name="l02015"></a>02015     }
<a name="l02016"></a>02016 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d9128f3e7703bfc29bb33d37397cf5c6"></a><!-- doxytag: member="cmat.h::ccellset" ref="d9128f3e7703bfc29bb33d37397cf5c6" args="(ccell *dc, dcomplex alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dcomplex&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
setting all elements of a X(cell) to alpha. 
<p>
<div class="fragment"><pre class="fragment"><a name="l02021"></a>02021                                     {
<a name="l02022"></a>02022     <span class="keywordflow">if</span>(dc){
<a name="l02023"></a>02023     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;dc-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>*dc-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; ix++){
<a name="l02024"></a>02024         X(<span class="keyword">set</span>)(dc-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[ix],alpha);
<a name="l02025"></a>02025     }
<a name="l02026"></a>02026     }
<a name="l02027"></a>02027 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6631a2e1f0b26b3b14723cb8e127ab11"></a><!-- doxytag: member="cmat.h::ccellfree_do" ref="6631a2e1f0b26b3b14723cb8e127ab11" args="(ccell *dc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellfree_do           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a X(cell) object. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01952"></a>01952                                 {
<a name="l01953"></a>01953     <span class="keywordflow">if</span>(!dc) <span class="keywordflow">return</span>;
<a name="l01954"></a>01954     <span class="keywordflow">if</span>(dc-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>){
<a name="l01955"></a>01955     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;dc-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>*dc-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; ix++){
<a name="l01956"></a>01956         X(free)(dc-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[ix]);
<a name="l01957"></a>01957     }
<a name="l01958"></a>01958     <span class="keywordflow">if</span>(dc-&gt;type==MT_MMAP){
<a name="l01959"></a>01959         <span class="keywordtype">long</span> headersize=<span class="keyword">sizeof</span>(long)*2+<span class="keyword">sizeof</span>(uint32_t);
<a name="l01960"></a>01960         munmap(((<span class="keywordtype">char</span>*)dc-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>)-headersize, headersize+dc-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>*dc-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>*<span class="keyword">sizeof</span>(T*));
<a name="l01961"></a>01961     }<span class="keywordflow">else</span>{
<a name="l01962"></a>01962         free(dc-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>);
<a name="l01963"></a>01963     }
<a name="l01964"></a>01964     }
<a name="l01965"></a>01965     free(dc);
<a name="l01966"></a>01966 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="db8e69bbe2c05a039f236fbb2eae12de"></a><!-- doxytag: member="cmat.h::ccelltrans" ref="db8e69bbe2c05a039f236fbb2eae12de" args="(const ccell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccelltrans           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
transpose a X(cell) object 
<p>
<div class="fragment"><pre class="fragment"><a name="l02032"></a>02032                                        {
<a name="l02033"></a>02033     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l02034"></a>02034     X(cell) *B=X(cellnew)(A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>, A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>);
<a name="l02035"></a>02035     X(mat)* (*Bp)[B-&gt;nx]=(<span class="keywordtype">void</span>*)B-&gt;p;
<a name="l02036"></a>02036     X(mat)* (*Ap)[A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>]=(<span class="keywordtype">void</span>*)A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>;
<a name="l02037"></a>02037     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;nx; ix++){
<a name="l02038"></a>02038     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; iy++){
<a name="l02039"></a>02039         Bp[ix][iy]=X(trans)(Ap[iy][ix]);
<a name="l02040"></a>02040     }
<a name="l02041"></a>02041     }
<a name="l02042"></a>02042     <span class="keywordflow">return</span> B;
<a name="l02043"></a>02043 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1f870a53b480b1477c2bc30e0178a516"></a><!-- doxytag: member="cmat.h::ccellref" ref="1f870a53b480b1477c2bc30e0178a516" args="(const ccell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellref           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creat a X(cell) reference an existing X(cell) by referencing the elements. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01972"></a>01972                                       {
<a name="l01973"></a>01973     <span class="keywordflow">if</span>(!in) <span class="keywordflow">return</span> NULL;
<a name="l01974"></a>01974     X(cell) *out=X(cellnew)(in-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>, in-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>);
<a name="l01975"></a>01975     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;in-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>*in-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; i++){
<a name="l01976"></a>01976     out-&gt;p[i]=X(ref)(in-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[i]);
<a name="l01977"></a>01977     }
<a name="l01978"></a>01978     <span class="keywordflow">return</span> out;
<a name="l01979"></a>01979 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0ed077f33b1a869fd6154ded4b557a4b"></a><!-- doxytag: member="cmat.h::ccelldup" ref="0ed077f33b1a869fd6154ded4b557a4b" args="(const ccell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccelldup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
duplicate a X(cell) object. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01984"></a>01984                                       {
<a name="l01985"></a>01985     X(cell) *out=NULL;
<a name="l01986"></a>01986     X(cellcp)(&amp;out, in);
<a name="l01987"></a>01987     <span class="keywordflow">return</span> out;
<a name="l01988"></a>01988 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="84b4ddc50d2114e9be97128fdf424e07"></a><!-- doxytag: member="cmat.h::ccellcp" ref="84b4ddc50d2114e9be97128fdf424e07" args="(ccell **out0, const ccell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellcp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy the values from one X(cell) to another. 
<p>
<div class="fragment"><pre class="fragment"><a name="l01993"></a>01993                                                  {
<a name="l01994"></a>01994     <span class="keywordflow">if</span>(in){
<a name="l01995"></a>01995     <span class="keywordflow">if</span>(!*out0)
<a name="l01996"></a>01996         *out0=X(cellnew)(in-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>, in-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>);
<a name="l01997"></a>01997     X(cell)* out=*out0;
<a name="l01998"></a>01998     assert(out-&gt;nx==in-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a> &amp;&amp; out-&gt;ny==in-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>);
<a name="l01999"></a>01999     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;in-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>*in-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; i++){
<a name="l02000"></a>02000         X(cp)(&amp;out-&gt;p[i], in-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[i]);
<a name="l02001"></a>02001     }
<a name="l02002"></a>02002     }<span class="keywordflow">else</span>{
<a name="l02003"></a>02003     X(cellfree)(*out0);<span class="comment">//copy a null X(cell) is same as erasing.</span>
<a name="l02004"></a>02004     }
<a name="l02005"></a>02005 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="83dd0483ef61373a16ee4c5478a919d1"></a><!-- doxytag: member="cmat.h::ccellnorm2" ref="83dd0483ef61373a16ee4c5478a919d1" args="(const ccell *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ccellnorm2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute norm2. 
<p>
<div class="fragment"><pre class="fragment"><a name="l02048"></a>02048                                      {
<a name="l02049"></a>02049     <span class="keywordtype">double</span> out=0;
<a name="l02050"></a>02050     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;nx*A-&gt;ny; i++){
<a name="l02051"></a>02051     out+=X(norm2)(A-&gt;p[i]);
<a name="l02052"></a>02052     }
<a name="l02053"></a>02053     <span class="keywordflow">return</span> out;
<a name="l02054"></a>02054 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0f63e81c5c497006f9f355a1f288cf91"></a><!-- doxytag: member="cmat.h::ccellscale" ref="0f63e81c5c497006f9f355a1f288cf91" args="(ccell *A, double w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellscale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>w</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
scale each element of A. 
<p>
<div class="fragment"><pre class="fragment"><a name="l02059"></a>02059                                        {
<a name="l02060"></a>02060     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l02061"></a>02061     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>*A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; i++){
<a name="l02062"></a>02062     X(scale)(A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[i],w);
<a name="l02063"></a>02063     }
<a name="l02064"></a>02064 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="00c2da2fc7f3d49037226159745c2378"></a><!-- doxytag: member="cmat.h::ccellreduce" ref="00c2da2fc7f3d49037226159745c2378" args="(const ccell *A, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellreduce           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reduce nx*ny cell matrix to 1*ny if dim=1 and nx*11 if dim=2 
<p>
<div class="fragment"><pre class="fragment"><a name="l02098"></a>02098                                                 {
<a name="l02099"></a>02099     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l02100"></a>02100     X(cell)* out=NULL;
<a name="l02101"></a>02101     <span class="keywordtype">long</span> nx, ny, *nxs, *nys;
<a name="l02102"></a>02102     X(celldim)(A, &amp;nx, &amp;ny, &amp;nxs, &amp;nys);
<a name="l02103"></a>02103     <span class="keywordflow">if</span>(nx==0 || ny==0) <span class="keywordflow">return</span> NULL;
<a name="l02104"></a>02104     PCELL(A,pA);
<a name="l02105"></a>02105     <span class="keywordflow">if</span>(dim==1){
<a name="l02106"></a>02106     out=X(cellnew)(1, A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>);
<a name="l02107"></a>02107     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; iy++){
<a name="l02108"></a>02108         <span class="keywordflow">if</span>(nys[iy]==0) <span class="keywordflow">continue</span>;
<a name="l02109"></a>02109         out-&gt;p[iy]=X(<span class="keyword">new</span>)(nx,nys[iy]);
<a name="l02110"></a>02110         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;nys[iy]; icol++){
<a name="l02111"></a>02111         <span class="keywordtype">long</span> kr=0;
<a name="l02112"></a>02112         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>; ix++){
<a name="l02113"></a>02113             <span class="keywordflow">if</span>(pA[iy][ix]){
<a name="l02114"></a>02114             memcpy(out-&gt;p[iy]-&gt;p+icol*nx+kr,
<a name="l02115"></a>02115                    pA[iy][ix]-&gt;p+icol*nxs[ix],
<a name="l02116"></a>02116                    nxs[ix]*<span class="keyword">sizeof</span>(T));
<a name="l02117"></a>02117             }           
<a name="l02118"></a>02118             kr+=nxs[ix];
<a name="l02119"></a>02119         }
<a name="l02120"></a>02120         }
<a name="l02121"></a>02121     }
<a name="l02122"></a>02122     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim==2){
<a name="l02123"></a>02123     out=X(cellnew)(A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>,1);
<a name="l02124"></a>02124     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>; ix++){
<a name="l02125"></a>02125         <span class="keywordflow">if</span>(nxs[ix]==0) <span class="keywordflow">continue</span>;
<a name="l02126"></a>02126         out-&gt;p[ix]=X(<span class="keyword">new</span>)(nxs[ix],ny);
<a name="l02127"></a>02127         <span class="keywordtype">long</span> kr=0;
<a name="l02128"></a>02128         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; iy++){
<a name="l02129"></a>02129         <span class="keywordflow">if</span>(pA[iy][ix]){
<a name="l02130"></a>02130             memcpy(out-&gt;p[ix]-&gt;p+kr*nxs[ix],
<a name="l02131"></a>02131                pA[iy][ix]-&gt;p,
<a name="l02132"></a>02132                nxs[ix]*nys[iy]*<span class="keyword">sizeof</span>(T));
<a name="l02133"></a>02133         }
<a name="l02134"></a>02134         kr+=nys[iy];
<a name="l02135"></a>02135         }
<a name="l02136"></a>02136     }
<a name="l02137"></a>02137     }<span class="keywordflow">else</span>{
<a name="l02138"></a>02138     error(<span class="stringliteral">"Invalid dim=%d\n"</span>,dim);
<a name="l02139"></a>02139     }
<a name="l02140"></a>02140     free(nxs);
<a name="l02141"></a>02141     free(nys);
<a name="l02142"></a>02142     <span class="keywordflow">return</span> out;
<a name="l02143"></a>02143 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6bc29f4fe8fda3c3a1ca2fe3ac56b126"></a><!-- doxytag: member="cmat.h::ccellcat" ref="6bc29f4fe8fda3c3a1ca2fe3ac56b126" args="(const ccell *A, const ccell *B, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellcat           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
concatenate two cell matrices along dimenstion 'dim' 
<p>
<div class="fragment"><pre class="fragment"><a name="l02148"></a>02148                                                                 {
<a name="l02149"></a>02149     <span class="keywordflow">if</span>(!A){
<a name="l02150"></a>02150     <span class="keywordflow">if</span>(!B){
<a name="l02151"></a>02151         <span class="keywordflow">return</span> NULL;
<a name="l02152"></a>02152     }<span class="keywordflow">else</span>{
<a name="l02153"></a>02153         <span class="keywordflow">return</span> X(celldup)(B);
<a name="l02154"></a>02154     }
<a name="l02155"></a>02155     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(!B){
<a name="l02156"></a>02156     <span class="keywordflow">return</span> X(celldup)(A);
<a name="l02157"></a>02157     }
<a name="l02158"></a>02158 
<a name="l02159"></a>02159     X(cell) *out=NULL;
<a name="l02160"></a>02160     PCELL(A,pA);
<a name="l02161"></a>02161     PCELL(B,pB);
<a name="l02162"></a>02162 
<a name="l02163"></a>02163     <span class="keywordflow">if</span>(dim==1){
<a name="l02164"></a>02164     <span class="comment">//along x.</span>
<a name="l02165"></a>02165     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>!=B-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>){
<a name="l02166"></a>02166         error(<span class="stringliteral">"Mismatch: A is (%ld, %ld), B is (%ld, %ld)\n"</span>,
<a name="l02167"></a>02167           A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>, A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>, B-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>, B-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>);
<a name="l02168"></a>02168     }
<a name="l02169"></a>02169     out=X(cellnew)(A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>+B-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>, A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>);
<a name="l02170"></a>02170     PCELL(out,pout);
<a name="l02171"></a>02171     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; iy++){
<a name="l02172"></a>02172         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>; ix++){
<a name="l02173"></a>02173         pout[iy][ix]=X(dup)(pA[iy][ix]);
<a name="l02174"></a>02174         }
<a name="l02175"></a>02175         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;B-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>; ix++){
<a name="l02176"></a>02176         pout[iy][ix+A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>]=X(dup)(pB[iy][ix]);
<a name="l02177"></a>02177         }
<a name="l02178"></a>02178     }
<a name="l02179"></a>02179     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim==2){
<a name="l02180"></a>02180     <span class="comment">//along y.</span>
<a name="l02181"></a>02181     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>!=B-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>){
<a name="l02182"></a>02182         error(<span class="stringliteral">"Mismatch. A is (%ld, %ld), B is (%ld, %ld)\n"</span>, 
<a name="l02183"></a>02183           A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>, A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>, B-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>, B-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>);
<a name="l02184"></a>02184     }
<a name="l02185"></a>02185     out=X(cellnew)(A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>, A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>+B-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>);
<a name="l02186"></a>02186     PCELL(out,pout);
<a name="l02187"></a>02187     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; iy++){
<a name="l02188"></a>02188         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>; ix++){
<a name="l02189"></a>02189         pout[iy][ix]=X(dup)(pA[iy][ix]);
<a name="l02190"></a>02190         }
<a name="l02191"></a>02191     }
<a name="l02192"></a>02192     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;B-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; iy++){
<a name="l02193"></a>02193         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;B-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>; ix++){
<a name="l02194"></a>02194         pout[iy+A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>][ix]=X(dup)(pB[iy][ix]);
<a name="l02195"></a>02195         }
<a name="l02196"></a>02196     }
<a name="l02197"></a>02197     }<span class="keywordflow">else</span>{
<a name="l02198"></a>02198     error(<span class="stringliteral">"Invalid dim\n"</span>);
<a name="l02199"></a>02199     }
<a name="l02200"></a>02200     <span class="keywordflow">return</span> out;
<a name="l02201"></a>02201 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="46bafd0a0ab7198be7c8c7ad4c42f88b"></a><!-- doxytag: member="cmat.h::ccellcat_each" ref="46bafd0a0ab7198be7c8c7ad4c42f88b" args="(const ccell *A, const ccell *B, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellcat_each           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
concatenate coresponding elements of each X(cell). 
<p>
They must have the same shape. <div class="fragment"><pre class="fragment"><a name="l02207"></a>02207                                                                      {
<a name="l02208"></a>02208     <span class="keywordflow">if</span>(!A){
<a name="l02209"></a>02209     <span class="keywordflow">if</span>(!B){
<a name="l02210"></a>02210         <span class="keywordflow">return</span> NULL;
<a name="l02211"></a>02211     }<span class="keywordflow">else</span>{
<a name="l02212"></a>02212         <span class="keywordflow">return</span> X(celldup)(B);
<a name="l02213"></a>02213     }
<a name="l02214"></a>02214     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(!B){
<a name="l02215"></a>02215     <span class="keywordflow">return</span> X(celldup)(A);
<a name="l02216"></a>02216     }
<a name="l02217"></a>02217     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>!=B-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a> || A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>!=B-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>){
<a name="l02218"></a>02218     error(<span class="stringliteral">"Mismatch: (%ld %ld), (%ld %ld)\n"</span>,A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>, A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>, B-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>, B-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>);
<a name="l02219"></a>02219     }
<a name="l02220"></a>02220     X(cell) *out=X(cellnew)(A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>, A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>);
<a name="l02221"></a>02221     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>*A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; ix++){
<a name="l02222"></a>02222     out-&gt;p[ix]=X(cat)(A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[ix], B-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[ix], dim);
<a name="l02223"></a>02223     }
<a name="l02224"></a>02224     <span class="keywordflow">return</span> out;
<a name="l02225"></a>02225 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d65426e91446c2e95481a47fc9e8716a"></a><!-- doxytag: member="cmat.h::ccelldropempty" ref="d65426e91446c2e95481a47fc9e8716a" args="(ccell **A0, int dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccelldropempty           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
drop empty rows or columns. 
<p>
(size of *A0 is changed. <div class="fragment"><pre class="fragment"><a name="l02230"></a>02230                                             {
<a name="l02231"></a>02231     X(cell) *A=*A0;
<a name="l02232"></a>02232     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span>;
<a name="l02233"></a>02233     PCELL(A,pA);
<a name="l02234"></a>02234     <span class="keywordflow">if</span>(dim==1){
<a name="l02235"></a>02235     <span class="comment">//drop rows</span>
<a name="l02236"></a>02236     <span class="keywordtype">int</span> keep[A-&gt;nx];
<a name="l02237"></a>02237     <span class="keywordtype">int</span> ndrop=0;
<a name="l02238"></a>02238     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;nx; ix++){
<a name="l02239"></a>02239         keep[ix]=0;
<a name="l02240"></a>02240         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;ny; iy++){
<a name="l02241"></a>02241         <span class="keywordflow">if</span>(pA[iy][ix]){
<a name="l02242"></a>02242             keep[ix]=1;
<a name="l02243"></a>02243             <span class="keywordflow">break</span>;
<a name="l02244"></a>02244         }
<a name="l02245"></a>02245         }
<a name="l02246"></a>02246         <span class="keywordflow">if</span>(keep[ix]==0)
<a name="l02247"></a>02247         ndrop++;
<a name="l02248"></a>02248     }
<a name="l02249"></a>02249     <span class="keywordflow">if</span>(ndrop!=0){
<a name="l02250"></a>02250         <span class="keywordflow">if</span>(ndrop==A-&gt;nx){
<a name="l02251"></a>02251         X(cellfree)(A);
<a name="l02252"></a>02252         *A0=NULL;
<a name="l02253"></a>02253         }<span class="keywordflow">else</span>{
<a name="l02254"></a>02254         X(cell) *B=calloc(1, <span class="keyword">sizeof</span>(X(cell)*));
<a name="l02255"></a>02255         B-&gt;p=calloc((A-&gt;nx-ndrop)*A-&gt;ny, <span class="keyword">sizeof</span>(X(mat)*));
<a name="l02256"></a>02256         PCELL(B,pB);
<a name="l02257"></a>02257         <span class="keywordtype">int</span> count=0;
<a name="l02258"></a>02258         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;nx; ix++){
<a name="l02259"></a>02259             <span class="keywordflow">if</span>(keep[ix]){
<a name="l02260"></a>02260             <span class="keywordflow">if</span>(count!=ix){
<a name="l02261"></a>02261                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;ny; iy++){
<a name="l02262"></a>02262                 pB[iy][count]=pA[iy][ix];
<a name="l02263"></a>02263                 }
<a name="l02264"></a>02264             }
<a name="l02265"></a>02265             count++;
<a name="l02266"></a>02266             }<span class="keywordflow">else</span>{
<a name="l02267"></a>02267             warning(<span class="stringliteral">"row %d dropped\n"</span>, ix);
<a name="l02268"></a>02268             }
<a name="l02269"></a>02269         }
<a name="l02270"></a>02270         free(A-&gt;p); free(A);
<a name="l02271"></a>02271         A=B;
<a name="l02272"></a>02272         }
<a name="l02273"></a>02273     }
<a name="l02274"></a>02274     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim==2){
<a name="l02275"></a>02275     <span class="comment">//drop cols</span>
<a name="l02276"></a>02276     <span class="keywordtype">int</span> count=0;
<a name="l02277"></a>02277     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;A-&gt;ny; iy++){
<a name="l02278"></a>02278         <span class="keywordtype">int</span> keep=0;
<a name="l02279"></a>02279         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;nx; ix++){
<a name="l02280"></a>02280         <span class="keywordflow">if</span>(pA[iy][ix]){
<a name="l02281"></a>02281             keep=1;
<a name="l02282"></a>02282             <span class="keywordflow">break</span>;
<a name="l02283"></a>02283         }
<a name="l02284"></a>02284         }
<a name="l02285"></a>02285         <span class="keywordflow">if</span>(keep){
<a name="l02286"></a>02286         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;A-&gt;nx; ix++){
<a name="l02287"></a>02287             pA[count][ix]=pA[iy][ix];
<a name="l02288"></a>02288         }
<a name="l02289"></a>02289         count++;
<a name="l02290"></a>02290         }<span class="keywordflow">else</span>{
<a name="l02291"></a>02291         <span class="comment">//warning("Col %d dropped\n", iy);</span>
<a name="l02292"></a>02292         }
<a name="l02293"></a>02293     }
<a name="l02294"></a>02294     A-&gt;ny=count;
<a name="l02295"></a>02295     <span class="keywordflow">if</span>(count==0){
<a name="l02296"></a>02296         X(cellfree)(A);
<a name="l02297"></a>02297         *A0=NULL;
<a name="l02298"></a>02298     }<span class="keywordflow">else</span>{
<a name="l02299"></a>02299         A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>=realloc(A-&gt;p,<span class="keyword">sizeof</span>(X(mat)*)*A-&gt;ny*A-&gt;nx);
<a name="l02300"></a>02300     }
<a name="l02301"></a>02301     }<span class="keywordflow">else</span>{
<a name="l02302"></a>02302     error(<span class="stringliteral">"Invalid dim: %d\n"</span>,dim);
<a name="l02303"></a>02303     }
<a name="l02304"></a>02304  
<a name="l02305"></a>02305 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e52c5a573fcaa559847488c664365e62"></a><!-- doxytag: member="cmat.h::ccelladd" ref="e52c5a573fcaa559847488c664365e62" args="(ccell **B0, double bc, const ccell *A, const double ac)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccelladd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>B0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>ac</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add one to another. 
<p>
B=B*bc+A*ac <div class="fragment"><pre class="fragment"><a name="l02310"></a>02310                                                                           {
<a name="l02311"></a>02311     <span class="keywordflow">if</span>(A){
<a name="l02312"></a>02312     <span class="keywordflow">if</span>(!*B0){
<a name="l02313"></a>02313         *B0=X(cellnew)(A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>, A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>); bc=0;
<a name="l02314"></a>02314     }
<a name="l02315"></a>02315     X(cell) *B=*B0;
<a name="l02316"></a>02316     assert(A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>==B-&gt;nx &amp;&amp; A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a> == B-&gt;ny);
<a name="l02317"></a>02317     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>*A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; i++){
<a name="l02318"></a>02318         X(<span class="keyword">add</span>)(&amp;B-&gt;p[i], bc, A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[i], ac);
<a name="l02319"></a>02319     }
<a name="l02320"></a>02320     }
<a name="l02321"></a>02321 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="df204a1a88694e37365a17488d1e12c8"></a><!-- doxytag: member="cmat.h::ccellinn" ref="df204a1a88694e37365a17488d1e12c8" args="(const ccell *A, const ccell *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dcomplex ccellinn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the inner produce of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>. 
<p>
<div class="fragment"><pre class="fragment"><a name="l02326"></a>02326                                               {
<a name="l02327"></a>02327     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>!=B-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a> || A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>!=1 || B-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>!=1) error(<span class="stringliteral">"mismatch\n"</span>);
<a name="l02328"></a>02328     T out=0;
<a name="l02329"></a>02329     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>; i++){
<a name="l02330"></a>02330     out+=X(inn)(A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[i], B-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[i]);
<a name="l02331"></a>02331     }
<a name="l02332"></a>02332     <span class="keywordflow">return</span> out;
<a name="l02333"></a>02333 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="92110ce17c83d4a1f68d856ec32a90cd"></a><!-- doxytag: member="cmat.h::ccellcwm" ref="92110ce17c83d4a1f68d856ec32a90cd" args="(ccell *B, const ccell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellcwm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Component wise multiply of two <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a> B=A. 
<p>
*B*alpha <div class="fragment"><pre class="fragment"><a name="l02339"></a>02339                                              {
<a name="l02340"></a>02340     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>!=B-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a> || A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a> !=B-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>) error(<span class="stringliteral">"mismatch\n"</span>);
<a name="l02341"></a>02341     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>*A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; i++){
<a name="l02342"></a>02342     X(cwm)(B-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[i], A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[i]);
<a name="l02343"></a>02343     }
<a name="l02344"></a>02344 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="afe341e06821b09968d37a530a3adc3e"></a><!-- doxytag: member="cmat.h::ccellmm" ref="afe341e06821b09968d37a530a3adc3e" args="(ccell **C0, const ccell *A, const ccell *B, const char trans[2], const double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellmm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>trans</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute A*B and add to C0. 
<p>
C=C+trans(A)*trans(B)*alpha<p>
2009-11-09: There was initially a beta parameter It was implemented wrongly for beta!=1 because for every call to dmm, the already accumulated ones are scaled. removed beta. <div class="fragment"><pre class="fragment"><a name="l02356"></a>02356                                                    {
<a name="l02357"></a>02357     <span class="keywordflow">if</span>(!A || !B) <span class="keywordflow">return</span>;
<a name="l02358"></a>02358     <span class="keywordtype">int</span> ax, az;
<a name="l02359"></a>02359     <span class="keywordtype">int</span> nx,ny,nz;
<a name="l02360"></a>02360     <span class="keywordtype">int</span> bz, by;
<a name="l02361"></a>02361     <span class="keywordflow">if</span>(trans[0]==<span class="charliteral">'n'</span>||trans[0]==<span class="charliteral">'N'</span>){
<a name="l02362"></a>02362     nx=A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>; 
<a name="l02363"></a>02363     ax=1; az=A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>;
<a name="l02364"></a>02364     nz=A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>;
<a name="l02365"></a>02365     }<span class="keywordflow">else</span>{ 
<a name="l02366"></a>02366     nx=A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>;
<a name="l02367"></a>02367     az=1; ax=A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>;
<a name="l02368"></a>02368     nz=A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>;
<a name="l02369"></a>02369     }
<a name="l02370"></a>02370     <span class="keywordflow">if</span>(trans[1]==<span class="charliteral">'n'</span>||trans[0]==<span class="charliteral">'N'</span>){
<a name="l02371"></a>02371     ny=B-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; 
<a name="l02372"></a>02372     bz=1; by=B-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>;
<a name="l02373"></a>02373     <span class="keywordflow">if</span>(nz!=B-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>) error(<span class="stringliteral">"mismatch\n"</span>);
<a name="l02374"></a>02374     }<span class="keywordflow">else</span>{
<a name="l02375"></a>02375     ny=B-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>;
<a name="l02376"></a>02376     by=1; bz=B-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>;
<a name="l02377"></a>02377     <span class="keywordflow">if</span>(nz!=B-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>) error(<span class="stringliteral">"mismatch\n"</span>);
<a name="l02378"></a>02378     }
<a name="l02379"></a>02379     <span class="keywordflow">if</span>(!*C0){
<a name="l02380"></a>02380     *C0=X(cellnew)(nx,ny);
<a name="l02381"></a>02381     }
<a name="l02382"></a>02382     X(cell) *C=*C0;
<a name="l02383"></a>02383     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;ny; iy++){
<a name="l02384"></a>02384     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;nx; ix++){
<a name="l02385"></a>02385         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz=0; iz&lt;nz; iz++){
<a name="l02386"></a>02386         <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[ix*ax+iz*az]&amp;&amp;B-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[iz*bz+iy*by]){
<a name="l02387"></a>02387             X(mm)(&amp;C-&gt;p[ix+iy*nx],A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[ix*ax+iz*az], 
<a name="l02388"></a>02388               B-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[iz*bz+iy*by],trans,alpha);
<a name="l02389"></a>02389         }
<a name="l02390"></a>02390         }
<a name="l02391"></a>02391     }
<a name="l02392"></a>02392     }
<a name="l02393"></a>02393 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="99b65983778109d4aa815d3ea5db9414"></a><!-- doxytag: member="cmat.h::ccellinvspd" ref="99b65983778109d4aa815d3ea5db9414" args="(ccell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellinvspd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inplace Invert a SPD matrix. 
<p>
It is treated as a block matrix <div class="fragment"><pre class="fragment"><a name="l02398"></a>02398                                   {
<a name="l02399"></a>02399     X(mat) *Ab=X(cell2m)(A);
<a name="l02400"></a>02400     X(invspd_inplace)(Ab);
<a name="l02401"></a>02401     X(cell) *B=NULL;
<a name="l02402"></a>02402     X(2cell)(&amp;B, Ab, A);
<a name="l02403"></a>02403     X(celldropzero)(B,0);
<a name="l02404"></a>02404     X(free)(Ab);
<a name="l02405"></a>02405     <span class="keywordflow">return</span> B;
<a name="l02406"></a>02406 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ddb2ebf6b55726391b1ea6be0e210e2e"></a><!-- doxytag: member="cmat.h::ccellinv" ref="ddb2ebf6b55726391b1ea6be0e210e2e" args="(ccell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellinv           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inplace Invert a matrix. 
<p>
It is treated as a block matrix. <div class="fragment"><pre class="fragment"><a name="l02411"></a>02411                                {
<a name="l02412"></a>02412     X(mat) *Ab=X(cell2m)(A);
<a name="l02413"></a>02413     X(inv_inplace)(Ab);
<a name="l02414"></a>02414     X(cell) *B=NULL;
<a name="l02415"></a>02415     X(2cell)(&amp;B, Ab, A);
<a name="l02416"></a>02416     X(celldropzero)(B,0);
<a name="l02417"></a>02417     X(free)(Ab);
<a name="l02418"></a>02418     <span class="keywordflow">return</span> B;
<a name="l02419"></a>02419 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="72a43514eb1abfbe161f74f5a223f2f5"></a><!-- doxytag: member="cmat.h::ccellinvspd_each" ref="72a43514eb1abfbe161f74f5a223f2f5" args="(ccell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellinvspd_each           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
invert each component of the <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>. 
<p>
Each cell is treated as an individual matrix. <div class="fragment"><pre class="fragment"><a name="l02424"></a>02424                                        {
<a name="l02425"></a>02425     X(cell) *out=NULL;
<a name="l02426"></a>02426     X(cellcp)(&amp;out,A);
<a name="l02427"></a>02427     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;out-&gt;nx*out-&gt;ny; i++){
<a name="l02428"></a>02428     X(invspd_inplace)(out-&gt;p[i]);
<a name="l02429"></a>02429     }
<a name="l02430"></a>02430     <span class="keywordflow">return</span> out;
<a name="l02431"></a>02431 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2c8c0809e00fd5d528cbb31048f3c52a"></a><!-- doxytag: member="cmat.h::ccell2m" ref="2c8c0809e00fd5d528cbb31048f3c52a" args="(const ccell *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* ccell2m           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a block matrix to a matrix. 
<p>
<div class="fragment"><pre class="fragment"><a name="l02436"></a>02436                                    {
<a name="l02437"></a>02437     X(mat) *(*Ap)[A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>] = (X(mat) *(*)[A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>])A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>;
<a name="l02438"></a>02438     <span class="keywordtype">long</span> nx,ny,*nxs,*nys;
<a name="l02439"></a>02439     X(celldim)(A,&amp;nx,&amp;ny,&amp;nxs,&amp;nys);
<a name="l02440"></a>02440     X(mat) *out=X(<span class="keyword">new</span>)(nx,ny);
<a name="l02441"></a>02441     <span class="keywordtype">long</span> jcol=0;
<a name="l02442"></a>02442     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; iy++){
<a name="l02443"></a>02443     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;nys[iy]; icol++){
<a name="l02444"></a>02444         <span class="keywordtype">long</span> kr=0;
<a name="l02445"></a>02445         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>; ix++){
<a name="l02446"></a>02446         <span class="keywordflow">if</span>(Ap[iy][ix]){
<a name="l02447"></a>02447             memcpy(out-&gt;p+((icol+jcol)*nx+kr),
<a name="l02448"></a>02448                Ap[iy][ix]-&gt;p+icol*nxs[ix],
<a name="l02449"></a>02449                nxs[ix]*<span class="keyword">sizeof</span>(T));
<a name="l02450"></a>02450         }
<a name="l02451"></a>02451         kr+=nxs[ix];
<a name="l02452"></a>02452         }
<a name="l02453"></a>02453     }
<a name="l02454"></a>02454     jcol+=nys[iy];
<a name="l02455"></a>02455     }
<a name="l02456"></a>02456     free(nxs);
<a name="l02457"></a>02457     free(nys);
<a name="l02458"></a>02458     <span class="keywordflow">return</span> out;
<a name="l02459"></a>02459 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1545f84a1ac4226ce43fbfc8ba0af5db"></a><!-- doxytag: member="cmat.h::c2cellref" ref="1545f84a1ac4226ce43fbfc8ba0af5db" args="(const cmat *A, int *dims, int ndim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* c2cellref           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
convert a vector to cell using dimensions specified in dims. 
<p>
Reference the vector <div class="fragment"><pre class="fragment"><a name="l02464"></a>02464                                                          {
<a name="l02465"></a>02465     <span class="keywordtype">long</span> nx=0;
<a name="l02466"></a>02466     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;ndim; ix++){
<a name="l02467"></a>02467     nx+=dims[ix];
<a name="l02468"></a>02468     }
<a name="l02469"></a>02469     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>!=1){
<a name="l02470"></a>02470     error(<span class="stringliteral">"Use d2cell2 instead for non vectors\n"</span>);
<a name="l02471"></a>02471     }
<a name="l02472"></a>02472     <span class="keywordflow">if</span>(nx!=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> ){
<a name="l02473"></a>02473     error(<span class="stringliteral">"Shape doesn't agree. nx=%ld, nx=%ld\n"</span>, nx,A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>);
<a name="l02474"></a>02474     }
<a name="l02475"></a>02475     <span class="keywordtype">long</span> kr=0;
<a name="l02476"></a>02476     X(cell) *B=X(cellnew)(ndim,1);
<a name="l02477"></a>02477     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;ndim; ix++){
<a name="l02478"></a>02478     B-&gt;p[ix]=X(new_ref)(A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>+kr,dims[ix],1);<span class="comment">//refrence the data. </span>
<a name="l02479"></a>02479     kr+=dims[ix];
<a name="l02480"></a>02480     }
<a name="l02481"></a>02481     <span class="keywordflow">return</span> B;
<a name="l02482"></a>02482 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a5983177f2055cae1bb16f5a53e3f4aa"></a><!-- doxytag: member="cmat.h::c2cell" ref="a5983177f2055cae1bb16f5a53e3f4aa" args="(ccell **B, const cmat *A, const ccell *ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void c2cell           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>ref</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
make A a cell array using shape information from ref if *B is NULL 
<p>
<div class="fragment"><pre class="fragment"><a name="l02487"></a>02487                                                                {
<a name="l02488"></a>02488     <span class="keywordtype">long</span> nx,ny,*nxs,*nys;
<a name="l02489"></a>02489     <span class="keywordflow">if</span>(*B) ref=*B;<span class="comment">//use B as reference.</span>
<a name="l02490"></a>02490     X(celldim)(ref, &amp;nx, &amp;ny, &amp;nxs, &amp;nys);
<a name="l02491"></a>02491     <span class="keywordflow">if</span>(nx!=A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a> || ny!=A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>){
<a name="l02492"></a>02492     error(<span class="stringliteral">"Shape doesn't agree. Reference is %ldx%ld but input is %ldx%ld\n"</span>,
<a name="l02493"></a>02493           nx,ny,A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>,A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>);
<a name="l02494"></a>02494     }
<a name="l02495"></a>02495     <span class="keywordflow">if</span>(!*B){
<a name="l02496"></a>02496     *B=X(cellnew)(ref-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>, ref-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>);
<a name="l02497"></a>02497     PCELL((*B),Bp);
<a name="l02498"></a>02498     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;ref-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; iy++){
<a name="l02499"></a>02499         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;ref-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>; ix++){
<a name="l02500"></a>02500         Bp[iy][ix]=X(<span class="keyword">new</span>)(nxs[ix],nys[iy]);
<a name="l02501"></a>02501         }
<a name="l02502"></a>02502     }
<a name="l02503"></a>02503     }
<a name="l02504"></a>02504     PCELL((*B),Bp);
<a name="l02505"></a>02505     <span class="keywordtype">long</span> jcol=0;
<a name="l02506"></a>02506     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;ref-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; iy++){
<a name="l02507"></a>02507     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> icol=0; icol&lt;nys[iy]; icol++){
<a name="l02508"></a>02508         <span class="keywordtype">long</span> kr=0;
<a name="l02509"></a>02509         <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;ref-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>; ix++){
<a name="l02510"></a>02510         <span class="keywordflow">if</span>(nxs[ix]&gt;0){
<a name="l02511"></a>02511             memcpy(Bp[iy][ix]-&gt;p+icol*Bp[iy][ix]-&gt;nx,
<a name="l02512"></a>02512                A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>+((icol+jcol)*nx+kr),
<a name="l02513"></a>02513                nxs[ix]*<span class="keyword">sizeof</span>(T));
<a name="l02514"></a>02514             kr+=nxs[ix];
<a name="l02515"></a>02515         }
<a name="l02516"></a>02516         }
<a name="l02517"></a>02517     }
<a name="l02518"></a>02518     jcol+=nys[iy];
<a name="l02519"></a>02519     }
<a name="l02520"></a>02520     free(nxs);
<a name="l02521"></a>02521     free(nys);
<a name="l02522"></a>02522 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b0d7e1c7d7eb2810eff34b04111129c8"></a><!-- doxytag: member="cmat.h::ccelldropzero" ref="b0d7e1c7d7eb2810eff34b04111129c8" args="(ccell *B, double thres)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccelldropzero           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>thres</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
drop empty blocks (zero). 
<p>
Size of B is not modified. <div class="fragment"><pre class="fragment"><a name="l02527"></a>02527                                               {
<a name="l02528"></a>02528     PCELL(B,Bp);
<a name="l02529"></a>02529     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> iy=0; iy&lt;B-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; iy++){
<a name="l02530"></a>02530     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;B-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>; ix++){
<a name="l02531"></a>02531         X(mat) *tmp=Bp[iy][ix];
<a name="l02532"></a>02532         <span class="keywordflow">if</span>(!tmp) <span class="keywordflow">continue</span>;
<a name="l02533"></a>02533         <span class="keywordtype">int</span> hasnonzero=0;
<a name="l02534"></a>02534         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ixy=0; ixy&lt;tmp-&gt;nx*tmp-&gt;ny; ixy++){
<a name="l02535"></a>02535         <span class="keywordflow">if</span>(ABS(tmp-&gt;p[ixy])&gt;thres){
<a name="l02536"></a>02536             hasnonzero=1;
<a name="l02537"></a>02537             <span class="keywordflow">break</span>;
<a name="l02538"></a>02538         }
<a name="l02539"></a>02539         }
<a name="l02540"></a>02540         <span class="keywordflow">if</span>(!hasnonzero){
<a name="l02541"></a>02541         X(free)(Bp[iy][ix]);
<a name="l02542"></a>02542         Bp[iy][ix]=NULL;
<a name="l02543"></a>02543         <span class="comment">//warning("Dropped block (%ld, %ld)\n", ix, iy);</span>
<a name="l02544"></a>02544         }
<a name="l02545"></a>02545     }
<a name="l02546"></a>02546     }
<a name="l02547"></a>02547 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2fd83c2f600649a6205e8c62547f6e8d"></a><!-- doxytag: member="cmat.h::ccelldiff" ref="2fd83c2f600649a6205e8c62547f6e8d" args="(const ccell *A, const ccell *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ccelldiff           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute ||A-B||/||A|| use mean. 
<p>
<div class="fragment"><pre class="fragment"><a name="l02553"></a>02553                                                       {
<a name="l02554"></a>02554     X(cell) *C=NULL;
<a name="l02555"></a>02555     X(cellcp)(&amp;C,A);
<a name="l02556"></a>02556     X(celladd)(&amp;C,1,B,-1);
<a name="l02557"></a>02557     <span class="keywordtype">double</span> d=sqrt(X(cellnorm2)(C)*2/(X(cellnorm2)(C)+X(cellnorm2)(B)));
<a name="l02558"></a>02558     <span class="keywordflow">return</span> isnan(d)?0:d;
<a name="l02559"></a>02559 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="fdb96e19ff1dfea164570fc47815a2ab"></a><!-- doxytag: member="cmat.h::ccellclip" ref="fdb96e19ff1dfea164570fc47815a2ab" args="(ccell *Ac, double min, double max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccellclip           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>Ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
clip a X(cell) array to max at 'max', min at 'min' 
<p>
<div class="fragment"><pre class="fragment"><a name="l02564"></a>02564                                                     {
<a name="l02565"></a>02565     <span class="keywordflow">if</span>(!Ac || !Ac-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>) <span class="keywordflow">return</span> 0;
<a name="l02566"></a>02566     <span class="keywordflow">if</span>(isinf(min)==-1 &amp;&amp; isinf(max)==1) <span class="keywordflow">return</span> 0;
<a name="l02567"></a>02567     <span class="keywordtype">int</span> nclip=0;
<a name="l02568"></a>02568     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i=0; i&lt;Ac-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>*Ac-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; i++){
<a name="l02569"></a>02569     nclip+=X(clip)(Ac-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[i],min,max);
<a name="l02570"></a>02570     }
<a name="l02571"></a>02571     <span class="keywordflow">return</span> nclip;
<a name="l02572"></a>02572 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6e30556d58339cea7a00a4b163822af4"></a><!-- doxytag: member="cmat.h::ccelltikcr" ref="6e30556d58339cea7a00a4b163822af4" args="(ccell *A, double thres)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccelltikcr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>thres</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply tickholov regularization of relative thres to cell array by converting it to mat. 
<p>
<div class="fragment"><pre class="fragment"><a name="l02578"></a>02578                                            {
<a name="l02579"></a>02579     X(mat) *Ab=X(cell2m)(A);
<a name="l02580"></a>02580     X(tikcr)(Ab,thres);
<a name="l02581"></a>02581     X(2cell)(&amp;A,Ab,NULL);
<a name="l02582"></a>02582     X(free)(Ab);
<a name="l02583"></a>02583 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0a9902ff737584f210c3730f430b1599"></a><!-- doxytag: member="cmat.h::ccellpinv" ref="0a9902ff737584f210c3730f430b1599" args="(const ccell *A, const ccell *wt, const cspcell *Wsp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellpinv           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>wt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>Wsp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the pseudo inverse of block matrix A. 
<p>
A is n*p cell, wt n*n cell or sparse cell. <img class="formulaInl" alt="$B=inv(A'*W*A)*A'*W$" src="form_0.png">; <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>The matrix to pseudo invert </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wt</em>&nbsp;</td><td>Use a dense matrix for weighting </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Wsp</em>&nbsp;</td><td>Use a sparse matrix for weighting </td></tr>
  </table>
</dl>
<div class="fragment"><pre class="fragment"><a name="l02591"></a>02591               {
<a name="l02592"></a>02592     <span class="keywordflow">if</span>(!A) <span class="keywordflow">return</span> NULL;
<a name="l02593"></a>02593     X(cell) *wA=NULL;
<a name="l02594"></a>02594     <span class="keywordflow">if</span>(!wt){
<a name="l02595"></a>02595     wA=X(cellref)(A);
<a name="l02596"></a>02596     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(Wsp &amp;&amp; !wt){
<a name="l02597"></a>02597     assert(Wsp-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>==A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a> &amp;&amp; Wsp-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>==A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>);
<a name="l02598"></a>02598     Y(spcellmulmat)(&amp;wA,Wsp,A,1);
<a name="l02599"></a>02599     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(wt &amp;&amp; !Wsp){
<a name="l02600"></a>02600     assert(wt-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>==A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a> &amp;&amp; wt-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>==A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>);
<a name="l02601"></a>02601     X(cellmm)(&amp;wA, wt, A, <span class="stringliteral">"nn"</span>,1);
<a name="l02602"></a>02602     }<span class="keywordflow">else</span>{
<a name="l02603"></a>02603     error(<span class="stringliteral">"Both wt and Wsp are specified.\n"</span>);
<a name="l02604"></a>02604     }
<a name="l02605"></a>02605     X(cell) *ata=NULL;
<a name="l02606"></a>02606     X(cell) *iata;
<a name="l02607"></a>02607     X(cellmm)(&amp;ata,wA,A,<span class="stringliteral">"tn"</span>,1);
<a name="l02608"></a>02608     iata=X(cellinvspd)(ata);
<a name="l02609"></a>02609     X(cellfree)(ata);
<a name="l02610"></a>02610     X(cell) *out=NULL;
<a name="l02611"></a>02611     X(cellmm)(&amp;out, iata, wA, <span class="stringliteral">"nt"</span>,1);
<a name="l02612"></a>02612     X(cellfree)(wA);
<a name="l02613"></a>02613     X(cellfree)(iata);
<a name="l02614"></a>02614     <span class="keywordflow">return</span> out;
<a name="l02615"></a>02615 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="611ce556f87c2ac01da0b00b717cd964"></a><!-- doxytag: member="cmat.h::ccellmulsp" ref="611ce556f87c2ac01da0b00b717cd964" args="(ccell **C0, const ccell *A, const cspcell *B, double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellmulsp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> **&nbsp;</td>
          <td class="paramname"> <em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a cell with a sparse cell. 
<p>
<img class="formulaInl" alt="$C0+=A*B*alpha$" src="form_1.png">. <div class="fragment"><pre class="fragment"><a name="l02622"></a>02622                                                                                    {
<a name="l02623"></a>02623     <span class="keywordflow">if</span>(!A || !B) <span class="keywordflow">return</span>;
<a name="l02624"></a>02624     <span class="keywordtype">int</span> ax, az;
<a name="l02625"></a>02625     <span class="keywordtype">int</span> nx,ny,nz;
<a name="l02626"></a>02626     <span class="keywordtype">int</span> bz, by;
<a name="l02627"></a>02627     <span class="keyword">const</span> <span class="keywordtype">char</span> trans[2]=<span class="stringliteral">"nn"</span>;
<a name="l02628"></a>02628     <span class="keywordflow">if</span>(trans[0]==<span class="charliteral">'n'</span>||trans[0]==<span class="charliteral">'N'</span>){
<a name="l02629"></a>02629     nx=A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>; 
<a name="l02630"></a>02630     ax=1; az=A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>;
<a name="l02631"></a>02631     nz=A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>;
<a name="l02632"></a>02632     }<span class="keywordflow">else</span>{ 
<a name="l02633"></a>02633     nx=A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>;
<a name="l02634"></a>02634     az=1; ax=A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>;
<a name="l02635"></a>02635     nz=A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>;
<a name="l02636"></a>02636     }
<a name="l02637"></a>02637     <span class="keywordflow">if</span>(trans[1]==<span class="charliteral">'n'</span>||trans[0]==<span class="charliteral">'N'</span>){
<a name="l02638"></a>02638     ny=B-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; 
<a name="l02639"></a>02639     bz=1; by=B-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>;
<a name="l02640"></a>02640     <span class="keywordflow">if</span>(nz!=B-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>) error(<span class="stringliteral">"mismatch\n"</span>);
<a name="l02641"></a>02641     }<span class="keywordflow">else</span>{
<a name="l02642"></a>02642     ny=B-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>;
<a name="l02643"></a>02643     by=1; bz=B-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>;
<a name="l02644"></a>02644     <span class="keywordflow">if</span>(nz!=B-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>) error(<span class="stringliteral">"mismatch\n"</span>);
<a name="l02645"></a>02645     }
<a name="l02646"></a>02646     <span class="keywordflow">if</span>(!*C0){
<a name="l02647"></a>02647     *C0=X(cellnew)(nx,ny);
<a name="l02648"></a>02648     }
<a name="l02649"></a>02649     X(cell) *C=*C0;
<a name="l02650"></a>02650     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy=0; iy&lt;ny; iy++){
<a name="l02651"></a>02651     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix=0; ix&lt;nx; ix++){
<a name="l02652"></a>02652         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz=0; iz&lt;nz; iz++){
<a name="l02653"></a>02653         <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[ix*ax+iz*az] &amp;&amp; B-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[iz*bz+iy*by]){
<a name="l02654"></a>02654             X(mulsp)(&amp;C-&gt;p[ix+iy*nx],A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[ix*ax+iz*az], 
<a name="l02655"></a>02655                  B-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[iz*bz+iy*by],alpha);
<a name="l02656"></a>02656         }
<a name="l02657"></a>02657         }
<a name="l02658"></a>02658     }
<a name="l02659"></a>02659     }
<a name="l02660"></a>02660 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="35a0966fdc0e65bdcf290c75e0404713"></a><!-- doxytag: member="cmat.h::ccelladdI" ref="35a0966fdc0e65bdcf290c75e0404713" args="(ccell *A, double a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccelladdI           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add a to diagonal elements of A; 
<p>
<div class="fragment"><pre class="fragment"><a name="l02665"></a>02665                                       {
<a name="l02666"></a>02666     <span class="keywordflow">if</span>(A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>!=A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>) 
<a name="l02667"></a>02667     error(<span class="stringliteral">"A must be symmetric\n"</span>);
<a name="l02668"></a>02668     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ib=0; ib&lt;A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>; ib++){
<a name="l02669"></a>02669     X(addI)(A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[ib+ib*A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>], a);
<a name="l02670"></a>02670     }
<a name="l02671"></a>02671 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d7eece0d6b59dbc7d2e98d5ce866b21b"></a><!-- doxytag: member="cmat.h::ccellsvd_pow" ref="d7eece0d6b59dbc7d2e98d5ce866b21b" args="(ccell *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellsvd_pow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute the power of a block matrix using svd method. 
<p>
First convert it do X(mat), do the power, and convert back to block matrix. <div class="fragment"><pre class="fragment"><a name="l02677"></a>02677                                              {
<a name="l02678"></a>02678     X(mat) *Ac=X(cell2m)(A);
<a name="l02679"></a>02679     X(svd_pow)(Ac, power);
<a name="l02680"></a>02680     X(2cell)(&amp;A, Ac, NULL);
<a name="l02681"></a>02681     X(free)(Ac);
<a name="l02682"></a>02682 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="92d8633d3243ae2a95e43d6b41c4a2cb"></a><!-- doxytag: member="cmat.h::ccellcwpow" ref="92d8633d3243ae2a95e43d6b41c4a2cb" args="(ccell *A, double power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellcwpow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
raise each cell in the cell array to power of power. 
<p>
<div class="fragment"><pre class="fragment"><a name="l02687"></a>02687                                           {
<a name="l02688"></a>02688     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ib=0; ib&lt;A-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>*A-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>; ib++){
<a name="l02689"></a>02689     X(cwpow)(A-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[ib],power);
<a name="l02690"></a>02690     }
<a name="l02691"></a>02691 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="28f2c1a91c80f5dc8c951f875d79f2de"></a><!-- doxytag: member="cmat.h::cwritedata" ref="28f2c1a91c80f5dc8c951f875d79f2de" args="(file_t *fp, const cmat *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cwritedata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contains routines to write/read dense/sparse matrix into/from file. 
<p>
Function to write dense matrix data into a file pointer. Generally used by library developer <div class="fragment"><pre class="fragment"><a name="l02736"></a>02736                                               {
<a name="l02737"></a>02737     <span class="keywordtype">void</span> *p=NULL;
<a name="l02738"></a>02738     uint64_t nx=0, ny=0;
<a name="l02739"></a>02739     <span class="keywordflow">if</span>(A){
<a name="l02740"></a>02740     p=A-&gt;<a class="code" href="structcmat.html#8b3042714ec7576bcdb1204030e8532a" title="the pointer to allocated memory.">p</a>;
<a name="l02741"></a>02741     nx=(uint64_t)A-&gt;<a class="code" href="structcmat.html#a4194b0fe36568f0dd5101cde603cb3c" title="number of rows">nx</a>;
<a name="l02742"></a>02742     ny=(uint64_t)A-&gt;<a class="code" href="structcmat.html#f5f56097ef44115b7454dad413d6bba2" title="number of columns">ny</a>;
<a name="l02743"></a>02743     }
<a name="l02744"></a>02744     <a class="code" href="bin_8c.html#1604f7a3a2eb8ec34d8d22c063458613" title="Write an 1-d or 2-d array into the file.">do_write</a>(fp, 0, <span class="keyword">sizeof</span>(T), M_T, p, nx, ny);
<a name="l02745"></a>02745 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5fc25bdbb6758549b60bc4b9c34a9bef"></a><!-- doxytag: member="cmat.h::ccellwritedata" ref="5fc25bdbb6758549b60bc4b9c34a9bef" args="(file_t *fp, const ccell *dc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellwritedata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to write cell array of dense matrix data. 
<p>
into a file pointer Generally used by library developer <div class="fragment"><pre class="fragment"><a name="l02750"></a>02750                                                     {
<a name="l02751"></a>02751     uint32_t magic=MC_T;
<a name="l02752"></a>02752     <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(&amp;magic, <span class="keyword">sizeof</span>(uint32_t), 1, fp);
<a name="l02753"></a>02753     <span class="keywordflow">if</span>(!dc){
<a name="l02754"></a>02754     uint64_t zero=0;
<a name="l02755"></a>02755     <a class="code" href="bin_8c.html#661981dba53025cce58eb981094679b7" title="Write multiple long numbers into the file.">zfwritelarr</a>(fp, 2, &amp;zero, &amp;zero);
<a name="l02756"></a>02756     }<span class="keywordflow">else</span>{
<a name="l02757"></a>02757     uint64_t nx=dc-&gt;<a class="code" href="structccell.html#b08666a33e3b77dc0ebad13f58cd6f86" title="number of rows">nx</a>;
<a name="l02758"></a>02758     uint64_t ny=dc-&gt;<a class="code" href="structccell.html#02882865ece8aa1dab5515077834d67e" title="number of columns">ny</a>;
<a name="l02759"></a>02759     <a class="code" href="bin_8c.html#661981dba53025cce58eb981094679b7" title="Write multiple long numbers into the file.">zfwritelarr</a>(fp, 2, &amp;nx, &amp;ny);
<a name="l02760"></a>02760     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> iy=0; iy&lt;ny; iy++){
<a name="l02761"></a>02761         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ix=0; ix&lt;nx; ix++){
<a name="l02762"></a>02762         X(writedata)(fp, dc-&gt;<a class="code" href="structccell.html#be5a18937f4edac1e20c91da302d4838" title="Contains an array of pointers to cmat.">p</a>[ix+iy*nx]);
<a name="l02763"></a>02763         }
<a name="l02764"></a>02764     }
<a name="l02765"></a>02765     }
<a name="l02766"></a>02766 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e9df93488639190f0b09a837ba21fd3e"></a><!-- doxytag: member="cmat.h::creaddata" ref="e9df93488639190f0b09a837ba21fd3e" args="(file_t *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* creaddata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to read dense matrix into memory from file pointer. 
<p>
Generally used by library developer. <div class="fragment"><pre class="fragment"><a name="l02789"></a>02789                                {
<a name="l02790"></a>02790     uint32_t magic;
<a name="l02791"></a>02791     <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(&amp;magic, <span class="keyword">sizeof</span>(uint32_t),1,fp);
<a name="l02792"></a>02792     <span class="keywordflow">if</span>(magic!=M_T)
<a name="l02793"></a>02793     error(<span class="stringliteral">"This is not a X(mat) file\n"</span>);
<a name="l02794"></a>02794     uint64_t nx,ny;
<a name="l02795"></a>02795     <a class="code" href="bin_8c.html#f2343993fa331cbf30672791bdf90e7d" title="Read multiple long numbers from the file.">zfreadlarr</a>(fp, 2, &amp;nx, &amp;ny);
<a name="l02796"></a>02796     X(mat) *out;
<a name="l02797"></a>02797     <span class="keywordflow">if</span>(nx==0 || ny==0)
<a name="l02798"></a>02798     out=NULL;
<a name="l02799"></a>02799     <span class="keywordflow">else</span>{
<a name="l02800"></a>02800     out=X(<span class="keyword">new</span>)((long)nx,(<span class="keywordtype">long</span>)ny);
<a name="l02801"></a>02801     <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(out-&gt;p,<span class="keyword">sizeof</span>(T),nx*ny,fp);
<a name="l02802"></a>02802     }
<a name="l02803"></a>02803     <span class="keywordflow">return</span> out;
<a name="l02804"></a>02804 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="41b9a0829de990592462d11aedcb2fa5"></a><!-- doxytag: member="cmat.h::ccellreaddata" ref="41b9a0829de990592462d11aedcb2fa5" args="(file_t *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellreaddata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to read dense matrix cell array into memory from file pointer. 
<p>
Generally used by library developer. <div class="fragment"><pre class="fragment"><a name="l02808"></a>02808                                     {
<a name="l02809"></a>02809     uint32_t magic;
<a name="l02810"></a>02810     <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(&amp;magic, <span class="keyword">sizeof</span>(uint32_t), 1, fp);
<a name="l02811"></a>02811     <span class="keywordflow">if</span>(magic!=MC_T)
<a name="l02812"></a>02812     error(<span class="stringliteral">"This is is not a X(mat) cell file. want %d, get %d\n"</span>,(<span class="keywordtype">int</span>)MC_T,(<span class="keywordtype">int</span>)magic);
<a name="l02813"></a>02813     uint64_t nx,ny;
<a name="l02814"></a>02814     <a class="code" href="bin_8c.html#f2343993fa331cbf30672791bdf90e7d" title="Read multiple long numbers from the file.">zfreadlarr</a>(fp, 2, &amp;nx, &amp;ny);
<a name="l02815"></a>02815     X(cell) *out;
<a name="l02816"></a>02816     <span class="keywordflow">if</span>(nx==0 || ny==0)
<a name="l02817"></a>02817     out=NULL;
<a name="l02818"></a>02818     <span class="keywordflow">else</span>{
<a name="l02819"></a>02819     out=X(cellnew)((long)nx,(<span class="keywordtype">long</span>)ny);
<a name="l02820"></a>02820     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ix=0; ix&lt;nx*ny; ix++){
<a name="l02821"></a>02821         out-&gt;p[ix]=X(readdata)(fp);
<a name="l02822"></a>02822     }
<a name="l02823"></a>02823     }
<a name="l02824"></a>02824     <span class="keywordflow">return</span> out;
<a name="l02825"></a>02825 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c856ab97d0032304beb9cb4fe0465528"></a><!-- doxytag: member="cmat.h::cspwritedata" ref="c856ab97d0032304beb9cb4fe0465528" args="(file_t *fp, const csp *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspwritedata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to write sparse matrix data into file pointed using a file pointer. 
<p>
Generally used by library developer. <div class="fragment"><pre class="fragment"><a name="l02853"></a>02853                                                 {
<a name="l02854"></a>02854     uint32_t magic=M_SPT;
<a name="l02855"></a>02855     <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(&amp;magic, <span class="keyword">sizeof</span>(uint32_t),1,fp);
<a name="l02856"></a>02856     <span class="keywordflow">if</span>(sp){
<a name="l02857"></a>02857     uint64_t m,n,nzmax;
<a name="l02858"></a>02858     m=sp-&gt;<a class="code" href="structcsp.html#2fc683f3c656de7244ea28ba8bba3204" title="number of rows">m</a>;
<a name="l02859"></a>02859     n=sp-&gt;<a class="code" href="structcsp.html#3c3ba5850365cc78c4b4f227ea70eaa9" title="number of columns">n</a>;
<a name="l02860"></a>02860     nzmax=sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[n];<span class="comment">//don't use sp-&gt;nzmax, which maybe larger than actual</span>
<a name="l02861"></a>02861     <a class="code" href="bin_8c.html#661981dba53025cce58eb981094679b7" title="Write multiple long numbers into the file.">zfwritelarr</a>(fp, 3, &amp;m, &amp;n, &amp;nzmax);
<a name="l02862"></a>02862     <span class="keywordflow">if</span>(<span class="keyword">sizeof</span>(*sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>)!=<span class="keyword">sizeof</span>(uint64_t)){
<a name="l02863"></a>02863         <span class="comment">//need to convert data</span>
<a name="l02864"></a>02864         warning(<span class="stringliteral">"Converting data in spwritedata\n"</span>);
<a name="l02865"></a>02865         uint64_t *p,*i;
<a name="l02866"></a>02866         p=malloc(<span class="keyword">sizeof</span>(uint64_t)*(n+1));
<a name="l02867"></a>02867         i=malloc(<span class="keyword">sizeof</span>(uint64_t)*(nzmax));
<a name="l02868"></a>02868         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> j=0; j&lt;n+1; j++){
<a name="l02869"></a>02869         p[j]=sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a>[j];
<a name="l02870"></a>02870         }
<a name="l02871"></a>02871         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> j=0; j&lt;nzmax; j++){
<a name="l02872"></a>02872         i[j]=sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a>[j];
<a name="l02873"></a>02873         }
<a name="l02874"></a>02874         <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(p ,<span class="keyword">sizeof</span>(uint64_t),n+1,fp);
<a name="l02875"></a>02875         <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(i ,<span class="keyword">sizeof</span>(uint64_t),nzmax,fp);
<a name="l02876"></a>02876         free(p); free(i);
<a name="l02877"></a>02877     }<span class="keywordflow">else</span>{
<a name="l02878"></a>02878         <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(sp-&gt;<a class="code" href="structcsp.html#1bcaea71f32f3e914f531bf446620040" title="column pointers (size n+1) or col indlces (size nzmax)">p</a> ,<span class="keyword">sizeof</span>(uint64_t),n+1,fp);
<a name="l02879"></a>02879         <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(sp-&gt;<a class="code" href="structcsp.html#812b9ead226e426b45f9edfaf5545a82" title="row indices, size nzmax">i</a> ,<span class="keyword">sizeof</span>(uint64_t),nzmax,fp);
<a name="l02880"></a>02880     }
<a name="l02881"></a>02881     <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(sp-&gt;<a class="code" href="structcsp.html#84cb4018d85a67a745c1c73720e30fdb" title="numerical values, size nzmax">x</a> ,<span class="keyword">sizeof</span>(T),nzmax,fp);  
<a name="l02882"></a>02882     }<span class="keywordflow">else</span>{
<a name="l02883"></a>02883     uint64_t zero=0;
<a name="l02884"></a>02884     <a class="code" href="bin_8c.html#661981dba53025cce58eb981094679b7" title="Write multiple long numbers into the file.">zfwritelarr</a>(fp, 2, &amp;zero, &amp;zero);
<a name="l02885"></a>02885     }
<a name="l02886"></a>02886 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c52d1399af426794abf242869a2ec077"></a><!-- doxytag: member="cmat.h::cspreaddata" ref="c52d1399af426794abf242869a2ec077" args="(file_t *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspreaddata           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__t.html">file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to read sparse matrix data from file pointer into memory. 
<p>
Used by library developer. <div class="fragment"><pre class="fragment"><a name="l02891"></a>02891                                 {
<a name="l02892"></a>02892     uint32_t magic;
<a name="l02893"></a>02893     <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(&amp;magic, <span class="keyword">sizeof</span>(uint32_t),1,fp);
<a name="l02894"></a>02894     <span class="keywordflow">if</span>(magic!=M_SPT){
<a name="l02895"></a>02895     error(<span class="stringliteral">"This is not a sparse matrix file\n"</span>);
<a name="l02896"></a>02896     }
<a name="l02897"></a>02897     uint64_t m,n,nzmax;
<a name="l02898"></a>02898     <a class="code" href="bin_8c.html#f2343993fa331cbf30672791bdf90e7d" title="Read multiple long numbers from the file.">zfreadlarr</a>(fp, 2, &amp;m, &amp;n);
<a name="l02899"></a>02899     X(sp) *out;
<a name="l02900"></a>02900     <span class="keywordflow">if</span>(m==0 || n==0){
<a name="l02901"></a>02901     out=0;
<a name="l02902"></a>02902     }<span class="keywordflow">else</span>{
<a name="l02903"></a>02903     uint64_t *p;
<a name="l02904"></a>02904     uint64_t *i;
<a name="l02905"></a>02905     <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(&amp;nzmax,<span class="keyword">sizeof</span>(uint64_t),1,fp);
<a name="l02906"></a>02906     out=Y(spnew)(m,n,nzmax);
<a name="l02907"></a>02907     <span class="keywordflow">if</span>(<span class="keyword">sizeof</span>(*out-&gt;p)==<span class="keyword">sizeof</span>(uint64_t)){
<a name="l02908"></a>02908         p=(uint64_t*)out-&gt;p;
<a name="l02909"></a>02909         i=(uint64_t*)out-&gt;i;
<a name="l02910"></a>02910         <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(p, <span class="keyword">sizeof</span>(uint64_t),n+1, fp);
<a name="l02911"></a>02911         <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(i, <span class="keyword">sizeof</span>(uint64_t),nzmax, fp);
<a name="l02912"></a>02912     }<span class="keywordflow">else</span>{
<a name="l02913"></a>02913         p=malloc(<span class="keyword">sizeof</span>(uint64_t)*(n+1));
<a name="l02914"></a>02914         i=malloc(<span class="keyword">sizeof</span>(uint64_t)*(nzmax));
<a name="l02915"></a>02915         <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(p, <span class="keyword">sizeof</span>(uint64_t),n+1, fp);
<a name="l02916"></a>02916         <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(i, <span class="keyword">sizeof</span>(uint64_t),nzmax, fp);
<a name="l02917"></a>02917         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> j=0; j&lt;n+1; j++){
<a name="l02918"></a>02918         out-&gt;p[j]=p[j];
<a name="l02919"></a>02919         }
<a name="l02920"></a>02920         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> j=0; j&lt;nzmax; j++){
<a name="l02921"></a>02921         out-&gt;i[j]=i[j];
<a name="l02922"></a>02922         }
<a name="l02923"></a>02923         free(p);
<a name="l02924"></a>02924         free(i);
<a name="l02925"></a>02925     }
<a name="l02926"></a>02926     <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(out-&gt;x, <span class="keyword">sizeof</span>(T),nzmax, fp);
<a name="l02927"></a>02927     }
<a name="l02928"></a>02928     <span class="keywordflow">return</span> out;
<a name="l02929"></a>02929 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9593e890699be4f48e826d9048018c04"></a><!-- doxytag: member="cmat.h::cwrite" ref="9593e890699be4f48e826d9048018c04" args="(const cmat *A, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcmat.html">cmat</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write dense matrix into a file. 
<p>
Usage: dwrite(A,"A") for double matrix. <div class="fragment"><pre class="fragment"><a name="l02771"></a>02771                                                       {
<a name="l02772"></a>02772     format2fn;
<a name="l02773"></a>02773     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"wb"</span>);
<a name="l02774"></a>02774     X(writedata)(fp, A);
<a name="l02775"></a>02775     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l02776"></a>02776 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e75214457fa1e5c394d311b307a7f5e4"></a><!-- doxytag: member="cmat.h::ccellwrite" ref="e75214457fa1e5c394d311b307a7f5e4" args="(const ccell *dc, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccellwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structccell.html">ccell</a> *&nbsp;</td>
          <td class="paramname"> <em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write cell array of dense matrix into a file. 
<p>
Usage: dcellwrite(A,"A.bin.gz") for double matrix cell. <div class="fragment"><pre class="fragment"><a name="l02780"></a>02780                                                             {
<a name="l02781"></a>02781     format2fn;
<a name="l02782"></a>02782     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"wb"</span>);
<a name="l02783"></a>02783     X(cellwritedata)(fp,dc);
<a name="l02784"></a>02784     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l02785"></a>02785 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d68739105dfbaca4f86b98fe0666f259"></a><!-- doxytag: member="cmat.h::cread" ref="d68739105dfbaca4f86b98fe0666f259" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read dense matrix into memory from file. 
<p>
Usage: A=dread("A.bin.gz"); for a <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> <div class="fragment"><pre class="fragment"><a name="l02829"></a>02829                                        {
<a name="l02830"></a>02830     format2fn;
<a name="l02831"></a>02831     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"rb"</span>);
<a name="l02832"></a>02832     X(mat) *out=X(readdata)(fp);
<a name="l02833"></a>02833     <a class="code" href="bin_8c.html#fb7723b26befc0c6f2a95a7e1a516201" title="Tell whether we end of file is reached.">zfeof</a>(fp);
<a name="l02834"></a>02834     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l02835"></a>02835     <span class="keywordflow">return</span> out;
<a name="l02836"></a>02836 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0a22a48812769ec4f65d0cc94b727059"></a><!-- doxytag: member="cmat.h::ccellread" ref="0a22a48812769ec4f65d0cc94b727059" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read cell array of dense matrix into memory from file. 
<p>
Usage: A=dcellread("A.bin.gz"); for a double <a class="el" href="structdcell.html" title="an 2-d block matrix of dmat.">dcell</a>. <div class="fragment"><pre class="fragment"><a name="l02841"></a>02841                                             {
<a name="l02842"></a>02842     format2fn;
<a name="l02843"></a>02843     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"rb"</span>);
<a name="l02844"></a>02844     X(cell) *out=X(cellreaddata)(fp);
<a name="l02845"></a>02845     <a class="code" href="bin_8c.html#fb7723b26befc0c6f2a95a7e1a516201" title="Tell whether we end of file is reached.">zfeof</a>(fp);
<a name="l02846"></a>02846     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l02847"></a>02847     <span class="keywordflow">return</span> out;
<a name="l02848"></a>02848 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ffeec010de1565a36f9d12612f9fae2f"></a><!-- doxytag: member="cmat.h::cspwrite" ref="ffeec010de1565a36f9d12612f9fae2f" args="(const csp *sp, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcsp.html">csp</a> *&nbsp;</td>
          <td class="paramname"> <em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write sparse matrix into file. 
<p>
Usage: spwrite(A,"A.bin.gz"); <div class="fragment"><pre class="fragment"><a name="l02936"></a>02936                                                         {
<a name="l02937"></a>02937     format2fn;
<a name="l02938"></a>02938     <span class="comment">//write the sparse matrix to file to later load from matlab</span>
<a name="l02939"></a>02939     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"wb"</span>);
<a name="l02940"></a>02940     Y(spwritedata)(fp, sp);
<a name="l02941"></a>02941     <span class="comment">//don't worry about the warning of 0x401ee45 in valgrind. That is the IO </span>
<a name="l02942"></a>02942     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l02943"></a>02943 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0b8af4e4788bab83b6a9ed7a70017066"></a><!-- doxytag: member="cmat.h::cspcellwrite" ref="0b8af4e4788bab83b6a9ed7a70017066" args="(const cspcell *spc, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cspcellwrite           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcspcell.html">cspcell</a> *&nbsp;</td>
          <td class="paramname"> <em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to write cell array of sparse matrix into file. 
<p>
Usage: spcellwrite(A,"A.bin.gz"); <div class="fragment"><pre class="fragment"><a name="l02948"></a>02948                                                                  {
<a name="l02949"></a>02949     format2fn;
<a name="l02950"></a>02950     uint32_t magic=MC_SPT;
<a name="l02951"></a>02951     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"wb"</span>);
<a name="l02952"></a>02952     <a class="code" href="bin_8c.html#67c349fe1033d91feb34b436dbb7e6b3" title="Write to the file.">zfwrite</a>(&amp;magic, <span class="keyword">sizeof</span>(uint32_t), 1, fp);
<a name="l02953"></a>02953     <span class="keywordflow">if</span>(spc){
<a name="l02954"></a>02954     uint64_t nx=spc-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>;
<a name="l02955"></a>02955     uint64_t ny=spc-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>;
<a name="l02956"></a>02956     <a class="code" href="bin_8c.html#661981dba53025cce58eb981094679b7" title="Write multiple long numbers into the file.">zfwritelarr</a>(fp, 2, &amp;nx, &amp;ny);
<a name="l02957"></a>02957     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> iy=0; iy&lt;spc-&gt;<a class="code" href="structcspcell.html#2000cf8ce69a38a69473e4b681adb21a" title="number of columns">ny</a>; iy++){
<a name="l02958"></a>02958         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ix=0; ix&lt;spc-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>; ix++){
<a name="l02959"></a>02959         Y(spwritedata)(fp, spc-&gt;<a class="code" href="structcspcell.html#06df329300f7b799f44ef08a5008e0e8" title="Contains an array of pointers to csp.">p</a>[ix+iy*spc-&gt;<a class="code" href="structcspcell.html#53908c34870ae6094f472897f2be9a7e" title="number of rows">nx</a>]);
<a name="l02960"></a>02960         }
<a name="l02961"></a>02961     }
<a name="l02962"></a>02962     }<span class="keywordflow">else</span>{
<a name="l02963"></a>02963     uint64_t zero=0;
<a name="l02964"></a>02964     <a class="code" href="bin_8c.html#661981dba53025cce58eb981094679b7" title="Write multiple long numbers into the file.">zfwritelarr</a>(fp, 2, &amp;zero, &amp;zero);
<a name="l02965"></a>02965     }
<a name="l02966"></a>02966     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l02967"></a>02967 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="65b955d360ccf1d72c40d93d9b6e077e"></a><!-- doxytag: member="cmat.h::cspread" ref="65b955d360ccf1d72c40d93d9b6e077e" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcsp.html">csp</a>* cspread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read sparse metrix from file. 
<p>
Usage: A=spread("A.bin.gz"); <div class="fragment"><pre class="fragment"><a name="l02972"></a>02972                                         {
<a name="l02973"></a>02973     format2fn;
<a name="l02974"></a>02974     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"rb"</span>);
<a name="l02975"></a>02975     X(sp) *out=Y(spreaddata)(fp);
<a name="l02976"></a>02976     <a class="code" href="bin_8c.html#fb7723b26befc0c6f2a95a7e1a516201" title="Tell whether we end of file is reached.">zfeof</a>(fp);
<a name="l02977"></a>02977     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l02978"></a>02978     <span class="keywordflow">return</span> out;
<a name="l02979"></a>02979 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1e52a56ac12aa2823536f0c9e4c20584"></a><!-- doxytag: member="cmat.h::cspcellread" ref="1e52a56ac12aa2823536f0c9e4c20584" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcspcell.html">cspcell</a>* cspcellread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User callable function to read cell array of sparse matrix from file. 
<p>
Usage: A=spcellread("A.bin.gz"); <div class="fragment"><pre class="fragment"><a name="l02984"></a>02984                                                 {
<a name="l02985"></a>02985     format2fn;
<a name="l02986"></a>02986     uint32_t magic;
<a name="l02987"></a>02987     <a class="code" href="structfile__t.html" title="contains information about opened files.">file_t</a> *fp=<a class="code" href="bin_8c.html#3d9545eb7bf658ee050828326040278c" title="Open the file and return a file_t struct that either contains a file descriptor (for...">zfopen</a>(fn,<span class="stringliteral">"rb"</span>);
<a name="l02988"></a>02988     <a class="code" href="bin_8c.html#6f90c7b343cad172afd005feb5112c30" title="Read from the file.">zfread</a>(&amp;magic, <span class="keyword">sizeof</span>(uint32_t), 1, fp);
<a name="l02989"></a>02989     <span class="keywordflow">if</span>(magic!=MC_SPT)
<a name="l02990"></a>02990     error(<span class="stringliteral">"%s is not a sparse cell file. want %d, got %u\n"</span>, fn,
<a name="l02991"></a>02991           MC_SPT, magic);
<a name="l02992"></a>02992     uint64_t nx,ny;
<a name="l02993"></a>02993     <a class="code" href="bin_8c.html#f2343993fa331cbf30672791bdf90e7d" title="Read multiple long numbers from the file.">zfreadlarr</a>(fp, 2, &amp;nx, &amp;ny);
<a name="l02994"></a>02994     Y(<a class="code" href="structspcell.html" title="an 2-d array of sparse.">spcell</a>) *out;
<a name="l02995"></a>02995     <span class="keywordflow">if</span>(nx==0 || ny==0)
<a name="l02996"></a>02996     out=NULL;
<a name="l02997"></a>02997     <span class="keywordflow">else</span>{
<a name="l02998"></a>02998     out=Y(spcellnew)(nx,ny);
<a name="l02999"></a>02999     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ix=0; ix&lt;nx*ny; ix++){
<a name="l03000"></a>03000         out-&gt;p[ix]=Y(spreaddata)(fp);
<a name="l03001"></a>03001     }
<a name="l03002"></a>03002     }
<a name="l03003"></a>03003     <a class="code" href="bin_8c.html#fb7723b26befc0c6f2a95a7e1a516201" title="Tell whether we end of file is reached.">zfeof</a>(fp);
<a name="l03004"></a>03004     <a class="code" href="bin_8c.html#4ed840d37c980314e41e565e7dd617d3" title="Close the file.">zfclose</a>(fp);
<a name="l03005"></a>03005     <span class="keywordflow">return</span> out;
<a name="l03006"></a>03006 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ac8504a7fc144e552e678c6543c34e8c"></a><!-- doxytag: member="cmat.h::cnew_mmap" ref="ac8504a7fc144e552e678c6543c34e8c" args="(long nx, long ny, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmat.html">cmat</a>* cnew_mmap           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(mat) matrix object, mmapped from file. 
<p>
be aware that the data is not 8-byte aligned. The file is truncated if already exists. <div class="fragment"><pre class="fragment"><a name="l03034"></a>03034                                                               {
<a name="l03035"></a>03035     <span class="keywordflow">if</span>(!nx || !ny) <span class="keywordflow">return</span> NULL;
<a name="l03036"></a>03036     format2fn;
<a name="l03037"></a>03037     <span class="keywordtype">int</span> fd=mmap_open(fn);
<a name="l03038"></a>03038     <span class="keywordtype">size_t</span> headersize=2*<span class="keyword">sizeof</span>(long)+<span class="keyword">sizeof</span>(uint32_t);
<a name="l03039"></a>03039     <span class="keywordtype">size_t</span> msize=nx*ny*<span class="keyword">sizeof</span>(T)+headersize;
<a name="l03040"></a>03040     <span class="keywordflow">if</span>(ftruncate(fd, msize)){
<a name="l03041"></a>03041     error(<span class="stringliteral">"Error truncating file\n"</span>);
<a name="l03042"></a>03042     }
<a name="l03043"></a>03043     <span class="keywordtype">char</span> *map=mmap(NULL, msize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
<a name="l03044"></a>03044     memset(map, 0, msize);
<a name="l03045"></a>03045     close(fd);
<a name="l03046"></a>03046     mmap_header(map, M_T, nx, ny);
<a name="l03047"></a>03047     X(mat) *out=X(new_data)((T*)(map+headersize), nx, ny);
<a name="l03048"></a>03048     out-&gt;type=MT_MMAP;
<a name="l03049"></a>03049     <span class="keywordflow">return</span> out;
<a name="l03050"></a>03050 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0ad4e8669ecf08ee0f0811d9eb24544d"></a><!-- doxytag: member="cmat.h::ccellnew_mmap" ref="0ad4e8669ecf08ee0f0811d9eb24544d" args="(long nx, long ny, long *nnx, long *nny, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellnew_mmap           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>nnx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>nny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(cell) matrix cell object, mmapped from file. 
<p>
be aware that the data is not 8-byte aligned. The file is truncated if already exists. <div class="fragment"><pre class="fragment"><a name="l03055"></a>03055                                                                                          {
<a name="l03056"></a>03056     <span class="keywordflow">if</span>(!nx || !ny) <span class="keywordflow">return</span> NULL;
<a name="l03057"></a>03057     format2fn;
<a name="l03058"></a>03058     <span class="keywordtype">int</span> fd=mmap_open(fn);
<a name="l03059"></a>03059     <span class="keywordtype">long</span> headersize=<span class="keyword">sizeof</span>(long)*2+<span class="keyword">sizeof</span>(uint32_t);
<a name="l03060"></a>03060     <span class="keywordtype">long</span> msize=headersize;
<a name="l03061"></a>03061     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;nx*ny; ix++){
<a name="l03062"></a>03062     msize+=headersize+nnx[ix]*nny[ix]*<span class="keyword">sizeof</span>(T);
<a name="l03063"></a>03063     }
<a name="l03064"></a>03064     <span class="keywordflow">if</span>(ftruncate(fd, msize)){
<a name="l03065"></a>03065     error(<span class="stringliteral">"Error truncating file\n"</span>);
<a name="l03066"></a>03066     }
<a name="l03067"></a>03067     <span class="keywordtype">char</span> *map=mmap(NULL, msize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
<a name="l03068"></a>03068     memset(map, 0, msize);
<a name="l03069"></a>03069     close(fd);
<a name="l03070"></a>03070     X(cell) *out=X(cellnew)(nx,ny);
<a name="l03071"></a>03071     out-&gt;type=MT_MMAP;
<a name="l03072"></a>03072     mmap_header(map, MC_T, nx, ny);
<a name="l03073"></a>03073     map+=headersize;<span class="comment">//header of cell</span>
<a name="l03074"></a>03074     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;nx*ny; ix++){
<a name="l03075"></a>03075     mmap_header(map, M_T, nnx[ix], nny[ix]);
<a name="l03076"></a>03076     out-&gt;p[ix]=X(new_data)((T*)(map+headersize), nnx[ix], nny[ix]);
<a name="l03077"></a>03077     <span class="keywordflow">if</span>(out-&gt;p[ix]) {
<a name="l03078"></a>03078         out-&gt;p[ix]-&gt;type=MT_MMAP;
<a name="l03079"></a>03079     }
<a name="l03080"></a>03080     map+=nnx[ix]*nny[ix]*<span class="keyword">sizeof</span>(T)+headersize;
<a name="l03081"></a>03081     }
<a name="l03082"></a>03082 
<a name="l03083"></a>03083     <span class="keywordflow">return</span> out;
<a name="l03084"></a>03084 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2c1c6578e7f7960142a73e928f6cd192"></a><!-- doxytag: member="cmat.h::ccellnewsame_mmap" ref="2c1c6578e7f7960142a73e928f6cd192" args="(long nx, long ny, long mx, long my, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structccell.html">ccell</a>* ccellnewsame_mmap           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new X(cell) matrix cell object, with identical blocks, mmapped from file. 
<p>
be aware that the data is not 8-byte aligned. The file is truncated if already exists. <div class="fragment"><pre class="fragment"><a name="l03089"></a>03089                                                                                          {
<a name="l03090"></a>03090     <span class="keywordflow">if</span>(!nx || !ny) <span class="keywordflow">return</span> NULL;
<a name="l03091"></a>03091     format2fn;
<a name="l03092"></a>03092     <span class="keywordtype">int</span> fd=mmap_open(fn);
<a name="l03093"></a>03093     <span class="keywordtype">long</span> headersize=<span class="keyword">sizeof</span>(long)*2+<span class="keyword">sizeof</span>(uint32_t);
<a name="l03094"></a>03094     <span class="keywordtype">long</span> msize=headersize;
<a name="l03095"></a>03095     msize=headersize+nx*ny*(headersize+mx*my*<span class="keyword">sizeof</span>(T));
<a name="l03096"></a>03096     <span class="keywordflow">if</span>(ftruncate(fd, msize)){
<a name="l03097"></a>03097     error(<span class="stringliteral">"Error truncating file\n"</span>);
<a name="l03098"></a>03098     }
<a name="l03099"></a>03099     <span class="keywordtype">char</span> *map=mmap(NULL, msize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
<a name="l03100"></a>03100     memset(map, 0, msize);
<a name="l03101"></a>03101     close(fd);
<a name="l03102"></a>03102     X(cell) *out=X(cellnew)(nx,ny);
<a name="l03103"></a>03103     out-&gt;type=MT_MMAP;
<a name="l03104"></a>03104     mmap_header(map, MC_T, nx, ny);
<a name="l03105"></a>03105     map+=headersize;<span class="comment">//header of cell</span>
<a name="l03106"></a>03106     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> ix=0; ix&lt;nx*ny; ix++){
<a name="l03107"></a>03107     mmap_header(map, M_T, mx, my);
<a name="l03108"></a>03108     out-&gt;p[ix]=X(new_data)((T*)(map+headersize), mx, my);
<a name="l03109"></a>03109     <span class="keywordflow">if</span>(out-&gt;p[ix]){
<a name="l03110"></a>03110         out-&gt;p[ix]-&gt;type=MT_MMAP;
<a name="l03111"></a>03111     }
<a name="l03112"></a>03112     map+=mx*my*<span class="keyword">sizeof</span>(T)+headersize;
<a name="l03113"></a>03113     }
<a name="l03114"></a>03114     <span class="keywordflow">return</span> out;
<a name="l03115"></a>03115 }
</pre></div>
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Oct 27 12:43:13 2010 for maos-0.6.1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
