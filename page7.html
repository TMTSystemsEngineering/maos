<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>maos-0.7.1: C Fundementals</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="page7">C Fundementals </a></h1>The user is required to have a good understanding of the C fundementals, like the pointer, to study and improve the code.<p>
Here we list a few to remind the user.<h2><a class="anchor" name="sect-array">
Arrays</a></h2>
If you declare an array: <code>double a[1024];</code> the symbol actually contains the address of a 1024x8 byte memory region that is automatically allocated in the stack (malloc, calloc allocations memory in the heap). Suppost the address of the memory region is 0xFF00. Assignment <code>a[0]=1;</code> puts 1 in memory started at 0xFF00 <code>a[1]=1;</code> puts 1 in memory started at 0xFF08.<p>
Stack is the memory region allocated dynamically when calling a function. All variables reside in stack are automatically deleted when the function returns.<p>
Heap is the memory reservoir. The functions malloc, calloc, realloc reserves memory in the heap while free removes the reservation.<h2><a class="anchor" name="sect-pointer">
Pointers</a></h2>
A pointer is a variable that stores the address of a memory region. <code>void *p;</code><p>
is a basic pointer that just stores the address and can not do any thing about the memory it points to. Its value can be assigned to any other non const vectr or from any vector (1d or 2d).<p>
However, a normal pointer like <code>double *p;</code> also contains information about the memory it points to. More specifically, the compiler know the length of each element so that it can compute the address offset of the elements, just like arrays.<p>
For example: <code>double *p;</code> if p contains value of 0xFF00.<p>
<code>p[0]=1;</code>will store a double 1 into memory region at 0xFF00<p>
<code>p[1]=1;</code>will store a double 1 into memory region at 0xFF08 because a double requires 8 bytes.<p>
<code>p=p+1;</code>p will now contain 0xFF08, i.e., points to the next element, instead of 0xFF01<p>
<code>p[0]=1;</code> is strictly equivalent to <code>*p=1;</code> *p means visit the memory pointed by p instead of p itself. <code>p[1]=1;</code> is strictly equivalent to <code>*(p+1)=1;</code><h3><a class="anchor" name="sect-1d-pointer">
1D Pointers</a></h3>
The simplist usage of pointer is to create and index an 1-D array: <code>double *p;</code>.<p>
<code>p=calloc(1024, sizeof(double));</code> Allocate a memory block of 1024x8 byte and store its address in p.<p>
<code>p[0]=1;</code> will assign 1 to the first number in the array<p>
This is equivalent to using the arrays.<p>
<code>double a[1024];</code> Declare an 1-D array.<p>
<code>a[0]=1;</code> will assign 1 to the first number in the array. The symbol a is like a constant pointer. We can assign it's value to a constant pointer:<p>
<code>double *const p=a;</code><p>
<code>p[0]=1;</code><h3><a class="anchor" name="sect-const">
Const pointers vs. pointers point to const memory</a></h3>
Beware about a const pointer and pointer that points to constant memory regions:<p>
<code>const double *p;</code>p is a pointer that points to a memory region that can not be changed. Thus <code>p[0]=1;</code> is illegal.<p>
<code>double * const p;</code>p is a constant pointer that can not have its value changed. Thus <code>p=a</code> is illegal, unless you assign at declaration: <code>double *const p=a</code>. However, it is legal to modify the values in the memory p points to: <code>p[0]=1;</code>.<h3><a class="anchor" name="sect-2d-pointer">
2D Pointers</a></h3>
A 2D pointer is like a 1D pointer. It stores the address of a memory region. However, unlike the 1D pointer, the compiler knows some additional infos about the 2D pointer. The compiler knows the length of the first dimension so that is can compute the memory location given 2D index like a[2][3]; <code>double (*p)[2]=calloc(3*2,sizeof(double))</code> can be used in the same way as <code>double a[3][2]</code>. The last index changes fastest.<p>
The pointer p in our <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> (or <a class="el" href="structcmat.html" title="a double complex matrix object contains 2-d arrays of double complex numbers.">cmat</a>) struct points to the allocated memory. It can be cast to a two-d vector to facilitize visiting of the elements. The cast is conveniently done by PDMAT(a,pa) for <a class="el" href="structdmat.html" title="a double matrix object contains 2-d array of double numbers">dmat</a> a, which simply declares a 2-d pointer and assign a-&gt;p to it:<p>
<code>double (pa*)[2]=(void*)a-&gt;p</code>. a-&gt;p is first cast to void * because it is a double * and can not be assigned to double (*)[2] directly. The array elements (ix,jy) can be accessed by pa[iy][ix]. Notice that ix changes fastest. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Nov 3 13:02:52 2010 for maos-0.7.1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
