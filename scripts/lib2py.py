#!/usr/bin/env python

#2019-07-18 First version

#Convert functions defined in aolib.h to aoslib.py that is callable by Python
#derived from lib2mex.py

#from __future__ import print_function
import sys
import maos
from pathlib import Path
import json
if len(sys.argv)>2:
    srcdir=sys.argv[1];
    fnout=sys.argv[2];
else:
    srcdir=srcdir=str(Path.home())+'/work/programming/aos'
    fnout='../scripts/libaos.py'

simu_all=list();

headlist=['maos/parms.h','maos/types.h','lib/accphi.h','lib/cn2est.h','lib/kalman.h',
          'lib/locfft.h','lib/muv.h','lib/servo.h','lib/stfun.h','lib/turbulence.h',
          'lib/mkdtf.h', 'math/chol.h','sys/scheduler.h']
structs=maos.parse_structs(srcdir, headlist)

funcs=maos.parse_func(srcdir, structs, ['mex/aolib.h'])

fpout=open(fnout,'w')
print("#!/usr/bin/env python", file=fpout)
print("\n#Do not modify! This file is automatically generated by lib2py.py.\n", file=fpout)
print("from interface import *", file=fpout)

#map between MAOS C types and python types
aotype2py={
    'dmat':'cell',
    'lmat':'cell',
    'cmat':'cell',
    'smat':'cell',
    'cell':'cell',
    'loc_t':'loc',
    'dsp':'csc',
    'csp':'csc',
    'ssp':'csc',
    'zsp':'csc',
    'char':'c_char',
    'double':'c_double',
    'long':'c_long',
    'int':'c_int',
    'void':'',
}
#process variable type
def handle_type(argtype, argname):
    isout=0;
    isref=0;
  
    if argtype[-2:]=='**': #output
        isout=1;
        isref=1
        argtype=argtype[:-2]
    elif argtype[-1:]=='*': #pointer
        isref=1;
        argtype=argtype[:-1]

    if argtype[-4:]=='cell':
        argtype='cell'
    pytype=aotype2py.get(argtype, None)
    if pytype is None: #represent as a struct
        py2c='py2struct('+argname+')'
    elif pytype=='cell':#arbitrary array
        py2c='py2cell('+argname+')'
    else:
        py2c=pytype+'('+argname+')'
    if isref:
        if pytype=='cell' or pytype=='loc':
            py2c='byref('+py2c+')'
        elif pytype=='c_char':
            py2c='c_char_p('+argname+')'
        else:
            py2c=argname+'.ctypes.data_as(c_void_p)'

    if isout:
        prep1=argname+'=POINTER('+pytype+')'
        prep2='pt2py('+argname+')'
    else:
        prep1=''
        prep2=''
    return (py2c, prep1, prep2)

#process function type
def handle_output(funtype, funname):
  
    if funtype[-1:]=='*': #pointer
        ispointer=1;
        funtype=funtype[:-1]
    else:
        ispointer=0
    if funtype[-4:]=='cell':
        funtype='cell'
    fun_arg=aotype2py.get(funtype, None)
    if fun_arg is None:#represent as a struct
        fun_arg='make_class(\''+funtype+'\''+','+json.dumps(structs.get(funtype,None))+')'
    if ispointer:
        fun_val='pt2py(out)'
        fun_arg='POINTER('+fun_arg+')'
    else:
        fun_val='out'

    return ('lib.'+funname+'.restype='+fun_arg, fun_val)

funcalls=list()
for funname in funcs: #loop over functions
    funtype=funcs[funname][0]  #function return type
    funargs=funcs[funname][1]  #Function arguments
    funname2=funcs[funname][2] #C function name
    nargs=len(funargs)
    fundef=''
    fundef_free=''
    pointer_output=''
    funout=''
   
    #Define Python function 
    pyargin=''
    argin=''
    argout=''
    prepout=''
    fun_arg, fun_val=handle_output(funtype, funname2)
    if funtype!='void': #with C outupt
        argout+=fun_val+','
        funname1='out='
    else:
        funname1=''

    for arg in funargs: #loop over the arguments
        argtype=arg[0]
        argname=arg[1]
        if argname == 'loc':
            argname = 'loc_'
        if argname == 'input':
            argname = 'input_'
        py2c, prep1, prep2=handle_type(argtype, argname)
        argin+=py2c+','
        if prep1: #output argument
            prepout+='    '+prep1+'\n'
            argout+=prep2+','
        else: #input argument
            pyargin+=argname+','

    if pyargin[-1]==',':
        pyargin=pyargin[0:-1]
    if argin[-1]==',':
        argin=argin[0:-1]
    if len(argout)>0 and argout[-1]==',':
        argout=argout[0:-1]
    if len(prepout)>0 and prepout[-1]=='\n':
        prepout=prepout[0:-1]
    fundef+='def '+funname+'('+pyargin+'):'   #def function 
    if funtype!='void':
        fundef+='\n    '+fun_arg          #C function return type
    if len(prepout)>0:
        fundef+='\n'+prepout          #C function arguments
    fundef+='\n    '+funname1+'lib.'+funname2+'('+argin+')'
    if len(argout)>0:
        fundef+='\n    return ('+argout+')'

    if(fundef.find('Unknown'))>-1:
        print("'''", file=fpout)
    print(fundef, file=fpout);
    if(fundef.find('Unknown'))>-1:
        print("'''", file=fpout)
fpout.close()
